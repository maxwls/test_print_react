/*
Stimulsoft.Reports.JS
Version: 2022.1.2
Build date: 2022.07.11
License: https://www.stimulsoft.com/en/licensing/reports
*/
!function(e){
!('undefined' != typeof process && process.__nwjs) && 'object' == typeof exports && 'undefined' != typeof module ? module.exports = ((s) => Object.assign(s, e(s.Stimulsoft)))(require('./stimulsoft.reports.engine.src'))
: 'function' == typeof define && define.amd ? define(['./stimulsoft.reports.engine.src'], (s) => Object.assign(s, e(s.Stimulsoft)))
: window.Stimulsoft ? window.Stimulsoft.Report ? Object.assign(window, e(window.Stimulsoft)) : window.Stimulsoft.exportFactory = e : window.Stimulsoft = {exportFactory: e}
}(function (Stimulsoft) {function defaultsDeep(object, defaults) {
    for (var key in defaults) {
        if (!(key in object)) {
            object[key] = defaults[key];
        } else {
            defaultsDeep(object[key], defaults[key]);
        }
    }
    return object;
}
var Stimulsoft = defaultsDeep(Stimulsoft || {}, { Report: { Export: {} } });
var __ = {};
__.a = Stimulsoft.Report;
__.b = __.a.Export;
Stimulsoft.tsfb = function (thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator['throw'](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
let StiMath = Stimulsoft.System.StiMath;
let Char = Stimulsoft.System.Char;
let StiCheckBox = __.a.Components.StiCheckBox;
let CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
let StiZipWriter20 = Stimulsoft.Base.Zip.StiZipWriter20;
let ImageFormat = __.a.ImageFormat;
let IStiExportImageExtended = __.a.Components.IStiExportImageExtended;
let StiText = __.a.Components.StiText;
let StiArray = Stimulsoft.System.StiArray;
let Hashtable = Stimulsoft.System.Collections.Hashtable;
let StiPageOrientation = __.a.Components.StiPageOrientation;
let StiPagesCollection = __.a.Components.StiPagesCollection;
let DateTime = Stimulsoft.System.DateTime;
let Formatting = Stimulsoft.System.Xml.Formatting;
let XmlTextWriter = Stimulsoft.System.Xml.XmlTextWriter;
let Encoding = Stimulsoft.System.Text.Encoding;
let StreamWriter = Stimulsoft.System.IO.StreamWriter;
let Color = Stimulsoft.System.Drawing.Color;
let StiString = Stimulsoft.System.StiString;
let MemoryStream = Stimulsoft.System.IO.MemoryStream;
let StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
let StiTextHorAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment;
let StiVertAlignment = Stimulsoft.Base.Drawing.StiVertAlignment;
{
    let CellStyleData = class {
        constructor() {
            this.BorderLeft = 'none';
            this.BorderRight = 'none';
            this.BorderTop = 'none';
            this.BorderBottom = 'none';
            this.BackColor = Color.transparent;
            this.VertAlign = StiVertAlignment.Bottom;
            this.FontName = 'Arial';
            this.FontSize = 6;
            this.Bold = false;
            this.Italic = false;
            this.Underline = false;
            this.FontColor = Color.black;
            this.HorAlign = StiTextHorAlignment.Left;
            this.Angle = 0;
            this.Wordwrap = false;
            this.DataStyle = -1;
        }
    };
    let DataStyleData = class {
        constructor() {
            this.isNumeric = false;
            this.isCurrency = false;
            this.isPercent = false;
            this.isDate = false;
            this.isTime = false;
            this.isDefaultFormat = false;
            this.DecimalDigits = 2;
            this.DecimalComma = ' ';
            this.GroupDigits = 0;
            this.CurrencySymbol = '$';
            this.CurrencyPositionBefore = false;
            this.NegativeBraces = false;
            this.DateTimeFormatString = null;
            this.CurrencyPositivePattern = null;
            this.CurrencyNegativePattern = null;
        }
    };
    __.b.StiOdsExportService = class extends __.b.StiExportService {
        constructor() {
            super(...arguments);
            this.multipleFiles = false;
            this.matrix = null;
            this.imageCache = null;
            this.cellStyleList = null;
            this.dataStyleList = null;
            this.sheetNameList = null;
            this.matrixList = null;
            this.firstPageIndexList = null;
            this.minRowList = null;
            this.maxRowList = null;
            this.cellStyleTableList = null;
            this.imageQuality = 0.75;
            this.imageResolution = 96;
            this.xmlIndentation = 1;
        }
        implements() {
            return [__.b.IStiOdsExportService];
        }
        get defaultExtension() {
            return 'ods';
        }
        get exportFormat() {
            return __.a.StiExportFormat.Ods;
        }
        get groupCategory() {
            return 'Excel';
        }
        get position() {
            return __.b.StiExportPosition.Ods;
        }
        get exportNameInMenu() {
            return StiLocalization.get('Export', 'ExportTypeCalcFile');
        }
        getFilter() {
            return StiLocalization.get('FileFilters', 'WriteCalcFilesrFiles');
        }
        exportTo(report, stream, settings) {
            this.exportOds(report, stream, settings);
        }
        exportToAsync(onExport, report, stream, settings) {
            setTimeout(() => Stimulsoft.tsfb(this, void 0, void 0, function* () {
                yield __.b.StiExportImageHelper.convertAllImages(report, Stimulsoft.System.Drawing.Imaging.ImageFormat.Jpeg, false, this.exportFormat);
                this.exportTo(report, stream, settings);
                if (report != null && report.preparedExportImages != null) {
                    report.preparedExportImages.clear();
                    report.preparedExportImages = null;
                }
                onExport();
            }));
        }
        doubleToString(numb) {
            return StiMath.round2(numb / 100, 4).toString().stimulsoft().replaceAll(',', '.') + 'in';
        }
        getColumnName(column) {
            let columnHigh = column / 26 | 0;
            let columnLow = column % 26;
            let output = '';
            if (columnHigh > 0) {
                output += String.fromCharCode(65 + columnHigh - 1);
            }
            output += String.fromCharCode(65 + columnLow);
            return output;
        }
        getColorString(color) {
            return '#' + StiString.format('{0:X8}', color.toArgb()).substr(2);
        }
        getCellStyleNumber(indexRow, indexColumn, height, width) {
            let style = new CellStyleData();
            let needBorderLeft = true;
            let needBorderRight = true;
            for (let index = 0; index < height; index++) {
                if (this.matrix.bordersY[indexRow + index][indexColumn] == null)
                    needBorderLeft = false;
                if (this.matrix.bordersY[indexRow + index][indexColumn + width] == null)
                    needBorderRight = false;
            }
            let needBorderTop = true;
            let needBorderBottom = true;
            for (let index = 0; index < width; index++) {
                if (this.matrix.bordersX[indexRow][indexColumn + index] == null)
                    needBorderTop = false;
                if (this.matrix.bordersX[indexRow + height][indexColumn + index] == null)
                    needBorderBottom = false;
            }
            if (needBorderTop)
                style.BorderTop = this.getStringFromBorder(this.matrix.bordersX[indexRow][indexColumn]);
            if (needBorderLeft)
                style.BorderLeft = this.getStringFromBorder(this.matrix.bordersY[indexRow][indexColumn]);
            if (needBorderBottom)
                style.BorderBottom = this.getStringFromBorder(this.matrix.bordersX[indexRow + height][indexColumn]);
            if (needBorderRight)
                style.BorderRight = this.getStringFromBorder(this.matrix.bordersY[indexRow][indexColumn + width]);
            if (this.matrix.cells[indexRow][indexColumn] != null) {
                let cell = this.matrix.cells[indexRow][indexColumn];
                let cellStyle = cell.cellStyle;
                style.BackColor = cellStyle.color;
                style.VertAlign = cellStyle.vertAlignment;
                style.FontName = cellStyle.font.name;
                style.FontSize = cellStyle.font.sizeInPoints;
                style.Bold = cellStyle.font.bold;
                style.Italic = cellStyle.font.italic;
                style.Underline = cellStyle.font.underline;
                style.FontColor = cellStyle.textColor;
                style.HorAlign = cellStyle.horAlignment;
                let textAngle = 0;
                if (cellStyle.textOptions != null) {
                    textAngle = cellStyle.textOptions.angle;
                    style.Wordwrap = cellStyle.textOptions.wordWrap;
                }
                style.Angle = Math.round(textAngle) | 0;
                if (cell.component != null) {
                    let textComp = cell.component.stimulsoft().as(StiText);
                    if (textComp != null)
                        style.DataStyle = this.getDataStyleNumber(textComp);
                    let checkComp = cell.component.stimulsoft().as(StiCheckBox);
                    if (checkComp != null && !StiString.isNullOrEmpty(checkComp.excelDataValue)) {
                        style.FontName = Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.name;
                        style.FontSize = Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.sizeInPoints;
                        style.Bold = Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.bold;
                        style.Italic = Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.italic;
                        style.Underline = Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.underline;
                        style.VertAlign = Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.VertAlignment;
                        style.HorAlign = Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.HorAlignment;
                    }
                }
            }
            if (this.cellStyleList.length > 0) {
                for (let index = 0; index < this.cellStyleList.length; index++) {
                    let tempStyle = this.cellStyleList[index];
                    if (tempStyle.BorderLeft == style.BorderLeft && tempStyle.BorderRight == style.BorderRight && tempStyle.BorderTop == style.BorderTop && tempStyle.BorderBottom == style.BorderBottom && tempStyle.BackColor.equals(style.BackColor) && tempStyle.VertAlign == style.VertAlign && tempStyle.FontName == style.FontName && tempStyle.FontSize == style.FontSize && tempStyle.Bold == style.Bold && tempStyle.Italic == style.Italic && tempStyle.Underline == style.Underline && tempStyle.FontColor.equals(style.FontColor) && tempStyle.HorAlign == style.HorAlign && tempStyle.Angle == style.Angle && tempStyle.Wordwrap == style.Wordwrap && tempStyle.DataStyle == style.DataStyle) {
                        return index;
                    }
                }
            }
            this.cellStyleList.push(style);
            return this.cellStyleList.length - 1;
        }
        getStringFromBorder(border) {
            return StiString.format('{0} solid {1}', this.doubleToString(border.size), this.getColorString(border.color));
        }
        getDataStyleNumber(textComp) {
            let style = new DataStyleData();
            let inputFormat = textComp.format;
            let posPatternDelimiter = inputFormat != null ? inputFormat.indexOf('|') : -1;
            if (posPatternDelimiter != -1) {
                style.CurrencyPositivePattern = __.b.StiExportUtils.getPositivePattern(inputFormat.charCodeAt(posPatternDelimiter + 1) - 65);
                style.CurrencyNegativePattern = __.b.StiExportUtils.getNegativePattern(inputFormat.charCodeAt(posPatternDelimiter + 2) - 65);
                inputFormat = inputFormat.substr(0, posPatternDelimiter);
            }
            if (!StiString.isNullOrEmpty(inputFormat)) {
                if (inputFormat.charAt(0) == 'C')
                    style.isCurrency = true;
                if (inputFormat.charAt(0) == 'N')
                    style.isNumeric = true;
                if (inputFormat.charAt(0) == 'P')
                    style.isPercent = true;
                if (inputFormat.charAt(0) == 'D') {
                    style.isDate = true;
                    if (inputFormat.length > 1)
                        style.DateTimeFormatString = inputFormat.substr(1);
                }
                if (inputFormat.charAt(0) == 'T') {
                    style.isTime = true;
                    if (inputFormat.length > 1)
                        style.DateTimeFormatString = inputFormat.substr(1);
                }
                if (inputFormat.length == 1)
                    style.isDefaultFormat = true;
                else {
                    if (style.isCurrency || style.isNumeric || style.isPercent) {
                        let indexPos = 1;
                        if (Char.isDigit(inputFormat, indexPos)) {
                            let decimalSB = '';
                            while (indexPos < inputFormat.length && Char.isDigit(inputFormat, indexPos)) {
                                decimalSB += inputFormat.charAt(indexPos);
                                indexPos++;
                            }
                            style.DecimalDigits = parseInt(decimalSB);
                        }
                        if (indexPos < inputFormat.length && inputFormat.charAt(indexPos) == 'G') {
                            indexPos++;
                            style.GroupDigits = 3;
                        }
                        if (indexPos < inputFormat.length && inputFormat.charAt(indexPos) == '(') {
                            indexPos++;
                            style.NegativeBraces = true;
                        }
                        if (indexPos < inputFormat.length && (inputFormat.charAt(indexPos) == '.' || inputFormat.charAt(indexPos) == ',')) {
                            style.DecimalComma = inputFormat.charAt(indexPos);
                            indexPos++;
                        }
                        if (indexPos < inputFormat.length && (inputFormat.charAt(indexPos) == '+' || inputFormat.charAt(indexPos) == '-')) {
                            if (inputFormat.charAt(indexPos) == '+')
                                style.CurrencyPositionBefore = true;
                            indexPos++;
                            if (indexPos < inputFormat.length) {
                                style.CurrencySymbol = inputFormat.substr(indexPos);
                            }
                        }
                    }
                }
            } else {
                return -1;
            }
            if (textComp.hideZeros && !StiString.isNullOrEmpty(inputFormat))
                style.isDefaultFormat = false;
            if (this.dataStyleList.length > 0) {
                for (let index = 0; index < this.dataStyleList.length; index++) {
                    let tempStyle = this.dataStyleList.stimulsoft().getByIndex(index);
                    if (tempStyle.isNumeric == style.isNumeric && tempStyle.isCurrency == style.isCurrency && tempStyle.isPercent == style.isPercent && tempStyle.isDate == style.isDate && tempStyle.isTime == style.isTime && tempStyle.isDefaultFormat == style.isDefaultFormat && tempStyle.DecimalDigits == style.DecimalDigits && tempStyle.DecimalComma == style.DecimalComma && tempStyle.GroupDigits == style.GroupDigits && tempStyle.CurrencySymbol == style.CurrencySymbol && tempStyle.CurrencyPositionBefore == style.CurrencyPositionBefore && tempStyle.DateTimeFormatString == style.DateTimeFormatString && tempStyle.CurrencyPositivePattern == style.CurrencyPositivePattern && tempStyle.CurrencyNegativePattern == style.CurrencyNegativePattern) {
                        return index;
                    }
                }
            }
            this.dataStyleList.push(style);
            let temp = this.dataStyleList.stimulsoft().countItems - 1;
            return temp;
        }
        writeMimetype() {
            let ms = new MemoryStream();
            let writer = new StreamWriter(ms, Encoding.ASCII);
            writer.write('application/vnd.oasis.opendocument.spreadsheet');
            writer.flush();
            return ms;
        }
        writeMeta() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('office:document-meta');
            writer.writeAttributeString('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
            writer.writeAttributeString('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeAttributeString('xmlns:meta', 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0');
            writer.writeAttributeString('xmlns:ooo', 'http://openoffice.org/2004/office');
            writer.writeAttributeString('office:version', '1.1');
            writer.writeStartElement('office:meta');
            let dateTime = DateTime.now.toString('yyyy-MM-ddTHH:mm:ss');
            let creator = __.b.StiExportUtils.getReportVersion();
            writer.writeElementString('meta:generator', creator);
            writer.writeElementString('meta:creation-date', dateTime);
            writer.writeElementString('dc:date', dateTime);
            writer.writeElementString('meta:editing-cycles', '1');
            writer.writeElementString('meta:editing-duration', 'PT0M0S');
            writer.writeStartElement('meta:user-defined');
            writer.writeAttributeString('meta:name', 'Info 1');
            writer.writeEndElement();
            writer.writeStartElement('meta:user-defined');
            writer.writeAttributeString('meta:name', 'Info 2');
            writer.writeEndElement();
            writer.writeStartElement('meta:user-defined');
            writer.writeAttributeString('meta:name', 'Info 3');
            writer.writeEndElement();
            writer.writeStartElement('meta:user-defined');
            writer.writeAttributeString('meta:name', 'Info 4');
            writer.writeEndElement();
            writer.writeStartElement('meta:document-statistic');
            writer.writeAttributeString('meta:table-count', '1');
            writer.writeAttributeString('meta:cell-count', '1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeManifest() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('manifest:manifest');
            writer.writeAttributeString('xmlns:manifest', 'urn:oasis:names:tc:opendocument:xmlns:manifest:1.0');
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'application/vnd.oasis.opendocument.spreadsheet');
            writer.writeAttributeString('manifest:full-path', '/');
            writer.writeEndElement();
            for (let index = 0; index < this.imageCache.imagePackedStore.stimulsoft().countItems; index++) {
                writer.writeStartElement('manifest:file-entry');
                writer.writeAttributeString('manifest:media-type', 'image/jpeg');
                writer.writeAttributeString('manifest:full-path', StiString.format('Pictures/{0:D5}.jpg', index + 1));
                writer.writeEndElement();
            }
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'text/xml');
            writer.writeAttributeString('manifest:full-path', 'content.xml');
            writer.writeEndElement();
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'text/xml');
            writer.writeAttributeString('manifest:full-path', 'styles.xml');
            writer.writeEndElement();
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'text/xml');
            writer.writeAttributeString('manifest:full-path', 'meta.xml');
            writer.writeEndElement();
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'text/xml');
            writer.writeAttributeString('manifest:full-path', 'settings.xml');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeImage(numb) {
            let ms = new MemoryStream();
            let buf = this.imageCache.imagePackedStore[numb];
            ms.write(buf, 0, buf.length);
            return ms;
        }
        writeSettings() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('office:document-settings');
            writer.writeAttributeString('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
            writer.writeAttributeString('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            writer.writeAttributeString('xmlns:config', 'urn:oasis:names:tc:opendocument:xmlns:config:1.0');
            writer.writeAttributeString('xmlns:ooo', 'http://openoffice.org/2004/office');
            writer.writeAttributeString('office:version', '1.1');
            writer.writeStartElement('office:settings');
            writer.writeStartElement('config:config-item-set');
            writer.writeAttributeString('config:name', 'ooo:view-settings');
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VisibleAreaTop');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VisibleAreaLeft');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('-10107');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VisibleAreaWidth');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('43208');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VisibleAreaHeight');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('22174');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item-map-indexed');
            writer.writeAttributeString('config:name', 'Views');
            writer.writeStartElement('config:config-item-map-entry');
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ViewId');
            writer.writeAttributeString('config:type', 'string');
            writer.writeString('View1');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item-map-named');
            writer.writeAttributeString('config:name', 'Tables');
            writer.writeStartElement('config:config-item-map-entry');
            writer.writeAttributeString('config:name', 'Sheet1');
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'CursorPositionX');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'CursorPositionY');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'HorizontalSplitMode');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VerticalSplitMode');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'HorizontalSplitPosition');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VerticalSplitPosition');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ActiveSplitRange');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('2');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PositionLeft');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PositionRight');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PositionTop');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PositionBottom');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ActiveTable');
            writer.writeAttributeString('config:type', 'string');
            writer.writeString('Sheet1');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'HorizontalScrollbarWidth');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('270');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ZoomType');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ZoomValue');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('100');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PageViewZoomValue');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('60');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowPageBreakPreview');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowZeroValues');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowNotes');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowGrid');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'GridColor');
            writer.writeAttributeString('config:type', 'long');
            writer.writeString('12632256');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowPageBreaks');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'HasColumnRowHeaders');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'HasSheetTabs');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsOutlineSymbolsSet');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsSnapToRaster');
            writer.writeAttributeString('config:type', 'long');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterIsVisible');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterResolutionX');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1000');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterResolutionY');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1000');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterSubdivisionX');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterSubdivisionY');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsRasterAxisSynchronized');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('config:config-item-set');
            writer.writeAttributeString('config:name', 'ooo:configuration-settings');
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowZeroValues');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowNotes');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowGrid');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'GridColor');
            writer.writeAttributeString('config:type', 'long');
            writer.writeString('12632256');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowPageBreaks');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'LinkUpdateMode');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('3');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'HasColumnRowHeaders');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'HasSheetTabs');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsOutlineSymbolsSet');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsSnapToRaster');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterIsVisible');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterResolutionX');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1000');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterResolutionY');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1000');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterSubdivisionX');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RasterSubdivisionY');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('1');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsRasterAxisSynchronized');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'AutoCalculate');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrinterName');
            writer.writeAttributeString('config:type', 'string');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrinterSetup');
            writer.writeAttributeString('config:type', 'base64Binary');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ApplyUserData');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'CharacterCompressionType');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsKernAsianPunctuation');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'SaveVersionOnClose');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'UpdateFromTemplate');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'AllowPrintJobCancel');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'LoadReadonly');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeStyles(pages) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('office:document-styles');
            writer.writeAttributeString('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
            writer.writeAttributeString('xmlns:style', 'urn:oasis:names:tc:opendocument:xmlns:style:1.0');
            writer.writeAttributeString('xmlns:text', 'urn:oasis:names:tc:opendocument:xmlns:text:1.0');
            writer.writeAttributeString('xmlns:table', 'urn:oasis:names:tc:opendocument:xmlns:table:1.0');
            writer.writeAttributeString('xmlns:draw', 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0');
            writer.writeAttributeString('xmlns:fo', 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0');
            writer.writeAttributeString('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeAttributeString('xmlns:meta', 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0');
            writer.writeAttributeString('xmlns:number', 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0');
            writer.writeAttributeString('xmlns:presentation', 'urn:oasis:names:tc:opendocument:xmlns:presentation:1.0');
            writer.writeAttributeString('xmlns:svg', 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0');
            writer.writeAttributeString('xmlns:chart', 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0');
            writer.writeAttributeString('xmlns:dr3d', 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0');
            writer.writeAttributeString('xmlns:math', 'http://www.w3.org/1998/Math/MathML');
            writer.writeAttributeString('xmlns:form', 'urn:oasis:names:tc:opendocument:xmlns:form:1.0');
            writer.writeAttributeString('xmlns:script', 'urn:oasis:names:tc:opendocument:xmlns:script:1.0');
            writer.writeAttributeString('xmlns:ooo', 'http://openoffice.org/2004/office');
            writer.writeAttributeString('xmlns:ooow', 'http://openoffice.org/2004/writer');
            writer.writeAttributeString('xmlns:oooc', 'http://openoffice.org/2004/calc');
            writer.writeAttributeString('xmlns:dom', 'http://www.w3.org/2001/xml-events');
            writer.writeAttributeString('office:version', '1.1');
            writer.writeStartElement('office:font-face-decls');
            writer.writeStartElement('style:font-face');
            writer.writeAttributeString('style:name', 'Arial');
            writer.writeAttributeString('svg:font-family', 'Arial');
            writer.writeEndElement();
            writer.writeStartElement('style:font-face');
            writer.writeAttributeString('style:name', 'Tahoma');
            writer.writeAttributeString('svg:font-family', 'Tahoma');
            writer.writeAttributeString('style:font-family-generic', 'system');
            writer.writeAttributeString('style:font-pitch', 'variable');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('office:styles');
            writer.writeStartElement('style:default-style');
            writer.writeAttributeString('style:family', 'table-cell');
            writer.writeStartElement('style:table-cell-properties');
            writer.writeAttributeString('style:decimal-places', '2');
            writer.writeEndElement();
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('style:tab-stop-distance', '1.25cm');
            writer.writeEndElement();
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('style:font-name', 'Arial');
            writer.writeAttributeString('fo:language', 'ru');
            writer.writeAttributeString('fo:country', 'RU');
            writer.writeAttributeString('style:font-name-asian', 'Lucida Sans Unicode');
            writer.writeAttributeString('style:language-asian', 'zxx');
            writer.writeAttributeString('style:country-asian', 'none');
            writer.writeAttributeString('style:font-name-complex', 'Tahoma');
            writer.writeAttributeString('style:language-complex', 'zxx');
            writer.writeAttributeString('style:country-complex', 'none');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('number:number-style');
            writer.writeAttributeString('style:name', 'N0');
            writer.writeStartElement('number:number');
            writer.writeAttributeString('number:min-integer-digits', '1');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Default');
            writer.writeAttributeString('style:family', 'table-cell');
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Result');
            writer.writeAttributeString('style:family', 'table-cell');
            writer.writeAttributeString('style:parent-style-name', 'Default');
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('fo:font-style', 'italic');
            writer.writeAttributeString('style:text-underline-style', 'solid');
            writer.writeAttributeString('style:text-underline-width', 'auto');
            writer.writeAttributeString('style:text-underline-color', 'font-color');
            writer.writeAttributeString('fo:font-weight', 'bold');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Heading');
            writer.writeAttributeString('style:family', 'table-cell');
            writer.writeAttributeString('style:parent-style-name', 'Default');
            writer.writeStartElement('style:table-cell-properties');
            writer.writeAttributeString('style:text-align-source', 'fix');
            writer.writeAttributeString('style:repeat-content', 'false');
            writer.writeEndElement();
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('fo:text-align', 'center');
            writer.writeEndElement();
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('fo:font-size', '16pt');
            writer.writeAttributeString('fo:font-style', 'italic');
            writer.writeAttributeString('fo:font-weight', 'bold');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Heading1');
            writer.writeAttributeString('style:family', 'table-cell');
            writer.writeAttributeString('style:parent-style-name', 'Heading');
            writer.writeStartElement('style:table-cell-properties');
            writer.writeAttributeString('style:rotation-angle', '90');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('office:automatic-styles');
            let page = pages.getByIndex(0);
            let pageHeight = page.unit.convertToHInches(page.pageHeight * page.segmentPerHeight);
            let pageWidth = page.unit.convertToHInches(page.pageWidth * page.segmentPerWidth);
            let mgLeft = page.unit.convertToHInches(page.margins.left);
            let mgRight = page.unit.convertToHInches(page.margins.right);
            let mgTop = page.unit.convertToHInches(page.margins.top);
            let mgBottom = page.unit.convertToHInches(page.margins.bottom) - 4;
            if (mgBottom < 0)
                mgBottom = 0;
            writer.writeStartElement('style:page-layout');
            writer.writeAttributeString('style:name', 'pm1');
            writer.writeStartElement('style:page-layout-properties');
            writer.writeAttributeString('fo:page-width', this.doubleToString(pageWidth));
            writer.writeAttributeString('fo:page-height', this.doubleToString(pageHeight));
            writer.writeAttributeString('style:num-format', '1');
            writer.writeAttributeString('style:print-orientation', page.orientation == StiPageOrientation.Portrait ? 'portrait' : 'landscape');
            writer.writeAttributeString('fo:margin-top', this.doubleToString(mgTop));
            writer.writeAttributeString('fo:margin-bottom', this.doubleToString(mgBottom));
            writer.writeAttributeString('fo:margin-left', this.doubleToString(mgLeft));
            writer.writeAttributeString('fo:margin-right', this.doubleToString(mgRight));
            writer.writeAttributeString('style:writing-mode', 'lr-tb');
            writer.writeEndElement();
            writer.writeStartElement('style:header-style');
            writer.writeStartElement('style:header-footer-properties');
            writer.writeAttributeString('fo:min-height', '0.101cm');
            writer.writeAttributeString('fo:margin-left', '0cm');
            writer.writeAttributeString('fo:margin-right', '0cm');
            writer.writeAttributeString('fo:margin-bottom', '0cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:footer-style');
            writer.writeStartElement('style:header-footer-properties');
            writer.writeAttributeString('fo:min-height', '0.101cm');
            writer.writeAttributeString('fo:margin-left', '0cm');
            writer.writeAttributeString('fo:margin-right', '0cm');
            writer.writeAttributeString('fo:margin-top', '0cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('office:master-styles');
            writer.writeStartElement('style:master-page');
            writer.writeAttributeString('style:name', 'Default');
            writer.writeAttributeString('style:page-layout-name', 'pm1');
            writer.writeStartElement('style:header');
            writer.writeAttributeString('style:display', 'false');
            writer.writeStartElement('text:p');
            writer.writeStartElement('text:sheet-name');
            writer.writeString('Sheet1');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:header-left');
            writer.writeAttributeString('style:display', 'false');
            writer.writeEndElement();
            writer.writeStartElement('style:footer');
            writer.writeAttributeString('style:display', 'false');
            writer.writeStartElement('text:p');
            writer.writeString('Page ');
            writer.writeStartElement('text:page-number');
            writer.writeString('1');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:footer-left');
            writer.writeAttributeString('style:display', 'false');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeContent(report, allPages) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('office:document-content');
            writer.writeAttributeString('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
            writer.writeAttributeString('xmlns:style', 'urn:oasis:names:tc:opendocument:xmlns:style:1.0');
            writer.writeAttributeString('xmlns:text', 'urn:oasis:names:tc:opendocument:xmlns:text:1.0');
            writer.writeAttributeString('xmlns:table', 'urn:oasis:names:tc:opendocument:xmlns:table:1.0');
            writer.writeAttributeString('xmlns:draw', 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0');
            writer.writeAttributeString('xmlns:fo', 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0');
            writer.writeAttributeString('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeAttributeString('xmlns:meta', 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0');
            writer.writeAttributeString('xmlns:number', 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0');
            writer.writeAttributeString('xmlns:presentation', 'urn:oasis:names:tc:opendocument:xmlns:presentation:1.0');
            writer.writeAttributeString('xmlns:svg', 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0');
            writer.writeAttributeString('xmlns:chart', 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0');
            writer.writeAttributeString('xmlns:dr3d', 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0');
            writer.writeAttributeString('xmlns:math', 'http://www.w3.org/1998/Math/MathML');
            writer.writeAttributeString('xmlns:form', 'urn:oasis:names:tc:opendocument:xmlns:form:1.0');
            writer.writeAttributeString('xmlns:script', 'urn:oasis:names:tc:opendocument:xmlns:script:1.0');
            writer.writeAttributeString('xmlns:ooo', 'http://openoffice.org/2004/office');
            writer.writeAttributeString('xmlns:ooow', 'http://openoffice.org/2004/writer');
            writer.writeAttributeString('xmlns:oooc', 'http://openoffice.org/2004/calc');
            writer.writeAttributeString('xmlns:dom', 'http://www.w3.org/2001/xml-events');
            writer.writeAttributeString('xmlns:xforms', 'http://www.w3.org/2002/xforms');
            writer.writeAttributeString('xmlns:xsd', 'http://www.w3.org/2001/XMLSchema');
            writer.writeAttributeString('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
            writer.writeAttributeString('office:version', '1.1');
            let indexPage = 0;
            while (indexPage < allPages.count) {
                let pages = new StiPagesCollection(report, allPages);
                pages.addV2Internal(allPages.getByIndex(indexPage));
                let firstPageIndex = indexPage;
                let pageName = allPages.getByIndex(indexPage).excelSheetValue;
                while (indexPage < allPages.count - 1 && allPages.getByIndex(indexPage + 1).excelSheetValue == pageName) {
                    indexPage++;
                    pages.addV2Internal(allPages.getByIndex(indexPage));
                }
                pages.cacheMode = report.renderedPages.cacheMode;
                let sheetName = pages.getByIndex(0).excelSheetValue;
                if (StiString.isNullOrEmpty(sheetName))
                    sheetName = StiString.format('Page {0}', this.sheetNameList.stimulsoft().countItems + 1);
                let sheetSuffix = '';
                let sheetIndex = 1;
                this.matrix = new __.b.StiMatrix(pages, Stimulsoft['StiOptions'].Export.OpenDocumentCalc.divideBigCells, this);
                if (this.isStopped)
                    return null;
                let minRowIndex = 0;
                do {
                    this.firstPageIndexList.push(firstPageIndex);
                    this.matrixList.push(this.matrix);
                    let maxRowIndex = this.matrix.coordY.countItems - 1;
                    if (maxRowIndex - minRowIndex > Stimulsoft['StiOptions'].Export.OpenDocumentCalc.maximumSheetHeight)
                        maxRowIndex = minRowIndex + Stimulsoft['StiOptions'].Export.OpenDocumentCalc.maximumSheetHeight;
                    else
                        this.matrix = null;
                    this.minRowList.push(minRowIndex);
                    this.maxRowList.push(maxRowIndex);
                    minRowIndex = maxRowIndex;
                    if (this.matrix != null || sheetSuffix.length > 0)
                        sheetSuffix = StiString.format(' part{0}', sheetIndex++);
                    this.sheetNameList.push(sheetName + sheetSuffix);
                    if (this.isStopped)
                        return null;
                } while (this.matrix != null);
                indexPage++;
            }
            let rowHeightList = new Hashtable();
            let rowHeightList2 = new Hashtable();
            let colWidthList = new Hashtable();
            let colWidthList2 = new Hashtable();
            for (let indexSheet = 0; indexSheet < this.matrixList.stimulsoft().countItems; indexSheet++) {
                this.matrix = this.matrixList.stimulsoft().getByIndex(indexSheet);
                let minRowIndex = this.minRowList.stimulsoft().getByIndex(indexSheet);
                let maxRowIndex = this.maxRowList.stimulsoft().getByIndex(indexSheet);
                let readyCells = StiArray.create2(Boolean, this.matrix.coordY.countItems, this.matrix.coordX.countItems);
                let cellStyleTable = StiArray.create2(Number, this.matrix.coordY.countItems, this.matrix.coordX.countItems);
                for (let indexColumn = 0; indexColumn < this.matrix.coordX.countItems - 1; indexColumn++) {
                    let columnWidth = this.matrix.coordX.getByIndex(indexColumn + 1) - this.matrix.coordX.getByIndex(indexColumn);
                    if (!colWidthList.containsKey(columnWidth)) {
                        let listPos = colWidthList.count;
                        colWidthList.set(columnWidth, listPos);
                        colWidthList2.set(listPos, columnWidth);
                    }
                }
                for (let indexRow = minRowIndex + 1; indexRow < maxRowIndex + 1; indexRow++) {
                    let rowHeight = this.matrix.coordY.getByIndex(indexRow) - this.matrix.coordY.getByIndex(indexRow - 1);
                    if (!rowHeightList.containsKey(rowHeight)) {
                        let listPos = rowHeightList.count;
                        rowHeightList.set(rowHeight, listPos);
                        rowHeightList2.set(listPos, rowHeight);
                    }
                    for (let indexColumn = 1; indexColumn < this.matrix.coordX.countItems; indexColumn++) {
                        let cell = this.matrix.cells[indexRow - 1][indexColumn - 1];
                        if (!readyCells[indexRow][indexColumn]) {
                            if (cell != null) {
                                for (let yy = 0; yy <= cell.height; yy++) {
                                    for (let xx = 0; xx <= cell.width; xx++) {
                                        readyCells[indexRow + yy][indexColumn + xx] = true;
                                    }
                                }
                                cellStyleTable[indexRow - 1][indexColumn - 1] = this.getCellStyleNumber(indexRow - 1, indexColumn - 1, cell.height + 1, cell.width + 1);
                            } else {
                                cellStyleTable[indexRow - 1][indexColumn - 1] = this.getCellStyleNumber(indexRow - 1, indexColumn - 1, 1, 1);
                            }
                        }
                    }
                }
                this.cellStyleTableList.push(cellStyleTable);
            }
            writer.writeStartElement('office:scripts');
            writer.writeEndElement();
            let fonts = new Hashtable();
            for (let tempStyle of this.cellStyleList) {
                fonts.set(tempStyle.FontName, tempStyle.FontName);
            }
            writer.writeStartElement('office:font-face-decls');
            for (let de of fonts.keys) {
                let fontName = fonts.get(de);
                writer.writeStartElement('style:font-face');
                writer.writeAttributeString('style:name', fontName);
                writer.writeAttributeString('svg:font-family', fontName);
                writer.writeEndElement();
            }
            writer.writeEndElement();
            writer.writeStartElement('office:automatic-styles');
            for (let indexColumn = 0; indexColumn < colWidthList.count; indexColumn++) {
                writer.writeStartElement('style:style');
                writer.writeAttributeString('style:name', StiString.format('co{0}', indexColumn + 1));
                writer.writeAttributeString('style:family', 'table-column');
                writer.writeStartElement('style:table-column-properties');
                writer.writeAttributeString('fo:break-before', 'auto');
                let columnWidth = colWidthList2.get(indexColumn);
                writer.writeAttributeString('style:column-width', this.doubleToString(columnWidth));
                writer.writeEndElement();
                writer.writeEndElement();
            }
            for (let indexRow = 0; indexRow < rowHeightList.count; indexRow++) {
                writer.writeStartElement('style:style');
                writer.writeAttributeString('style:name', StiString.format('ro{0}', indexRow + 1));
                writer.writeAttributeString('style:family', 'table-row');
                writer.writeStartElement('style:table-row-properties');
                let rowHeight = rowHeightList2.get(indexRow);
                writer.writeAttributeString('style:row-height', this.doubleToString(rowHeight));
                writer.writeAttributeString('fo:break-before', 'auto');
                writer.writeAttributeString('style:use-optimal-row-height', 'false');
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'ta1');
            writer.writeAttributeString('style:family', 'table');
            writer.writeAttributeString('style:master-page-name', 'Default');
            writer.writeStartElement('style:table-properties');
            writer.writeAttributeString('table:display', 'true');
            writer.writeAttributeString('style:writing-mode', 'lr-tb');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'gr1');
            writer.writeAttributeString('style:family', 'graphic');
            writer.writeStartElement('style:graphic-properties');
            writer.writeAttributeString('draw:stroke', 'none');
            writer.writeAttributeString('draw:fill', 'none');
            writer.writeAttributeString('draw:textarea-horizontal-align', 'center');
            writer.writeAttributeString('draw:textarea-vertical-align', 'middle');
            writer.writeAttributeString('draw:color-mode', 'standard');
            writer.writeAttributeString('draw:luminance', '0%');
            writer.writeAttributeString('draw:contrast', '0%');
            writer.writeAttributeString('draw:gamma', '100%');
            writer.writeAttributeString('draw:red', '0%');
            writer.writeAttributeString('draw:green', '0%');
            writer.writeAttributeString('draw:blue', '0%');
            writer.writeAttributeString('fo:clip', 'rect(0cm 0cm 0cm 0cm)');
            writer.writeAttributeString('draw:image-opacity', '100%');
            writer.writeAttributeString('style:mirror', 'none');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'P1');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('fo:text-align', 'center');
            writer.writeEndElement();
            writer.writeEndElement();
            for (let indexStyle = 0; indexStyle < this.dataStyleList.stimulsoft().countItems; indexStyle++) {
                let style = this.dataStyleList.stimulsoft().getByIndex(indexStyle);
                if (style.isNumeric) {
                    writer.writeStartElement('number:number-style');
                    if (style.NegativeBraces) {
                        writer.writeAttributeString('style:name', StiString.format('N{0}P0', indexStyle + 1));
                        writer.writeAttributeString('style:volatile', 'true');
                    } else {
                        writer.writeAttributeString('style:name', StiString.format('N{0}', indexStyle + 1));
                    }
                    if (style.DecimalComma != ' ') {
                        writer.writeAttributeString('number:language', style.DecimalComma == ',' ? 'ru' : 'en');
                        writer.writeAttributeString('number:country', style.DecimalComma == ',' ? 'RU' : 'US');
                    }
                    writer.writeStartElement('number:number');
                    writer.writeAttributeString('number:decimal-places', style.DecimalDigits.toString());
                    writer.writeAttributeString('number:min-integer-digits', '1');
                    writer.writeAttributeString('number:grouping', style.GroupDigits == 3 ? 'true' : 'false');
                    writer.writeEndElement();
                    writer.writeEndElement();
                    if (style.NegativeBraces) {
                        writer.writeStartElement('number:number-style');
                        writer.writeAttributeString('style:name', StiString.format('N{0}', indexStyle + 1));
                        if (style.DecimalComma != ' ') {
                            writer.writeAttributeString('number:language', style.DecimalComma == ',' ? 'ru' : 'en');
                            writer.writeAttributeString('number:country', style.DecimalComma == ',' ? 'RU' : 'US');
                        }
                        writer.writeElementString('number:text', '(');
                        writer.writeStartElement('number:number');
                        writer.writeAttributeString('number:decimal-places', style.DecimalDigits.toString());
                        writer.writeAttributeString('number:min-integer-digits', '1');
                        writer.writeAttributeString('number:grouping', style.GroupDigits == 3 ? 'true' : 'false');
                        writer.writeEndElement();
                        writer.writeElementString('number:text', ')');
                        writer.writeStartElement('style:map');
                        writer.writeAttributeString('style:condition', 'value()>=0');
                        writer.writeAttributeString('style:apply-style-name', StiString.format('N{0}P0', indexStyle + 1));
                        writer.writeEndElement();
                        writer.writeEndElement();
                    }
                }
                if (style.isPercent) {
                    writer.writeStartElement('number:percentage-style');
                    writer.writeAttributeString('style:name', StiString.format('N{0}', indexStyle + 1));
                    if (style.DecimalComma != ' ') {
                        writer.writeAttributeString('number:language', style.DecimalComma == ',' ? 'ru' : 'en');
                        writer.writeAttributeString('number:country', style.DecimalComma == ',' ? 'RU' : 'US');
                    }
                    writer.writeStartElement('number:number');
                    writer.writeAttributeString('number:decimal-places', style.DecimalDigits.toString());
                    writer.writeAttributeString('number:min-integer-digits', '1');
                    if (style.GroupDigits == 3)
                        writer.writeAttributeString('number:grouping', 'true');
                    writer.writeEndElement();
                    writer.writeElementString('number:text', '%');
                    writer.writeEndElement();
                }
                if (style.isCurrency) {
                    writer.writeStartElement('number:currency-style');
                    writer.writeAttributeString('style:name', StiString.format('N{0}', indexStyle + 1));
                    if (style.DecimalComma != ' ') {
                        writer.writeAttributeString('number:language', style.DecimalComma == ',' ? 'ru' : 'en');
                        writer.writeAttributeString('number:country', style.DecimalComma == ',' ? 'RU' : 'US');
                    }
                    if (style.CurrencyPositionBefore)
                        writer.writeElementString('number:currency-symbol', style.CurrencySymbol);
                    writer.writeStartElement('number:number');
                    writer.writeAttributeString('number:decimal-places', style.DecimalDigits.toString());
                    writer.writeAttributeString('number:min-integer-digits', '1');
                    writer.writeAttributeString('number:grouping', style.GroupDigits == 3 ? 'true' : 'false');
                    writer.writeEndElement();
                    if (!style.CurrencyPositionBefore)
                        writer.writeElementString('number:currency-symbol', style.CurrencySymbol);
                    writer.writeEndElement();
                }
                if (style.isDate) {
                    writer.writeStartElement('number:date-style');
                    writer.writeAttributeString('style:name', StiString.format('N{0}', indexStyle + 1));
                    this.writeDateTimeFormatString(writer, style.DateTimeFormatString, 'd');
                    writer.writeEndElement();
                }
                if (style.isTime) {
                    writer.writeStartElement('number:time-style');
                    writer.writeAttributeString('style:name', StiString.format('N{0}', indexStyle + 1));
                    if (!StiString.isNullOrEmpty(style.DateTimeFormatString) && style.DateTimeFormatString.indexOf('h') != -1) {
                        writer.writeAttributeString('number:language', 'en');
                        writer.writeAttributeString('number:country', 'US');
                    }
                    this.writeDateTimeFormatString(writer, style.DateTimeFormatString, 't');
                    writer.writeEndElement();
                }
            }
            for (let indexStyle = 0; indexStyle < this.cellStyleList.stimulsoft().countItems; indexStyle++) {
                let style = this.cellStyleList.stimulsoft().getByIndex(indexStyle);
                writer.writeStartElement('style:style');
                writer.writeAttributeString('style:name', StiString.format('ce{0}', indexStyle + 1));
                writer.writeAttributeString('style:family', 'table-cell');
                writer.writeAttributeString('style:parent-style-name', 'Default');
                if (style.DataStyle != -1)
                    writer.writeAttributeString('style:data-style-name', StiString.format('N{0}', style.DataStyle + 1));
                writer.writeStartElement('style:table-cell-properties');
                if (style.BackColor.a > 0)
                    writer.writeAttributeString('fo:background-color', this.getColorString(style.BackColor));
                else
                    writer.writeAttributeString('fo:background-color', 'transparent');
                if (style.VertAlign == StiVertAlignment.Center)
                    writer.writeAttributeString('style:vertical-align', 'middle');
                if (style.VertAlign == StiVertAlignment.Top)
                    writer.writeAttributeString('style:vertical-align', 'top');
                writer.writeAttributeString('style:text-align-source', 'fix');
                writer.writeAttributeString('style:repeat-content', 'false');
                if (style.Wordwrap)
                    writer.writeAttributeString('fo:wrap-option', 'wrap');
                writer.writeAttributeString('fo:padding', '0in');
                writer.writeAttributeString('fo:border-left', style.BorderLeft);
                writer.writeAttributeString('fo:border-right', style.BorderRight);
                writer.writeAttributeString('fo:border-top', style.BorderTop);
                writer.writeAttributeString('fo:border-bottom', style.BorderBottom);
                if (style.Angle != 0) {
                    writer.writeAttributeString('style:rotation-angle', style.Angle.toString());
                    writer.writeAttributeString('style:rotation-align', 'none');
                }
                writer.writeEndElement();
                writer.writeStartElement('style:paragraph-properties');
                if (style.HorAlign == StiTextHorAlignment.Left)
                    writer.writeAttributeString('fo:text-align', 'start');
                if (style.HorAlign == StiTextHorAlignment.Center)
                    writer.writeAttributeString('fo:text-align', 'center');
                if (style.HorAlign == StiTextHorAlignment.Right)
                    writer.writeAttributeString('fo:text-align', 'end');
                if (style.HorAlign == StiTextHorAlignment.Width)
                    writer.writeAttributeString('fo:text-align', 'justify');
                writer.writeAttributeString('fo:margin-left', '0cm');
                writer.writeEndElement();
                writer.writeStartElement('style:text-properties');
                writer.writeAttributeString('fo:color', this.getColorString(style.FontColor));
                writer.writeAttributeString('style:font-name', style.FontName);
                let fontSizeSt = StiString.format('{0}pt', style.FontSize).stimulsoft().replaceAll(',', '.');
                writer.writeAttributeString('fo:font-size', fontSizeSt);
                writer.writeAttributeString('fo:font-size-asian', fontSizeSt);
                writer.writeAttributeString('fo:font-size-complex', fontSizeSt);
                if (style.Italic) {
                    writer.writeAttributeString('fo:font-style', 'italic');
                    writer.writeAttributeString('fo:font-style-asian', 'italic');
                    writer.writeAttributeString('fo:font-style-complex', 'italic');
                }
                if (style.Underline) {
                    writer.writeAttributeString('style:text-underline-style', 'solid');
                    writer.writeAttributeString('style:text-underline-width', 'auto');
                    writer.writeAttributeString('style:text-underline-color', 'font-color');
                }
                if (style.Bold) {
                    writer.writeAttributeString('fo:font-weight', 'bold');
                    writer.writeAttributeString('fo:font-weight-asian', 'bold');
                    writer.writeAttributeString('fo:font-weight-complex', 'bold');
                }
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeStartElement('office:body');
            writer.writeStartElement('office:spreadsheet');
            writer.writeStartElement('table:calculation-settings');
            writer.writeAttributeString('table:use-regular-expressions', 'false');
            writer.writeEndElement();
            this.currentPassNumber = Stimulsoft['StiOptions'].Export.OpenDocumentCalc.divideSegmentPages ? 3 : 2;
            for (let indexSheet = 0; indexSheet < this.matrixList.stimulsoft().countItems; indexSheet++) {
                this.writeTableFromMatrix(writer, indexSheet, rowHeightList, colWidthList);
            }
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeDateTimeFormatString(writer, formatString, defaultFormatString) {
            if (StiString.isNullOrEmpty(formatString))
                formatString = defaultFormatString;
            if (formatString.length == 1) {
                let dtfi = this.currentCulture.dateTimeFormat;
                switch (formatString) {
                case 'd':
                    formatString = dtfi.shortDatePattern;
                    break;
                case 'D':
                    formatString = dtfi.longDatePattern;
                    break;
                case 'f':
                    formatString = dtfi.shortDatePattern + ' ' + dtfi.shortTimePattern;
                    break;
                case 'F':
                    formatString = dtfi.fullDateTimePattern;
                    break;
                case 'g':
                    formatString = dtfi.shortDatePattern + ' ' + dtfi.shortTimePattern;
                    break;
                case 'G':
                    formatString = dtfi.shortDatePattern + ' ' + dtfi.longTimePattern;
                    break;
                case 'm':
                case 'M':
                    formatString = CultureInfo.currentCulture.name.stimulsoft().contains('en') || CultureInfo.currentCulture.name.stimulsoft().contains('us') ? 'MMMM d' : 'd MMMM';
                    break;
                case 'r':
                case 'R':
                    formatString = 'ddd, dd MMM yyyy HH\\:mm\\:ss \\G\\M\\T';
                    break;
                case 's':
                    formatString = 'yyyy\\-MM\\-dd\\THH\\:mm\\:ss';
                    break;
                case 't':
                    formatString = dtfi.shortTimePattern;
                    break;
                case 'T':
                    formatString = dtfi.longTimePattern;
                    break;
                case 'u':
                    formatString = 'yyyy\\-MM\\-dd HH\\:mm\\:ss\\Z';
                    break;
                case 'U':
                    formatString = dtfi.fullDateTimePattern;
                    break;
                case 'y':
                case 'Y':
                    formatString = dtfi.yearMonthPattern;
                    break;
                }
                formatString = formatString.stimulsoft().replaceAll('"', '').stimulsoft().replaceAll("'", '');
            }
            let index = 0;
            while (index < formatString.length) {
                let ch = formatString.charAt(index);
                let counter = 1;
                while (index + 1 < formatString.length && formatString.charAt(index + 1) == ch) {
                    index++;
                    counter++;
                }
                index++;
                switch (ch) {
                case 'd':
                    if (counter == 1) {
                        writer.writeStartElement('number:day');
                        writer.writeEndElement();
                    }
                    if (counter == 2) {
                        writer.writeStartElement('number:day');
                        writer.writeAttributeString('number:style', 'long');
                        writer.writeEndElement();
                    }
                    if (counter == 3) {
                        writer.writeStartElement('number:day-of-week');
                        writer.writeEndElement();
                    }
                    if (counter == 4) {
                        writer.writeStartElement('number:day-of-week');
                        writer.writeAttributeString('number:style', 'long');
                        writer.writeEndElement();
                    }
                    break;
                case 'M':
                    if (counter == 1) {
                        writer.writeStartElement('number:month');
                        writer.writeEndElement();
                    }
                    if (counter == 2) {
                        writer.writeStartElement('number:month');
                        writer.writeAttributeString('number:style', 'long');
                        writer.writeEndElement();
                    }
                    if (counter == 3) {
                        writer.writeStartElement('number:month');
                        writer.writeAttributeString('number:textual', 'true');
                        writer.writeEndElement();
                    }
                    if (counter == 4) {
                        writer.writeStartElement('number:month');
                        writer.writeAttributeString('number:style', 'long');
                        writer.writeAttributeString('number:textual', 'true');
                        writer.writeEndElement();
                    }
                    break;
                case 'y':
                    if (counter == 1 || counter == 2) {
                        writer.writeStartElement('number:year');
                        writer.writeEndElement();
                    }
                    if (counter == 3 || counter == 4) {
                        writer.writeStartElement('number:year');
                        writer.writeAttributeString('number:style', 'long');
                        writer.writeEndElement();
                    }
                    break;
                case 's':
                    if (counter == 1) {
                        writer.writeStartElement('number:seconds');
                        writer.writeEndElement();
                    }
                    if (counter == 2) {
                        writer.writeStartElement('number:seconds');
                        writer.writeAttributeString('number:style', 'long');
                        writer.writeEndElement();
                    }
                    break;
                case 'm':
                    if (counter == 1) {
                        writer.writeStartElement('number:minutes');
                        writer.writeEndElement();
                    }
                    if (counter == 2) {
                        writer.writeStartElement('number:minutes');
                        writer.writeAttributeString('number:style', 'long');
                        writer.writeEndElement();
                    }
                    break;
                case 'h':
                case 'H':
                    if (counter == 1) {
                        writer.writeStartElement('number:hours');
                        writer.writeEndElement();
                    }
                    if (counter == 2) {
                        writer.writeStartElement('number:hours');
                        writer.writeAttributeString('number:style', 'long');
                        writer.writeEndElement();
                    }
                    break;
                default:
                    writer.writeElementString('number:text', ch);
                    break;
                }
            }
        }
        writeTableFromMatrix(writer, indexSheet, rowHeightList, colWidthList) {
            let _matrix = this.matrixList[indexSheet];
            let minRowIndex = this.minRowList[indexSheet];
            let maxRowIndex = this.maxRowList[indexSheet];
            let cellStyleTable = this.cellStyleTableList[indexSheet];
            let sheetName = this.sheetNameList[indexSheet];
            let readyCells = StiArray.create2(Boolean, _matrix.coordY.countItems, _matrix.coordX.countItems);
            writer.writeStartElement('table:table');
            writer.writeAttributeString('table:name', sheetName);
            writer.writeAttributeString('table:style-name', 'ta1');
            writer.writeAttributeString('table:print', 'false');
            for (let indexColumn = 0; indexColumn < _matrix.coordX.countItems - 1; indexColumn++) {
                let columnWidth = _matrix.coordX.getByIndex(indexColumn + 1) - _matrix.coordX.getByIndex(indexColumn);
                let columnStyle = colWidthList.get(columnWidth);
                writer.writeStartElement('table:table-column');
                writer.writeAttributeString('table:style-name', StiString.format('co{0}', columnStyle + 1));
                writer.writeAttributeString('table:default-cell-style-name', 'Default');
                writer.writeEndElement();
            }
            let progressScale = Math.max(_matrix.coordY.countItems / 200, 1);
            let progressValue = 0;
            for (let indexRow = minRowIndex + 1; indexRow < maxRowIndex + 1; indexRow++) {
                let currentProgress = indexRow / progressScale | 0;
                if (currentProgress > progressValue) {
                    progressValue = currentProgress;
                    this.invokeExporting2(indexRow, _matrix.coordY.countItems, this.currentPassNumber, this.maximumPassNumber);
                }
                let rowHeightDouble = _matrix.coordY.getByIndex(indexRow) - _matrix.coordY.getByIndex(indexRow - 1);
                let rowStyle = rowHeightList.get(rowHeightDouble);
                writer.writeStartElement('table:table-row');
                writer.writeAttributeString('table:style-name', StiString.format('ro{0}', rowStyle + 1));
                for (let indexColumn = 1; indexColumn < _matrix.coordX.countItems; indexColumn++) {
                    let cell = _matrix.cells[indexRow - 1][indexColumn - 1];
                    if (!readyCells[indexRow][indexColumn]) {
                        if (cell != null) {
                            for (let yy = 0; yy <= cell.height; yy++) {
                                for (let xx = 0; xx <= cell.width; xx++) {
                                    readyCells[indexRow + yy][indexColumn + xx] = true;
                                }
                            }
                            let cellStyleIndex = cellStyleTable[indexRow - 1][indexColumn - 1];
                            let dataStyleIndex = this.cellStyleList[cellStyleIndex].DataStyle;
                            writer.writeStartElement('table:table-cell');
                            writer.writeAttributeString('table:style-name', StiString.format('ce{0}', cellStyleIndex + 1));
                            if (cell.width > 0 || cell.height > 0) {
                                writer.writeAttributeString('table:number-columns-spanned', (cell.width + 1).toString());
                                writer.writeAttributeString('table:number-rows-spanned', (cell.height + 1).toString());
                            }
                            let textComp = cell.component.stimulsoft().as(StiText);
                            let str = cell.text;
                            let checkComp = cell.component.stimulsoft().as(StiCheckBox);
                            if (checkComp != null && !StiString.isNullOrEmpty(checkComp.excelDataValue))
                                str = checkComp.excelDataValue;
                            if (!cell.component.isExportAsImage(__.a.StiExportFormat.Ods) && (!StiString.isNullOrEmpty(str) || textComp != null && textComp.excelDataValue != null)) {
                                let isNumber = false;
                                let numb = 0;
                                let dt = DateTime.now;
                                let dataStyle = null;
                                if (dataStyleIndex != -1 && textComp != null && textComp.excelDataValue != null && textComp.excelDataValue != '-') {
                                    let value = textComp.excelDataValue;
                                    let value2 = value.replace(/[^\d.,-]/g, '').stimulsoft().replaceAll(',', '.');
                                    dataStyle = this.dataStyleList[dataStyleIndex];
                                    isNumber = true;
                                    try {
                                        if (dataStyle.isDate || dataStyle.isTime) {
                                            let res = DateTime.tryParseExact(value, [null]);
                                            if (!res.successfully) {
                                                isNumber = false;
                                            } else {
                                                dt = res.result;
                                            }
                                        } else {
                                            numb = parseFloat(value2);
                                            if (isNaN(numb)) {
                                                isNumber = false;
                                                numb = 0;
                                            }
                                        }
                                    } catch (_a) {
                                        isNumber = false;
                                    }
                                    if (!isNumber && str == null)
                                        str = value;
                                }
                                if (isNumber) {
                                    if (dataStyle.isDate) {
                                        writer.writeAttributeString('office:value-type', 'date');
                                        writer.writeAttributeString('office:date-value', dt.toString('yyyy-MM-dd'));
                                    } else if (dataStyle.isTime) {
                                        writer.writeAttributeString('office:value-type', 'time');
                                        writer.writeAttributeString('office:time-value', dt.toString('PTHH\\Hmm\\Mss\\S'));
                                    } else {
                                        let value = numb.toString().stimulsoft().replaceAll(',', '.');
                                        if (dataStyle.isNumeric)
                                            writer.writeAttributeString('office:value-type', 'float');
                                        if (dataStyle.isPercent)
                                            writer.writeAttributeString('office:value-type', 'percentage');
                                        if (dataStyle.isCurrency)
                                            writer.writeAttributeString('office:value-type', 'currency');
                                        writer.writeAttributeString('office:value', value);
                                    }
                                } else {
                                    writer.writeAttributeString('office:value-type', 'string');
                                }
                                let stringList = __.b.StiExportUtils.splitString(str, true);
                                for (let indexLine = 0; indexLine < stringList.length; indexLine++) {
                                    let textLine = stringList[indexLine];
                                    writer.writeStartElement('text:p');
                                    writer.writeString(textLine);
                                    writer.writeEndElement();
                                }
                            }
                            if (cell.component.isExportAsImage(__.a.StiExportFormat.Ods)) {
                                writer.writeAttributeString('office:value-type', 'string');
                                let exportImage = cell.component.stimulsoft().as(IStiExportImageExtended);
                                if (exportImage != null) {
                                    let image = null;
                                    let REFrsImageResolution = { ref: this.imageResolution };
                                    image = exportImage.getImage(REFrsImageResolution, __.a.StiExportFormat.Ods);
                                    if (image != null) {
                                        let img = _matrix.getRealImageData(cell, image);
                                        if (img != null)
                                            image = img;
                                        let indexImage = this.imageCache.addImageInt(image);
                                        let imageWidth = _matrix.coordX.getByIndex(indexColumn + cell.width) - _matrix.coordX.getByIndex(indexColumn - 1);
                                        let imageHeight = _matrix.coordY.getByIndex(indexRow + cell.height) - _matrix.coordY.getByIndex(indexRow - 1);
                                        let endCellAddress = StiString.format("'{0}'.{1}{2}", sheetName, this.getColumnName(cell.left + cell.width + 1), cell.top + cell.height + 1 + 1);
                                        writer.writeStartElement('draw:frame');
                                        writer.writeAttributeString('table:end-cell-address', endCellAddress);
                                        writer.writeAttributeString('table:end-x', '0in');
                                        writer.writeAttributeString('table:end-y', '0in');
                                        writer.writeAttributeString('draw:z-index', '0');
                                        writer.writeAttributeString('draw:name', StiString.format('Picture{0}', indexImage + 1));
                                        writer.writeAttributeString('draw:style-name', 'gr1');
                                        writer.writeAttributeString('draw:text-style-name', 'P1');
                                        writer.writeAttributeString('text:anchor-type', 'paragraph');
                                        writer.writeAttributeString('svg:x', this.doubleToString(0));
                                        writer.writeAttributeString('svg:y', this.doubleToString(0));
                                        writer.writeAttributeString('svg:width', this.doubleToString(imageWidth));
                                        writer.writeAttributeString('svg:height', this.doubleToString(imageHeight));
                                        writer.writeStartElement('draw:image');
                                        writer.writeAttributeString('xlink:href', StiString.format('Pictures/{0:D5}.jpg', indexImage + 1));
                                        writer.writeAttributeString('xlink:type', 'simple');
                                        writer.writeAttributeString('xlink:show', 'embed');
                                        writer.writeAttributeString('xlink:actuate', 'onLoad');
                                        writer.writeStartElement('text:p');
                                        writer.writeEndElement();
                                        writer.writeEndElement();
                                        writer.writeEndElement();
                                    }
                                }
                            }
                            writer.writeEndElement();
                        } else {
                            let cellStyleIndex = cellStyleTable[indexRow - 1][indexColumn - 1];
                            writer.writeStartElement('table:table-cell');
                            writer.writeAttributeString('table:style-name', StiString.format('ce{0}', cellStyleIndex + 1));
                            writer.writeEndElement();
                        }
                    } else {
                        writer.writeStartElement('table:covered-table-cell');
                        writer.writeEndElement();
                    }
                }
                writer.writeEndElement();
            }
            writer.writeEndElement();
        }
        exportOds(report, stream, settings) {
            __.a.StiLogService.write(this.stimulsoft().getType(), 'Export report to ODT format');
            if (settings == null)
                throw new Error("The 'settings' argument cannot be equal in null.");
            let pageRange = settings.pageRange;
            this.imageResolution = settings.imageResolution;
            this.imageQuality = settings.imageQuality;
            this.xmlIndentation = -1;
            if (this.imageQuality < 0)
                this.imageQuality = 0;
            if (this.imageQuality > 1)
                this.imageQuality = 1;
            if (this.imageResolution < 10)
                this.imageResolution = 10;
            this.imageResolution = this.imageResolution / 100;
            this.currentCulture = CultureInfo.currentCulture;
            try {
                CultureInfo.currentCulture = CultureInfo.cultures['en-US'];
                this.imageCache = new __.a.StiImageCache(Stimulsoft['StiOptions'].Export.OpenDocumentCalc.allowImageComparer, true, ImageFormat.Jpeg, this.imageQuality, false);
                this.cellStyleList = [];
                this.dataStyleList = [];
                this.sheetNameList = [];
                this.matrixList = [];
                this.firstPageIndexList = [];
                this.minRowList = [];
                this.maxRowList = [];
                this.cellStyleTableList = [];
                this.currentPassNumber = 0;
                this.maximumPassNumber = Stimulsoft['StiOptions'].Export.OpenDocumentCalc.divideSegmentPages ? 4 : 3;
                let pages = pageRange.getSelectedPages(report.renderedPages);
                if (Stimulsoft['StiOptions'].Export.OpenDocumentCalc.divideSegmentPages) {
                    pages = __.b.StiSegmentPagesDivider.divide(pages, this);
                    this.currentPassNumber = 1;
                }
                if (this.isStopped)
                    return;
                let zip = new StiZipWriter20();
                zip.begin(stream, true);
                zip.addFile('content.xml', this.writeContent(report, pages));
                zip.addFile('mimetype', this.writeMimetype());
                zip.addFile('meta.xml', this.writeMeta());
                zip.addFile('META-INF/manifest.xml', this.writeManifest());
                zip.addFile('settings.xml', this.writeSettings());
                zip.addFile('styles.xml', this.writeStyles(pages));
                if (this.imageCache.imagePackedStore.stimulsoft().countItems > 0) {
                    for (let index = 0; index < this.imageCache.imagePackedStore.stimulsoft().countItems; index++) {
                        zip.addFile(StiString.format('Pictures/{0:D5}.jpg', index + 1), this.writeImage(index));
                    }
                }
                zip.end();
            } finally {
                CultureInfo.currentCulture = this.currentCulture;
                this.sheetNameList.stimulsoft().clear();
                this.sheetNameList = null;
                this.firstPageIndexList.stimulsoft().clear();
                this.firstPageIndexList = null;
                this.minRowList.stimulsoft().clear();
                this.minRowList = null;
                this.maxRowList.stimulsoft().clear();
                this.maxRowList = null;
                for (let matrix1 of this.matrixList) {
                    if (matrix1 != null)
                        matrix1.clear();
                }
                this.matrixList.stimulsoft().clear();
                this.matrixList = null;
                this.cellStyleTableList.stimulsoft().clear();
                this.cellStyleTableList = null;
                this.dataStyleList.stimulsoft().clear();
                this.dataStyleList = null;
                this.cellStyleList.stimulsoft().clear();
                this.cellStyleList = null;
                this.imageCache.clear();
                this.imageCache = null;
                if (report.renderedPages.cacheMode)
                    __.b.StiMatrix.GCCollect();
            }
        }
    };
}
{
    let CellStyleData = class {
        constructor() {
            this.BorderLeft = 'none';
            this.BorderRight = 'none';
            this.BorderTop = 'none';
            this.BorderBottom = 'none';
            this.BackColor = Color.transparent;
            this.VertAlign = StiVertAlignment.Bottom;
        }
    };
    let ParagraphStyleData = class {
        constructor() {
            this.FontName = 'Arial';
            this.FontSize = 6;
            this.Bold = false;
            this.Italic = false;
            this.Underline = false;
            this.FontColor = Color.black;
            this.HorAlign = StiTextHorAlignment.Left;
            this.Angle = 0;
        }
    };
    __.b.StiOdtExportService = class extends __.b.StiExportService {
        constructor() {
            super(...arguments);
            this.multipleFiles = false;
            this.matrix = null;
            this.removeEmptySpaceAtBottom = Stimulsoft['StiOptions'].Export.OpenDocumentWriter.removeEmptySpaceAtBottom;
            this.imageCache = null;
            this.cellStyleList = null;
            this.paragraphStyleList = null;
            this.xmlIndentation = 1;
            this.imageQuality = 0.75;
            this.imageResolution = 96;
            this.usePageHeadersAndFooters = false;
        }
        implements() {
            return [__.b.IStiOdtExportService];
        }
        get defaultExtension() {
            return 'odt';
        }
        get exportFormat() {
            return __.a.StiExportFormat.Odt;
        }
        get groupCategory() {
            return 'Word';
        }
        get position() {
            return __.b.StiExportPosition.Odt;
        }
        get exportNameInMenu() {
            return StiLocalization.get('Export', 'ExportTypeWriterFile');
        }
        getFilter() {
            return StiLocalization.get('FileFilters', 'WriterFiles');
        }
        exportTo(report, stream, settings) {
            this.exportOdt(report, stream, settings);
        }
        exportToAsync(onExport, report, stream, settings) {
            setTimeout(() => Stimulsoft.tsfb(this, void 0, void 0, function* () {
                yield __.b.StiExportImageHelper.convertAllImages(report, Stimulsoft.System.Drawing.Imaging.ImageFormat.Jpeg, false, this.exportFormat);
                this.exportTo(report, stream, settings);
                if (report != null && report.preparedExportImages != null) {
                    report.preparedExportImages.clear();
                    report.preparedExportImages = null;
                }
                onExport();
            }), 0);
        }
        doubleToString(numb) {
            return StiMath.round2(numb / 100, 4).toString().stimulsoft().replaceAll(',', '.') + 'in';
        }
        getColumnName(column) {
            let columnHigh = column / 26 | 0;
            let columnLow = column % 26;
            let output = '';
            if (columnHigh > 0) {
                output += String.fromCharCode(65 + columnHigh - 1);
            }
            output += String.fromCharCode(65 + columnLow);
            return output;
        }
        getColorString(color) {
            return '#' + StiString.format('{0:X8}', color.toArgb()).substr(2);
        }
        getCellStyleNumber(indexRow, indexColumn, height, width) {
            let style = new CellStyleData();
            let needBorderLeft = true;
            let needBorderRight = true;
            for (let index = 0; index < height; index++) {
                if (this.matrix.bordersY[indexRow + index][indexColumn] == null)
                    needBorderLeft = false;
                if (this.matrix.bordersY[indexRow + index][indexColumn + width] == null)
                    needBorderRight = false;
            }
            let needBorderTop = true;
            let needBorderBottom = true;
            for (let index = 0; index < width; index++) {
                if (this.matrix.bordersX[indexRow][indexColumn + index] == null)
                    needBorderTop = false;
                if (this.matrix.bordersX[indexRow + height][indexColumn + index] == null)
                    needBorderBottom = false;
            }
            if (needBorderTop)
                style.BorderTop = this.getStringFromBorder(this.matrix.bordersX[indexRow][indexColumn]);
            if (needBorderLeft)
                style.BorderLeft = this.getStringFromBorder(this.matrix.bordersY[indexRow][indexColumn]);
            if (needBorderBottom)
                style.BorderBottom = this.getStringFromBorder(this.matrix.bordersX[indexRow + height][indexColumn]);
            if (needBorderRight)
                style.BorderRight = this.getStringFromBorder(this.matrix.bordersY[indexRow][indexColumn + width]);
            if (this.matrix.cells[indexRow][indexColumn] != null) {
                let cell = this.matrix.cells[indexRow][indexColumn];
                style.BackColor = cell.cellStyle.color;
                style.VertAlign = cell.cellStyle.vertAlignment;
                if (cell.cellStyle.textOptions != null) {
                    let textAngle = cell.cellStyle.textOptions.angle;
                    if (textAngle > 45 && textAngle < 135 || textAngle > 225 && textAngle < 315) {
                        if (cell.cellStyle.horAlignment == StiTextHorAlignment.Left)
                            style.VertAlign = StiVertAlignment.Bottom;
                        if (cell.cellStyle.horAlignment == StiTextHorAlignment.Center)
                            style.VertAlign = StiVertAlignment.Center;
                        if (cell.cellStyle.horAlignment == StiTextHorAlignment.Right)
                            style.VertAlign = StiVertAlignment.Top;
                        if (cell.cellStyle.horAlignment == StiTextHorAlignment.Width)
                            style.VertAlign = StiVertAlignment.Bottom;
                    }
                }
            }
            if (this.cellStyleList.length > 0) {
                for (let index = 0; index < this.cellStyleList.length; index++) {
                    let tempStyle = this.cellStyleList[index];
                    if (tempStyle.BorderLeft == style.BorderLeft && tempStyle.BorderRight == style.BorderRight && tempStyle.BorderTop == style.BorderTop && tempStyle.BorderBottom == style.BorderBottom && tempStyle.BackColor.equals(style.BackColor) && tempStyle.VertAlign == style.VertAlign) {
                        return index;
                    }
                }
            }
            this.cellStyleList.push(style);
            let temp = this.cellStyleList.length - 1;
            return temp;
        }
        getStringFromBorder(border) {
            return StiString.format('{0} solid {1}', this.doubleToString(border.size), this.getColorString(border.color));
        }
        getParagraphStyleNumber(indexRow, indexColumn) {
            let cellStyle = this.matrix.cells[indexRow][indexColumn].cellStyle;
            let style = new ParagraphStyleData();
            style.FontName = cellStyle.font.name;
            style.FontSize = cellStyle.font.sizeInPoints;
            style.Bold = cellStyle.font.bold;
            style.Italic = cellStyle.font.italic;
            style.Underline = cellStyle.font.underline;
            style.FontColor = cellStyle.textColor;
            style.HorAlign = cellStyle.horAlignment;
            let textAngle = 0;
            if (cellStyle.textOptions != null)
                textAngle = cellStyle.textOptions.angle;
            if (textAngle > 45 && textAngle < 135)
                style.Angle = 90;
            if (textAngle > 225 && textAngle < 315)
                style.Angle = 270;
            if (style.Angle != 0) {
                if (cellStyle.vertAlignment == StiVertAlignment.Top)
                    style.HorAlign = StiTextHorAlignment.Left;
                if (cellStyle.vertAlignment == StiVertAlignment.Center)
                    style.HorAlign = StiTextHorAlignment.Center;
                if (cellStyle.vertAlignment == StiVertAlignment.Bottom)
                    style.HorAlign = StiTextHorAlignment.Right;
            }
            if (this.paragraphStyleList.length > 0) {
                for (let index = 0; index < this.paragraphStyleList.length; index++) {
                    let tempStyle = this.paragraphStyleList[index];
                    if (tempStyle.FontName == style.FontName && tempStyle.FontSize == style.FontSize && tempStyle.Bold == style.Bold && tempStyle.Italic == style.Italic && tempStyle.Underline == style.Underline && tempStyle.FontColor.equals(style.FontColor) && tempStyle.HorAlign == style.HorAlign && tempStyle.Angle == style.Angle) {
                        return index;
                    }
                }
            }
            this.paragraphStyleList.push(style);
            let temp = this.paragraphStyleList.length - 1;
            return temp;
        }
        writeMimetype() {
            let ms = new MemoryStream();
            let writer = new StreamWriter(ms, Encoding.ASCII);
            writer.write('application/vnd.oasis.opendocument.text');
            writer.flush();
            return ms;
        }
        writeMeta() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('office:document-meta');
            writer.writeAttributeString('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
            writer.writeAttributeString('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeAttributeString('xmlns:meta', 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0');
            writer.writeAttributeString('xmlns:ooo', 'http://openoffice.org/2004/office');
            writer.writeAttributeString('office:version', '1.1');
            writer.writeStartElement('office:meta');
            let dateTime = StiString.format('{0}', DateTime.now.toString('yyyy-MM-ddTHH:mm:ss'));
            writer.writeElementString('meta:generator', 'Stimulsoft Reports');
            writer.writeElementString('meta:creation-date', dateTime);
            writer.writeElementString('dc:date', dateTime);
            writer.writeElementString('meta:editing-cycles', '1');
            writer.writeElementString('meta:editing-duration', 'PT0M01S');
            writer.writeStartElement('meta:user-defined');
            writer.writeAttributeString('meta:name', 'Info 1');
            writer.writeEndElement();
            writer.writeStartElement('meta:user-defined');
            writer.writeAttributeString('meta:name', 'Info 2');
            writer.writeEndElement();
            writer.writeStartElement('meta:user-defined');
            writer.writeAttributeString('meta:name', 'Info 3');
            writer.writeEndElement();
            writer.writeStartElement('meta:user-defined');
            writer.writeAttributeString('meta:name', 'Info 4');
            writer.writeEndElement();
            writer.writeStartElement('meta:document-statistic');
            writer.writeAttributeString('meta:table-count', '1');
            writer.writeAttributeString('meta:image-count', '0');
            writer.writeAttributeString('meta:object-count', '0');
            writer.writeAttributeString('meta:page-count', '1');
            writer.writeAttributeString('meta:paragraph-count', '1');
            writer.writeAttributeString('meta:word-count', '1');
            writer.writeAttributeString('meta:character-count', '1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeManifest() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('manifest:manifest');
            writer.writeAttributeString('xmlns:manifest', 'urn:oasis:names:tc:opendocument:xmlns:manifest:1.0');
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'application/vnd.oasis.opendocument.text');
            writer.writeAttributeString('manifest:full-path', '/');
            writer.writeEndElement();
            for (let index = 0; index < this.imageCache.imagePackedStore.stimulsoft().countItems; index++) {
                writer.writeStartElement('manifest:file-entry');
                writer.writeAttributeString('manifest:media-type', 'image/jpeg');
                writer.writeAttributeString('manifest:full-path', StiString.format('Pictures/{0:D5}.jpg', index + 1));
                writer.writeEndElement();
            }
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'text/xml');
            writer.writeAttributeString('manifest:full-path', 'content.xml');
            writer.writeEndElement();
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'text/xml');
            writer.writeAttributeString('manifest:full-path', 'styles.xml');
            writer.writeEndElement();
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'text/xml');
            writer.writeAttributeString('manifest:full-path', 'meta.xml');
            writer.writeEndElement();
            writer.writeStartElement('manifest:file-entry');
            writer.writeAttributeString('manifest:media-type', 'text/xml');
            writer.writeAttributeString('manifest:full-path', 'settings.xml');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeImage(numb) {
            let ms = new MemoryStream();
            let buf = this.imageCache.imagePackedStore[numb];
            ms.write(buf, 0, buf.length);
            return ms;
        }
        writeSettings() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('office:document-settings');
            writer.writeAttributeString('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
            writer.writeAttributeString('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            writer.writeAttributeString('xmlns:config', 'urn:oasis:names:tc:opendocument:xmlns:config:1.0');
            writer.writeAttributeString('xmlns:ooo', 'http://openoffice.org/2004/office');
            writer.writeAttributeString('office:version', '1.1');
            writer.writeStartElement('office:settings');
            writer.writeStartElement('config:config-item-set');
            writer.writeAttributeString('config:name', 'ooo:view-settings');
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ViewAreaTop');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ViewAreaLeft');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('-10107');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ViewAreaWidth');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('43208');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ViewAreaHeight');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('22174');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ShowRedlineChanges');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'InBrowseMode');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item-map-indexed');
            writer.writeAttributeString('config:name', 'Views');
            writer.writeStartElement('config:config-item-map-entry');
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ViewId');
            writer.writeAttributeString('config:type', 'string');
            writer.writeString('view2');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ViewLeft');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('3002');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ViewTop');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('10435');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VisibleLeft');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('-10107');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VisibleTop');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VisibleRight');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('33099');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'VisibleBottom');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('22172');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ZoomType');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ZoomFactor');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('100');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsSelectedFrame');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('config:config-item-set');
            writer.writeAttributeString('config:name', 'ooo:configuration-settings');
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'AddParaTableSpacing');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintReversed');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'OutlineLevelYieldsNumbering');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'LinkUpdateMode');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('1');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintEmptyPages');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IgnoreFirstLineIndentInNumbering');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'CharacterCompressionType');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintSingleJobs');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'UpdateFromTemplate');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintPaperFromSetup');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'AddFrameOffsets');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintLeftPages');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'RedlineProtectionKey');
            writer.writeAttributeString('config:type', 'base64Binary');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintTables');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ChartAutoUpdate');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintControls');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrinterSetup');
            writer.writeAttributeString('config:type', 'base64Binary');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IgnoreTabsAndBlanksForLineCalculation');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintAnnotationMode');
            writer.writeAttributeString('config:type', 'short');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'LoadReadonly');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'AddParaSpacingToTableCells');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'AddExternalLeading');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ApplyUserData');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'FieldAutoUpdate');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'SaveVersionOnClose');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'SaveGlobalDocumentLinks');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsKernAsianPunctuation');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'AlignTabStopPosition');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ClipAsCharacterAnchoredWriterFlyFrames');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'CurrentDatabaseDataSource');
            writer.writeAttributeString('config:type', 'string');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'DoNotCaptureDrawObjsOnPage');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'TableRowKeep');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrinterName');
            writer.writeAttributeString('config:type', 'string');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintFaxName');
            writer.writeAttributeString('config:type', 'string');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'ConsiderTextWrapOnObjPos');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'UseOldPrinterMetrics');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintRightPages');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'IsLabelDocument');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'UseFormerLineSpacing');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'AddParaTableSpacingAtStart');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'UseFormerTextWrapping');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'DoNotResetParaAttrsForNumFont');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintProspect');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintGraphics');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'AllowPrintJobCancel');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'CurrentDatabaseCommandType');
            writer.writeAttributeString('config:type', 'int');
            writer.writeString('0');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'DoNotJustifyLinesWithManualBreak');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'UseFormerObjectPositioning');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrinterIndependentLayout');
            writer.writeAttributeString('config:type', 'string');
            writer.writeString('high-resolution');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'UseOldNumbering');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintPageBackground');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'CurrentDatabaseCommand');
            writer.writeAttributeString('config:type', 'string');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintDrawings');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('true');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'PrintBlackFonts');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeStartElement('config:config-item');
            writer.writeAttributeString('config:name', 'UnxForceZeroExtLeading');
            writer.writeAttributeString('config:type', 'boolean');
            writer.writeString('false');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeStyles(pages) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('office:document-styles');
            writer.writeAttributeString('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
            writer.writeAttributeString('xmlns:style', 'urn:oasis:names:tc:opendocument:xmlns:style:1.0');
            writer.writeAttributeString('xmlns:text', 'urn:oasis:names:tc:opendocument:xmlns:text:1.0');
            writer.writeAttributeString('xmlns:table', 'urn:oasis:names:tc:opendocument:xmlns:table:1.0');
            writer.writeAttributeString('xmlns:draw', 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0');
            writer.writeAttributeString('xmlns:fo', 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0');
            writer.writeAttributeString('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeAttributeString('xmlns:meta', 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0');
            writer.writeAttributeString('xmlns:number', 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0');
            writer.writeAttributeString('xmlns:svg', 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0');
            writer.writeAttributeString('xmlns:chart', 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0');
            writer.writeAttributeString('xmlns:dr3d', 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0');
            writer.writeAttributeString('xmlns:math', 'http://www.w3.org/1998/Math/MathML');
            writer.writeAttributeString('xmlns:form', 'urn:oasis:names:tc:opendocument:xmlns:form:1.0');
            writer.writeAttributeString('xmlns:script', 'urn:oasis:names:tc:opendocument:xmlns:script:1.0');
            writer.writeAttributeString('xmlns:ooo', 'http://openoffice.org/2004/office');
            writer.writeAttributeString('xmlns:ooow', 'http://openoffice.org/2004/writer');
            writer.writeAttributeString('xmlns:oooc', 'http://openoffice.org/2004/calc');
            writer.writeAttributeString('xmlns:dom', 'http://www.w3.org/2001/xml-events');
            writer.writeAttributeString('office:version', '1.1');
            writer.writeStartElement('office:font-face-decls');
            writer.writeStartElement('style:font-face');
            writer.writeAttributeString('style:name', 'Arial');
            writer.writeAttributeString('svg:font-family', 'Arial');
            writer.writeEndElement();
            writer.writeStartElement('style:font-face');
            writer.writeAttributeString('style:name', 'Tahoma');
            writer.writeAttributeString('svg:font-family', 'Tahoma');
            writer.writeAttributeString('style:font-family-generic', 'system');
            writer.writeAttributeString('style:font-pitch', 'variable');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('office:styles');
            writer.writeStartElement('style:default-style');
            writer.writeAttributeString('style:family', 'graphic');
            writer.writeStartElement('style:graphic-properties');
            writer.writeAttributeString('draw:shadow-offset-x', '0.3cm');
            writer.writeAttributeString('draw:shadow-offset-y', '0.3cm');
            writer.writeAttributeString('draw:start-line-spacing-horizontal', '0.283cm');
            writer.writeAttributeString('draw:start-line-spacing-vertical', '0.283cm');
            writer.writeAttributeString('draw:end-line-spacing-horizontal', '0.283cm');
            writer.writeAttributeString('draw:end-line-spacing-vertical', '0.283cm');
            writer.writeAttributeString('style:flow-with-text', 'false');
            writer.writeEndElement();
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('style:text-autospace', 'ideograph-alpha');
            writer.writeAttributeString('style:line-break', 'strict');
            writer.writeAttributeString('style:writing-mode', 'lr-tb');
            writer.writeAttributeString('style:font-independent-line-spacing', 'false');
            writer.writeStartElement('style:tab-stops');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('style:use-window-font-color', 'true');
            writer.writeAttributeString('fo:font-size', '10pt');
            writer.writeAttributeString('style:letter-kerning', 'true');
            writer.writeAttributeString('style:font-size-asian', '12pt');
            writer.writeAttributeString('style:language-asian', 'zxx');
            writer.writeAttributeString('style:country-asian', 'none');
            writer.writeAttributeString('style:font-size-complex', '12pt');
            writer.writeAttributeString('style:language-complex', 'zxx');
            writer.writeAttributeString('style:country-complex', 'none');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:default-style');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('fo:hyphenation-ladder-count', 'no-limit');
            writer.writeAttributeString('style:text-autospace', 'ideograph-alpha');
            writer.writeAttributeString('style:punctuation-wrap', 'hanging');
            writer.writeAttributeString('style:line-break', 'strict');
            writer.writeAttributeString('style:tab-stop-distance', '1.251cm');
            writer.writeAttributeString('style:writing-mode', 'page');
            writer.writeEndElement();
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('style:use-window-font-color', 'true');
            writer.writeAttributeString('style:font-name', 'Arial');
            writer.writeAttributeString('fo:font-size', '10pt');
            writer.writeAttributeString('style:letter-kerning', 'true');
            writer.writeAttributeString('style:font-name-asian', 'Lucida Sans Unicode');
            writer.writeAttributeString('style:font-size-asian', '12pt');
            writer.writeAttributeString('style:language-asian', 'zxx');
            writer.writeAttributeString('style:country-asian', 'none');
            writer.writeAttributeString('style:font-name-complex', 'Tahoma');
            writer.writeAttributeString('style:font-size-complex', '12pt');
            writer.writeAttributeString('style:language-complex', 'zxx');
            writer.writeAttributeString('style:country-complex', 'none');
            writer.writeAttributeString('fo:hyphenate', 'false');
            writer.writeAttributeString('fo:hyphenation-remain-char-count', '2');
            writer.writeAttributeString('fo:hyphenation-push-char-count', '2');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:default-style');
            writer.writeAttributeString('style:family', 'table');
            writer.writeStartElement('style:table-properties');
            writer.writeAttributeString('table:border-model', 'collapsing');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:default-style');
            writer.writeAttributeString('style:family', 'table-row');
            writer.writeStartElement('style:table-row-properties');
            writer.writeAttributeString('fo:keep-together', 'auto');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Standard');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeAttributeString('style:class', 'text');
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Title');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeAttributeString('style:parent-style-name', 'Standard');
            writer.writeAttributeString('style:next-style-name', 'Text_20_body');
            writer.writeAttributeString('style:class', 'text');
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('fo:margin-top', '0.423cm');
            writer.writeAttributeString('fo:margin-bottom', '0.212cm');
            writer.writeAttributeString('fo:keep-with-next', 'always');
            writer.writeEndElement();
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('style:font-name', 'Arial1');
            writer.writeAttributeString('fo:font-size', '14pt');
            writer.writeAttributeString('style:font-name-asian', 'Lucida Sans Unicode');
            writer.writeAttributeString('style:font-size-asian', '14pt');
            writer.writeAttributeString('style:font-name-complex', 'Tahoma');
            writer.writeAttributeString('style:font-size-complex', '14pt');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Text_20_body');
            writer.writeAttributeString('style:display-name', 'Text body');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeAttributeString('style:parent-style-name', 'Standard');
            writer.writeAttributeString('style:class', 'text');
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('fo:margin-top', '0cm');
            writer.writeAttributeString('fo:margin-bottom', '0.212cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Subtitle');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeAttributeString('style:parent-style-name', 'Title');
            writer.writeAttributeString('style:next-style-name', 'Text_20_body');
            writer.writeAttributeString('style:class', 'chapter');
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('fo:text-align', 'center');
            writer.writeAttributeString('style:justify-single-word', 'false');
            writer.writeEndElement();
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('fo:font-size', '14pt');
            writer.writeAttributeString('fo:font-style', 'italic');
            writer.writeAttributeString('style:font-size-asian', '14pt');
            writer.writeAttributeString('style:font-style-asian', 'italic');
            writer.writeAttributeString('style:font-size-complex', '14pt');
            writer.writeAttributeString('style:font-style-complex', 'italic');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'List');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeAttributeString('style:parent-style-name', 'Text_20_body');
            writer.writeAttributeString('style:class', 'list');
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('style:font-name', 'Arial');
            writer.writeAttributeString('style:font-name-complex', 'Tahoma1');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Caption');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeAttributeString('style:parent-style-name', 'Standard');
            writer.writeAttributeString('style:class', 'extra');
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('fo:margin-top', '0.212cm');
            writer.writeAttributeString('fo:margin-bottom', '0.212cm');
            writer.writeAttributeString('text:number-lines', 'false');
            writer.writeAttributeString('text:line-number', '0');
            writer.writeEndElement();
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('style:font-name', 'Arial');
            writer.writeAttributeString('fo:font-size', '10pt');
            writer.writeAttributeString('fo:font-style', 'italic');
            writer.writeAttributeString('style:font-size-asian', '12pt');
            writer.writeAttributeString('style:font-style-asian', 'italic');
            writer.writeAttributeString('style:font-name-complex', 'Tahoma1');
            writer.writeAttributeString('style:font-size-complex', '12pt');
            writer.writeAttributeString('style:font-style-complex', 'italic');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Index');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeAttributeString('style:parent-style-name', 'Standard');
            writer.writeAttributeString('style:class', 'index');
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('text:number-lines', 'false');
            writer.writeAttributeString('text:line-number', '0');
            writer.writeEndElement();
            writer.writeStartElement('style:text-properties');
            writer.writeAttributeString('style:font-name', 'Arial');
            writer.writeAttributeString('style:font-name-complex', 'Tahoma1');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Table_20_Contents');
            writer.writeAttributeString('style:display-name', 'Table Contents');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeAttributeString('style:parent-style-name', 'Standard');
            writer.writeAttributeString('style:class', 'extra');
            writer.writeStartElement('style:paragraph-properties');
            writer.writeAttributeString('text:number-lines', 'false');
            writer.writeAttributeString('text:line-number', '0');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Graphics');
            writer.writeAttributeString('style:family', 'graphic');
            writer.writeStartElement('style:graphic-properties');
            writer.writeAttributeString('text:anchor-type', 'paragraph');
            writer.writeAttributeString('svg:x', '0cm');
            writer.writeAttributeString('svg:y', '0cm');
            writer.writeAttributeString('style:wrap', 'dynamic');
            writer.writeAttributeString('style:number-wrapped-paragraphs', 'no-limit');
            writer.writeAttributeString('style:wrap-contour', 'false');
            writer.writeAttributeString('style:vertical-pos', 'top');
            writer.writeAttributeString('style:vertical-rel', 'paragraph');
            writer.writeAttributeString('style:horizontal-pos', 'center');
            writer.writeAttributeString('style:horizontal-rel', 'paragraph');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-style');
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '1');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '2');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '3');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '4');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '5');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '6');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '7');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '8');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '9');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('text:outline-level-style');
            writer.writeAttributeString('text:level', '10');
            writer.writeAttributeString('style:num-format', '');
            writer.writeStartElement('style:list-level-properties');
            writer.writeAttributeString('text:min-label-distance', '0.381cm');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('text:notes-configuration');
            writer.writeAttributeString('text:note-class', 'footnote');
            writer.writeAttributeString('style:num-format', '1');
            writer.writeAttributeString('text:start-value', '0');
            writer.writeAttributeString('text:footnotes-position', 'page');
            writer.writeAttributeString('text:start-numbering-at', 'document');
            writer.writeEndElement();
            writer.writeStartElement('text:notes-configuration');
            writer.writeAttributeString('text:note-class', 'endnote');
            writer.writeAttributeString('style:num-format', 'i');
            writer.writeAttributeString('text:start-value', '0');
            writer.writeEndElement();
            writer.writeStartElement('text:linenumbering-configuration');
            writer.writeAttributeString('text:number-lines', 'false');
            writer.writeAttributeString('text:offset', '0.499cm');
            writer.writeAttributeString('style:num-format', '1');
            writer.writeAttributeString('text:number-position', 'left');
            writer.writeAttributeString('text:increment', '5');
            writer.writeEndElement();
            writer.writeEndElement();
            let page = pages.getByIndex(0);
            let pageHeight = page.unit.convertToHInches(page.pageHeight * page.segmentPerHeight);
            let pageWidth = page.unit.convertToHInches(page.pageWidth * page.segmentPerWidth);
            let mgLeft = page.unit.convertToHInches(page.margins.left);
            let mgRight = page.unit.convertToHInches(page.margins.right);
            let mgTop = page.unit.convertToHInches(page.margins.top);
            let mgBottom = page.unit.convertToHInches(page.margins.bottom) - 4;
            if (mgBottom < 0)
                mgBottom = 0;
            writer.writeStartElement('office:automatic-styles');
            writer.writeStartElement('style:page-layout');
            writer.writeAttributeString('style:name', 'pm1');
            writer.writeStartElement('style:page-layout-properties');
            writer.writeAttributeString('fo:page-width', this.doubleToString(pageWidth));
            writer.writeAttributeString('fo:page-height', this.doubleToString(pageHeight));
            writer.writeAttributeString('style:num-format', '1');
            writer.writeAttributeString('style:print-orientation', page.orientation == StiPageOrientation.Portrait ? 'portrait' : 'landscape');
            writer.writeAttributeString('fo:margin-top', this.doubleToString(mgTop));
            writer.writeAttributeString('fo:margin-bottom', this.doubleToString(mgBottom));
            writer.writeAttributeString('fo:margin-left', this.doubleToString(mgLeft));
            writer.writeAttributeString('fo:margin-right', this.doubleToString(mgRight));
            writer.writeAttributeString('style:writing-mode', 'lr-tb');
            writer.writeAttributeString('style:footnote-max-height', '0cm');
            writer.writeStartElement('style:footnote-sep');
            writer.writeAttributeString('style:width', '0.018cm');
            writer.writeAttributeString('style:distance-before-sep', '0.101cm');
            writer.writeAttributeString('style:distance-after-sep', '0.101cm');
            writer.writeAttributeString('style:adjustment', 'left');
            writer.writeAttributeString('style:rel-width', '25%');
            writer.writeAttributeString('style:color', '#000000');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:header-style');
            writer.writeEndElement();
            writer.writeStartElement('style:footer-style');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('office:master-styles');
            writer.writeStartElement('style:master-page');
            writer.writeAttributeString('style:name', 'Standard');
            writer.writeAttributeString('style:page-layout-name', 'pm1');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeContent() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('office:document-content');
            writer.writeAttributeString('xmlns:office', 'urn:oasis:names:tc:opendocument:xmlns:office:1.0');
            writer.writeAttributeString('xmlns:style', 'urn:oasis:names:tc:opendocument:xmlns:style:1.0');
            writer.writeAttributeString('xmlns:text', 'urn:oasis:names:tc:opendocument:xmlns:text:1.0');
            writer.writeAttributeString('xmlns:table', 'urn:oasis:names:tc:opendocument:xmlns:table:1.0');
            writer.writeAttributeString('xmlns:draw', 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0');
            writer.writeAttributeString('xmlns:fo', 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0');
            writer.writeAttributeString('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeAttributeString('xmlns:meta', 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0');
            writer.writeAttributeString('xmlns:number', 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0');
            writer.writeAttributeString('xmlns:svg', 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0');
            writer.writeAttributeString('xmlns:chart', 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0');
            writer.writeAttributeString('xmlns:dr3d', 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0');
            writer.writeAttributeString('xmlns:math', 'http://www.w3.org/1998/Math/MathML');
            writer.writeAttributeString('xmlns:form', 'urn:oasis:names:tc:opendocument:xmlns:form:1.0');
            writer.writeAttributeString('xmlns:script', 'urn:oasis:names:tc:opendocument:xmlns:script:1.0');
            writer.writeAttributeString('xmlns:ooo', 'http://openoffice.org/2004/office');
            writer.writeAttributeString('xmlns:ooow', 'http://openoffice.org/2004/writer');
            writer.writeAttributeString('xmlns:oooc', 'http://openoffice.org/2004/calc');
            writer.writeAttributeString('xmlns:dom', 'http://www.w3.org/2001/xml-events');
            writer.writeAttributeString('xmlns:xforms', 'http://www.w3.org/2002/xforms');
            writer.writeAttributeString('xmlns:xsd', 'http://www.w3.org/2001/XMLSchema');
            writer.writeAttributeString('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
            writer.writeAttributeString('office:version', '1.1');
            let readyCells = StiArray.create2(Boolean, this.matrix.coordY.countItems, this.matrix.coordX.countItems);
            let cellStyleTable = StiArray.create2(Number, this.matrix.coordY.countItems, this.matrix.coordX.countItems);
            let rowHeightList = new Hashtable();
            let rowHeightList2 = new Hashtable();
            let rowPosList = [];
            for (let indexRow = 1; indexRow < this.matrix.coordY.countItems; indexRow++) {
                let rowHeight = this.matrix.coordY.getByIndex(indexRow) - this.matrix.coordY.getByIndex(indexRow - 1);
                if (!rowHeightList.containsKey(rowHeight)) {
                    let listPos = rowHeightList.count;
                    rowHeightList.set(rowHeight, listPos);
                    rowHeightList2.set(listPos, rowHeight);
                }
                rowPosList[indexRow - 1] = rowHeightList.get(rowHeight) | 0;
                for (let indexColumn = 1; indexColumn < this.matrix.coordX.countItems; indexColumn++) {
                    let cell = this.matrix.cells[indexRow - 1][indexColumn - 1];
                    if (!readyCells[indexRow][indexColumn]) {
                        if (cell != null) {
                            for (let yy = 0; yy <= cell.height; yy++) {
                                for (let xx = 0; xx <= cell.width; xx++) {
                                    readyCells[indexRow + yy][indexColumn + xx] = true;
                                }
                            }
                            cellStyleTable[indexRow - 1][indexColumn - 1] = this.getCellStyleNumber(indexRow - 1, indexColumn - 1, cell.height + 1, cell.width + 1);
                        } else {
                            cellStyleTable[indexRow - 1][indexColumn - 1] = this.getCellStyleNumber(indexRow - 1, indexColumn - 1, 1, 1);
                        }
                    }
                }
            }
            writer.writeStartElement('office:scripts');
            writer.writeEndElement();
            let fonts = new Hashtable();
            for (let par of this.paragraphStyleList) {
                fonts.set(par.FontName, par.FontName);
            }
            writer.writeStartElement('office:font-face-decls');
            for (let deKey of fonts.keys) {
                let fontName = fonts.get(deKey);
                writer.writeStartElement('style:font-face');
                writer.writeAttributeString('style:name', fontName);
                writer.writeAttributeString('svg:font-family', fontName);
                writer.writeEndElement();
            }
            writer.writeEndElement();
            writer.writeStartElement('office:automatic-styles');
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'Table1');
            writer.writeAttributeString('style:family', 'table');
            writer.writeStartElement('style:table-properties');
            let tableWidth = this.matrix.coordX.getByIndex(this.matrix.coordX.countItems - 1) - this.matrix.coordX.getByIndex(0);
            writer.writeAttributeString('style:width', this.doubleToString(tableWidth));
            writer.writeAttributeString('table:align', 'left');
            writer.writeEndElement();
            writer.writeEndElement();
            for (let indexColumn = 0; indexColumn < this.matrix.coordX.countItems - 1; indexColumn++) {
                writer.writeStartElement('style:style');
                writer.writeAttributeString('style:name', StiString.format('Table1.{0}', this.getColumnName(indexColumn)));
                writer.writeAttributeString('style:family', 'table-column');
                writer.writeStartElement('style:table-column-properties');
                let columnWidth = this.matrix.coordX.getByIndex(indexColumn + 1) - this.matrix.coordX.getByIndex(indexColumn);
                writer.writeAttributeString('style:column-width', this.doubleToString(columnWidth));
                writer.writeEndElement();
                writer.writeEndElement();
            }
            for (let indexRow = 0; indexRow < rowHeightList.count; indexRow++) {
                writer.writeStartElement('style:style');
                writer.writeAttributeString('style:name', StiString.format('Table1.{0}', indexRow + 1));
                writer.writeAttributeString('style:family', 'table-row');
                writer.writeStartElement('style:table-row-properties');
                let rowHeight = rowHeightList2.get(indexRow);
                writer.writeAttributeString('style:row-height', this.doubleToString(rowHeight));
                writer.writeEndElement();
                writer.writeEndElement();
            }
            for (let indexStyle = 0; indexStyle < this.cellStyleList.stimulsoft().countItems; indexStyle++) {
                let style = this.cellStyleList[indexStyle];
                writer.writeStartElement('style:style');
                writer.writeAttributeString('style:name', StiString.format('cell{0}', indexStyle + 1));
                writer.writeAttributeString('style:family', 'table-cell');
                writer.writeStartElement('style:table-cell-properties');
                if (style.VertAlign == StiVertAlignment.Center)
                    writer.writeAttributeString('style:vertical-align', 'middle');
                if (style.VertAlign == StiVertAlignment.Bottom)
                    writer.writeAttributeString('style:vertical-align', 'bottom');
                if (style.BackColor.a > 0) {
                    writer.writeAttributeString('fo:background-color', this.getColorString(style.BackColor));
                } else {
                    writer.writeAttributeString('fo:background-color', 'transparent');
                }
                writer.writeAttributeString('fo:padding', '0in');
                writer.writeAttributeString('fo:border-left', style.BorderLeft);
                writer.writeAttributeString('fo:border-right', style.BorderRight);
                writer.writeAttributeString('fo:border-top', style.BorderTop);
                writer.writeAttributeString('fo:border-bottom', style.BorderBottom);
                writer.writeEndElement();
                writer.writeEndElement();
            }
            for (let indexStyle = 0; indexStyle < this.paragraphStyleList.stimulsoft().countItems; indexStyle++) {
                let style = this.paragraphStyleList[indexStyle];
                writer.writeStartElement('style:style');
                writer.writeAttributeString('style:name', StiString.format('par{0}', indexStyle + 1));
                writer.writeAttributeString('style:family', 'paragraph');
                writer.writeAttributeString('style:parent-style-name', 'Table_20_Contents');
                if (style.HorAlign != StiTextHorAlignment.Left) {
                    writer.writeStartElement('style:paragraph-properties');
                    if (style.HorAlign == StiTextHorAlignment.Center)
                        writer.writeAttributeString('fo:text-align', 'center');
                    if (style.HorAlign == StiTextHorAlignment.Right)
                        writer.writeAttributeString('fo:text-align', 'right');
                    if (style.HorAlign == StiTextHorAlignment.Width)
                        writer.writeAttributeString('fo:text-align', 'justify');
                    writer.writeEndElement();
                }
                writer.writeStartElement('style:text-properties');
                writer.writeAttributeString('fo:color', this.getColorString(style.FontColor));
                writer.writeAttributeString('style:font-name', style.FontName);
                let fontSizeSt = StiString.format('{0}pt', style.FontSize).stimulsoft().replaceAll(',', '.');
                writer.writeAttributeString('fo:font-size', fontSizeSt);
                writer.writeAttributeString('fo:font-size-asian', fontSizeSt);
                writer.writeAttributeString('fo:font-size-complex', fontSizeSt);
                if (style.Italic) {
                    writer.writeAttributeString('fo:font-style', 'italic');
                    writer.writeAttributeString('fo:font-style-asian', 'italic');
                    writer.writeAttributeString('fo:font-style-complex', 'italic');
                }
                if (style.Underline) {
                    writer.writeAttributeString('style:text-underline-style', 'solid');
                    writer.writeAttributeString('style:text-underline-width', 'auto');
                    writer.writeAttributeString('style:text-underline-color', 'font-color');
                }
                if (style.Bold) {
                    writer.writeAttributeString('fo:font-weight', 'bold');
                    writer.writeAttributeString('fo:font-weight-asian', 'bold');
                    writer.writeAttributeString('fo:font-weight-complex', 'bold');
                }
                if (style.Angle != 0) {
                    writer.writeAttributeString('style:text-rotation-angle', StiString.format('{0}', style.Angle));
                }
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'parEnd');
            writer.writeAttributeString('style:family', 'paragraph');
            writer.writeAttributeString('style:parent-style-name', 'Table_20_Contents');
            writer.writeStartElement('style:text-properties');
            let fontSizeStr = StiString.format('{0}pt', 1).stimulsoft().replaceAll(',', '.');
            writer.writeAttributeString('fo:font-size', fontSizeStr);
            writer.writeAttributeString('fo:font-size-asian', fontSizeStr);
            writer.writeAttributeString('fo:font-size-complex', fontSizeStr);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('style:style');
            writer.writeAttributeString('style:name', 'fr1');
            writer.writeAttributeString('style:family', 'graphic');
            writer.writeAttributeString('style:parent-style-name', 'Graphics');
            writer.writeStartElement('style:graphic-properties');
            writer.writeAttributeString('style:vertical-pos', 'middle');
            writer.writeAttributeString('style:vertical-rel', 'paragraph');
            writer.writeAttributeString('style:horizontal-pos', 'center');
            writer.writeAttributeString('style:horizontal-rel', 'paragraph');
            writer.writeAttributeString('fo:background-color', 'transparent');
            writer.writeAttributeString('style:background-transparency', '100%');
            writer.writeAttributeString('style:shadow', 'none');
            writer.writeAttributeString('style:mirror', 'none');
            writer.writeAttributeString('fo:clip', 'rect(0cm 0cm 0cm 0cm)');
            writer.writeAttributeString('draw:luminance', '0%');
            writer.writeAttributeString('draw:contrast', '0%');
            writer.writeAttributeString('draw:red', '0%');
            writer.writeAttributeString('draw:green', '0%');
            writer.writeAttributeString('draw:blue', '0%');
            writer.writeAttributeString('draw:gamma', '100%');
            writer.writeAttributeString('draw:color-inversion', 'false');
            writer.writeAttributeString('draw:image-opacity', '100%');
            writer.writeAttributeString('draw:color-mode', 'standard');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('office:body');
            writer.writeStartElement('office:text');
            writer.writeStartElement('office:forms');
            writer.writeAttributeString('form:automatic-focus', 'false');
            writer.writeAttributeString('form:apply-design-mode', 'false');
            writer.writeEndElement();
            writer.writeStartElement('text:sequence-decls');
            writer.writeStartElement('text:sequence-decl');
            writer.writeAttributeString('text:display-outline-level', '0');
            writer.writeAttributeString('text:name', 'Illustration');
            writer.writeEndElement();
            writer.writeStartElement('text:sequence-decl');
            writer.writeAttributeString('text:display-outline-level', '0');
            writer.writeAttributeString('text:name', 'Table');
            writer.writeEndElement();
            writer.writeStartElement('text:sequence-decl');
            writer.writeAttributeString('text:display-outline-level', '0');
            writer.writeAttributeString('text:name', 'Text');
            writer.writeEndElement();
            writer.writeStartElement('text:sequence-decl');
            writer.writeAttributeString('text:display-outline-level', '0');
            writer.writeAttributeString('text:name', 'Drawing');
            writer.writeEndElement();
            writer.writeEndElement();
            readyCells = StiArray.create2(Boolean, this.matrix.coordY.countItems, this.matrix.coordX.countItems);
            writer.writeStartElement('table:table');
            writer.writeAttributeString('table:name', 'Table1');
            writer.writeAttributeString('table:style-name', 'Table1');
            for (let indexColumn = 0; indexColumn < this.matrix.coordX.countItems - 1; indexColumn++) {
                writer.writeStartElement('table:table-column');
                writer.writeAttributeString('table:style-name', StiString.format('Table1.{0}', this.getColumnName(indexColumn)));
                writer.writeEndElement();
            }
            let progressScale = Math.max(this.matrix.coordY.countItems / 200, 1);
            let progressValue = 0;
            for (let indexRow = 1; indexRow < this.matrix.coordY.countItems; indexRow++) {
                let currentProgress = indexRow / progressScale | 0;
                if (currentProgress > progressValue) {
                    progressValue = currentProgress;
                    this.invokeExporting2(indexRow, this.matrix.coordY.countItems, this.currentPassNumber, this.maximumPassNumber);
                }
                writer.writeStartElement('table:table-row');
                writer.writeAttributeString('table:style-name', StiString.format('Table1.{0}', rowPosList[indexRow - 1] + 1));
                for (let indexColumn = 1; indexColumn < this.matrix.coordX.countItems; indexColumn++) {
                    let cell = this.matrix.cells[indexRow - 1][indexColumn - 1];
                    if (!readyCells[indexRow][indexColumn]) {
                        if (cell != null) {
                            for (let yy = 0; yy <= cell.height; yy++) {
                                for (let xx = 0; xx <= cell.width; xx++) {
                                    readyCells[indexRow + yy][indexColumn + xx] = true;
                                }
                            }
                            let cellStyleIndex = cellStyleTable[indexRow - 1][indexColumn - 1];
                            let parStyleIndex = this.getParagraphStyleNumber(indexRow - 1, indexColumn - 1);
                            writer.writeStartElement('table:table-cell');
                            writer.writeAttributeString('table:style-name', StiString.format('cell{0}', cellStyleIndex + 1));
                            if (cell.width > 0) {
                                writer.writeAttributeString('table:number-columns-spanned', StiString.format('{0}', cell.width + 1));
                            }
                            if (cell.height > 0) {
                                writer.writeAttributeString('table:number-rows-spanned', StiString.format('{0}', cell.height + 1));
                            }
                            writer.writeAttributeString('office:value-type', 'string');
                            if (cell.component.is(StiText) && !cell.component.isExportAsImage(__.a.StiExportFormat.Odt) && cell.text != null) {
                                let cellText = cell.text;
                                if (this.paragraphStyleList[parStyleIndex].stimulsoft().as(ParagraphStyleData).Angle != 0) {
                                    cellText = cellText.stimulsoft().replaceAll('\n', ' ');
                                }
                                let stringList = __.b.StiExportUtils.splitString(cellText, true);
                                for (let indexLine = 0; indexLine < stringList.stimulsoft().countItems; indexLine++) {
                                    let textLine = stringList[indexLine];
                                    writer.writeStartElement('text:p');
                                    writer.writeAttributeString('text:style-name', StiString.format('par{0}', parStyleIndex + 1));
                                    writer.writeString(textLine);
                                    writer.writeEndElement();
                                }
                            }
                            if (cell.component.isExportAsImage(__.a.StiExportFormat.Odt)) {
                                let exportImage = cell.component.stimulsoft().as(IStiExportImageExtended);
                                if (exportImage != null) {
                                    let rsImageResolution = this.imageResolution;
                                    let REFzoom = { ref: rsImageResolution };
                                    let image = exportImage.getImage(REFzoom);
                                    rsImageResolution = REFzoom.ref;
                                    if (image != null) {
                                        let indexImage = this.imageCache.addImageIntRaw(image, image.imageFormat);
                                        let imageWidth = this.matrix.coordX.getByIndex(indexColumn + cell.width) - this.matrix.coordX.getByIndex(indexColumn - 1);
                                        let imageHeight = this.matrix.coordY.getByIndex(indexRow + cell.height) - this.matrix.coordY.getByIndex(indexRow - 1);
                                        writer.writeStartElement('text:p');
                                        writer.writeAttributeString('text:style-name', 'Table_20_Contents');
                                        writer.writeStartElement('draw:frame');
                                        writer.writeAttributeString('draw:style-name', 'fr1');
                                        writer.writeAttributeString('draw:name', StiString.format('Picture{0}', indexImage + 1));
                                        writer.writeAttributeString('text:anchor-type', 'paragraph');
                                        writer.writeAttributeString('svg:width', this.doubleToString(imageWidth));
                                        writer.writeAttributeString('svg:height', this.doubleToString(imageHeight));
                                        writer.writeAttributeString('draw:z-index', '0');
                                        writer.writeStartElement('draw:image');
                                        writer.writeAttributeString('xlink:href', StiString.format('Pictures/{0:D5}.jpg', indexImage + 1));
                                        writer.writeAttributeString('xlink:type', 'simple');
                                        writer.writeAttributeString('xlink:show', 'embed');
                                        writer.writeAttributeString('xlink:actuate', 'onLoad');
                                        writer.writeEndElement();
                                        writer.writeEndElement();
                                        writer.writeEndElement();
                                    }
                                }
                            }
                            writer.writeEndElement();
                        } else {
                            let cellStyleIndex = cellStyleTable[indexRow - 1][indexColumn - 1];
                            writer.writeStartElement('table:table-cell');
                            writer.writeAttributeString('table:style-name', StiString.format('cell{0}', cellStyleIndex + 1));
                            writer.writeEndElement();
                        }
                    } else {
                        writer.writeStartElement('table:covered-table-cell');
                        writer.writeEndElement();
                    }
                }
                writer.writeEndElement();
            }
            writer.writeEndElement();
            writer.writeStartElement('text:p');
            writer.writeAttributeString('text:style-name', 'parEnd');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        exportOdt(report, stream, settings) {
            __.a.StiLogService.write(this.stimulsoft().getType(), 'Export report to ODT format');
            if (settings == null)
                throw new Error("The 'settings' argument cannot be equal in null.");
            let pageRange = settings.pageRange;
            this.usePageHeadersAndFooters = settings.usePageHeadersAndFooters;
            this.removeEmptySpaceAtBottom = settings.removeEmptySpaceAtBottom;
            this.imageResolution = settings.imageResolution;
            this.imageQuality = settings.imageQuality;
            this.xmlIndentation = -1;
            if (this.imageQuality < 0)
                this.imageQuality = 0;
            if (this.imageQuality > 1)
                this.imageQuality = 1;
            if (this.imageResolution < 10)
                this.imageResolution = 10;
            this.imageResolution = this.imageResolution / 100;
            try {
                this.imageCache = new __.a.StiImageCache(Stimulsoft['StiOptions'].Export.OpenDocumentWriter.allowImageComparer, true, ImageFormat.Jpeg, this.imageQuality, false);
                this.cellStyleList = [];
                this.paragraphStyleList = [];
                this.currentPassNumber = 0;
                this.maximumPassNumber = 3 + (Stimulsoft['StiOptions'].Export.OpenDocumentWriter.divideSegmentPages ? 1 : 0);
                let pages = pageRange.getSelectedPages(report.renderedPages);
                if (Stimulsoft['StiOptions'].Export.OpenDocumentWriter.divideSegmentPages) {
                    pages = __.b.StiSegmentPagesDivider.divide(pages, this);
                    this.currentPassNumber++;
                }
                if (this.isStopped)
                    return;
                let zip = new StiZipWriter20();
                zip.begin(stream, true);
                this.matrix = new __.b.StiMatrix(pages, true, this);
                this.currentPassNumber = 2 + (Stimulsoft['StiOptions'].Export.OpenDocumentWriter.divideSegmentPages ? 1 : 0);
                zip.addFile('content.xml', this.writeContent());
                zip.addFile('mimetype', this.writeMimetype());
                zip.addFile('meta.xml', this.writeMeta());
                zip.addFile('META-INF/manifest.xml', this.writeManifest());
                zip.addFile('settings.xml', this.writeSettings());
                zip.addFile('styles.xml', this.writeStyles(pages));
                if (this.imageCache.imagePackedStore.stimulsoft().countItems > 0) {
                    for (let index = 0; index < this.imageCache.imagePackedStore.stimulsoft().countItems; index++) {
                        zip.addFile(StiString.format('Pictures/{0:D5}.jpg', index + 1), this.writeImage(index));
                    }
                }
                zip.end();
            } finally {
                if (this.matrix != null) {
                    this.matrix.clear();
                    this.matrix = null;
                }
                this.cellStyleList.stimulsoft().clear();
                this.cellStyleList = null;
                this.paragraphStyleList.stimulsoft().clear();
                this.paragraphStyleList = null;
                this.imageCache.clear();
                this.imageCache = null;
                if (report.renderedPages.cacheMode)
                    __.b.StiMatrix.GCCollect();
            }
        }
    };
}
{
    let StiRtfStyleInfo = class {
    };
    __.b.StiRtfExportService = class extends __.b.StiExportService {
        constructor() {
            super(...arguments);
            this.multipleFiles = false;
            this.colorList = null;
            this.fontList = null;
            this.styleList = null;
            this.unicodeMapArray = null;
            this.codePageToFont = null;
            this.charsetCount = 0;
            this.fontToCodePages = null;
            this.baseFontNumber = 0;
            this.usePageHeadersAndFooters = false;
            this.imageResolution = 0.96;
            this.imageQuality = 0.75;
            this.imageFormat = __.a.StiExportFormat.Rtf;
            this.useStyles = false;
            this.bookmarkList = null;
            this.usedBookmarks = null;
        }
        get defaultExtension() {
            return 'rtf';
        }
        get exportFormat() {
            return __.a.StiExportFormat.Rtf;
        }
        get groupCategory() {
            return 'Word';
        }
        get position() {
            return __.b.StiExportPosition.Rtf;
        }
        get exportNameInMenu() {
            return StiLocalization.get('Export', 'ExportTypeRtfFile');
        }
        getFilter() {
            return StiLocalization.get('FileFilters', 'RtfFiles');
        }
        exportTo(report, stream, settings) {
        }
        getColorNumberInt(tmpColorList, incomingColor) {
            if (tmpColorList.length > 0) {
                for (let index = 0; index < tmpColorList.length; index++) {
                    if (tmpColorList[index].equals(incomingColor)) {
                        return index;
                    }
                }
            }
            tmpColorList.push(incomingColor);
            let temp = tmpColorList.length - 1;
            return temp;
        }
        getColorNumber(tmpColorList, incomingColor) {
            return this.getColorNumberInt(tmpColorList, incomingColor).toString();
        }
        getFontNumber2(tmpFontList, incomingFont) {
            if (tmpFontList.length > 0) {
                for (let index = 0; index < tmpFontList.length; index++) {
                    let tmpFont = tmpFontList[index];
                    if (tmpFont.name == incomingFont.name) {
                        return index * (this.charsetCount == 0 ? 1 : this.charsetCount);
                    }
                }
            }
            tmpFontList.push(incomingFont);
            let temp = tmpFontList.length - 1;
            return temp * (this.charsetCount == 0 ? 1 : this.charsetCount);
        }
        getFontNumber3(tmpFontList, incomingFont, charset) {
            if (tmpFontList.length > 0) {
                for (let index = 0; index < tmpFontList.length; index++) {
                    let tmpFont = tmpFontList[index];
                    if (tmpFont.name == incomingFont.name) {
                        return index * (this.charsetCount == 0 ? 1 : this.charsetCount) + this.getCharsetIndex(charset);
                    }
                }
            }
            tmpFontList.push(incomingFont);
            let temp = tmpFontList.length - 1;
            return temp * (this.charsetCount == 0 ? 1 : this.charsetCount) + this.getCharsetIndex(charset);
        }
        getCharsetIndex(charset) {
            let charsetIndex = 0;
            if (this.charsetCount == 0) {
                this.codePageToFont[charsetIndex] = 1;
                return 0;
            }
            return this.codePageToFont[charsetIndex];
        }
    };
}
let StiTxtBorderType = __.b.StiTxtBorderType;
let IStiTextHorAlignment = __.a.Components.IStiTextHorAlignment;
let IStiVertAlignment = __.a.Components.IStiVertAlignment;
let StiTextRenderer = Stimulsoft.Base.Drawing.StiTextRenderer;
let StiHtmlState = Stimulsoft.Base.Drawing.StiHtmlState;
let IStiTextOptions = __.a.Components.IStiTextOptions;
let StringBuilder = Stimulsoft.System.Text.StringBuilder;
{
    let StiTxtExportService = class extends __.b.StiExportService {
        constructor() {
            super(...arguments);
            this.multipleFiles = false;
            this.borderCodes = [
                6,
                9,
                12,
                10,
                5,
                3,
                13,
                11,
                14,
                7,
                15,
                1,
                2,
                4,
                8
            ];
            this.firstEscapeCodeIndex = 63742;
            this.ltrMark = ' 0E';
            this.useFullVerticalBorder = true;
            this.useFullHorizontalBorder = true;
        }
        implements() {
            return [__.b.IStiTxtExportService];
        }
        get defaultExtension() {
            return 'txt';
        }
        exportTo(report, stream, settings) {
            this.exportTxt(report, stream, settings);
        }
        exportToAsync(onExport, report, stream, settings) {
            this.exportTo(report, stream, settings);
            onExport();
        }
        get exportFormat() {
            return __.a.StiExportFormat.Text;
        }
        get groupCategory() {
            return 'Word';
        }
        get position() {
            return __.b.StiExportPosition.Txt;
        }
        get exportNameInMenu() {
            return StiLocalization.get('Export', 'ExportTypeTxtFile');
        }
        getFilter() {
            return StiLocalization.get('FileFilters', 'TxtFiles');
        }
        getBorderChar(code, type) {
            if (this.useFullVerticalBorder) {
                switch (type) {
                case StiTxtBorderType.UnicodeSingle:
                    return '─│┌┐└┘├┤┬┴┼ ─  '.charCodeAt(code);
                case StiTxtBorderType.UnicodeDouble:
                    return '═║╔╗╚╝╠╣╦╩╬ ═  '.charCodeAt(code);
                default:
                    return '-|+++++++++ -  '.charCodeAt(code);
                }
            } else {
                switch (type) {
                case StiTxtBorderType.UnicodeSingle:
                    return '─│┌┐└┘├┤┬┴┼    '.charCodeAt(code);
                case StiTxtBorderType.UnicodeDouble:
                    return '═║╔╗╚╝╠╣╦╩╬    '.charCodeAt(code);
                default:
                    return '-|+++++++++    '.charCodeAt(code);
                }
            }
        }
        lineFill(sb, code, startPosition, count) {
            let ch = this.borderCodes[code - 1];
            for (let index = 0; index < count; index++) {
                if (this.borderCodes.indexOf(sb[startPosition + index]) == -1) {
                    if (sb[startPosition + index] == 32)
                        sb[startPosition + index] = ch;
                } else
                    sb[startPosition + index] |= ch;
            }
        }
        lineFillChar(sb, code, startPosition, count) {
            for (let index = 0; index < count; index++) {
                sb[startPosition + index] = code;
            }
        }
        checkWordWrap(cell, refAarraySt, cellWidth, cutLongLines) {
            let arraySt = refAarraySt.ref;
            if (this.useEscapeCodes) {
                for (let index = 0; index < arraySt.length; index++) {
                    let st = arraySt[index];
                    let text = new StringBuilder(st);
                    if (__.b.StiBidirectionalConvert.stringContainArabicOrHebrew(st)) {
                        let pos3 = st.length;
                        while (Char.isWhitespace(st, pos3 - 1))
                            pos3--;
                        text.insert(pos3, '<#ltrMark>');
                    }
                    let pos = 0;
                    while (pos < text.length) {
                        if (text.charAt(pos) == '<' && pos < text.length + 1 && text.charAt(pos + 1) == '#') {
                            let pos2 = pos;
                            let escapeString = new StringBuilder();
                            while (text.charAt(pos2) == '<' && pos2 < text.length + 1 && text.charAt(pos2 + 1) == '#') {
                                while (pos2 < text.length && text.charAt(pos2) != '>') {
                                    escapeString.append(text.charAt(pos2));
                                    pos2++;
                                }
                                escapeString.append('>');
                                pos2++;
                                if (pos2 > text.length - 1)
                                    break;
                            }
                            if (pos2 > text.length - 1) {
                                if (pos > 0) {
                                    pos--;
                                    escapeString.insert(0, text[pos]);
                                } else {
                                    escapeString.append(String.fromCharCode(65535));
                                }
                            } else {
                                escapeString.append(text.charAt(pos2));
                                pos2++;
                            }
                            let escapeIndex = this.getEscapeNumber(this.escapeCodesList, escapeString.toString());
                            text.remove(pos, pos2 - pos);
                            text.insert(pos, String.fromCharCode(this.firstEscapeCodeIndex - escapeIndex));
                        }
                        pos++;
                    }
                    if (text.length != arraySt[index].length)
                        arraySt[index] = text.toString();
                }
            } else {
                for (let index = 0; index < arraySt.length; index++) {
                    if (__.b.StiBidirectionalConvert.stringContainArabicOrHebrew(arraySt[index])) {
                        let st = arraySt[index];
                        let pos = st.length - 1;
                        while (Char.isWhitespace(st, pos))
                            pos--;
                        let escapeString = st.charAt(pos) + this.ltrMark;
                        let escapeIndex = this.getEscapeNumber(this.escapeCodesList, escapeString);
                        if (pos == st.length - 1)
                            arraySt[index] = st.substring(0, pos) + String.fromCharCode(this.firstEscapeCodeIndex - escapeIndex);
                        else
                            arraySt[index] = st.substring(0, pos) + String.fromCharCode(this.firstEscapeCodeIndex - escapeIndex) + st.substring(pos + 1);
                    }
                }
            }
            let widthOfCell = cellWidth;
            if (this.useFullVerticalBorder) {
                if (this.needVerticalBorders[cell.left + cell.width])
                    widthOfCell--;
            } else {
                if (!this.useFullTextBoxWidth && widthOfCell > 1)
                    widthOfCell--;
            }
            let wordWrap = false;
            let textOpt = cell.component.stimulsoft().as(IStiTextOptions);
            if (textOpt != null)
                wordWrap = textOpt.textOptions.wordWrap;
            if (wordWrap) {
                let stringList = arraySt.stimulsoft().clone();
                for (let indexLine = 0; indexLine < stringList.length; indexLine++) {
                    let stt = stringList[indexLine];
                    if (stt.length > widthOfCell - 1 && widthOfCell > 1) {
                        let wordarr = StiArray.create(Number, stt.length);
                        let wordCounter = 0;
                        let tempIndexSpace = 0;
                        while (stt.charAt(tempIndexSpace) == ' ') {
                            wordarr[tempIndexSpace] = wordCounter;
                            tempIndexSpace++;
                        }
                        for (let tempIndex = tempIndexSpace; tempIndex < stt.length; tempIndex++) {
                            if (stt.charAt(tempIndex) == ' ')
                                wordCounter++;
                            wordarr[tempIndex] = wordCounter;
                        }
                        let index = widthOfCell - 1 - 1;
                        let index2 = index;
                        if (wordarr[index] > 0) {
                            if (wordarr[index] != wordarr[index + 1]) {
                                index2 = index++;
                                while (stt.charAt(index) == ' ')
                                    index++;
                            } else {
                                while (stt.charAt(index) != ' ')
                                    index--;
                                index2 = index++;
                                while (stt.charAt(index2) == ' ')
                                    index2--;
                            }
                        } else
                            index++;
                        stringList[indexLine] = stt.substring(0, index2 + 1);
                        stringList.stimulsoft().insert(indexLine + 1, stt.substr(index, stt.length - index));
                    }
                }
                if (stringList.length > arraySt.length) {
                    arraySt = stringList;
                }
            }
            if (cutLongLines) {
                for (let index = 0; index < arraySt.length; index++) {
                    if (arraySt[index].length > widthOfCell)
                        arraySt[index] = arraySt[index].substring(0, widthOfCell);
                }
            }
            refAarraySt.ref = arraySt;
        }
        checkGrow(lines, pageBreaks, currentY) {
            while (lines.length <= currentY) {
                lines.push([]);
                pageBreaks.push(false);
            }
        }
        addCharsToLine(lines, line, count, char) {
            for (let tempIndex = 0; tempIndex < count; tempIndex++) {
                lines[line].push(char);
            }
        }
        getStyleNumber(tmpStyleList, styleInfo) {
            if (tmpStyleList.length > 0) {
                for (let index = 0; index < tmpStyleList.length; index++) {
                    let tmpStyle = tmpStyleList[index];
                    if (tmpStyle.Bold == styleInfo.Bold && tmpStyle.Italic == styleInfo.Italic && tmpStyle.Underline == styleInfo.Underline && tmpStyle.Codes == styleInfo.Codes) {
                        return index;
                    }
                }
            }
            tmpStyleList.push(styleInfo);
            let temp = tmpStyleList.length - 1;
            return temp;
        }
        getEscapeNumber(tmpStyleList, escapeCodes) {
            if (tmpStyleList.length > 0) {
                for (let index = 0; index < tmpStyleList.length; index++) {
                    if (tmpStyleList[index] == escapeCodes) {
                        return index + 1;
                    }
                }
            }
            tmpStyleList.push(escapeCodes);
            let temp = tmpStyleList.length;
            return temp;
        }
        getEscapeNames(oldStyleNumber, newStyleNumber) {
            let oldStyle = this.styleList[oldStyleNumber];
            let newStyle = this.styleList[newStyleNumber];
            let sb = new StringBuilder();
            if (!oldStyle.Bold && newStyle.Bold)
                sb.append('<#b>');
            if (oldStyle.Bold && !newStyle.Bold)
                sb.append('<#/b>');
            if (!oldStyle.Italic && newStyle.Italic)
                sb.append('<#i>');
            if (oldStyle.Italic && !newStyle.Italic)
                sb.append('<#/i>');
            if (!oldStyle.Underline && newStyle.Underline)
                sb.append('<#u>');
            if (oldStyle.Underline && !newStyle.Underline)
                sb.append('<#/u>');
            return sb;
        }
        exportTxt(report, stream, settings) {
            __.a.StiLogService.write(this.stimulsoft().getType(), 'Export report to Text format');
            this.report = report;
            if (settings == null)
                throw new Error("The 'settings' argument cannot be equal in null.");
            let pageRange = settings.pageRange;
            let encoding = settings.encoding;
            let drawBorder = settings.drawBorder;
            let borderType = settings.borderType;
            let killSpaceLines = settings.killSpaceLines;
            let killSpaceGraphLines = settings.killSpaceGraphLines;
            let putFeedPageCode = settings.putFeedPageCode;
            let cutLongLines = settings.cutLongLines;
            let zoomX = settings.zoomX;
            let zoomY = settings.zoomY;
            this.useEscapeCodes = settings.useEscapeCodes;
            this.useFullTextBoxWidth = Stimulsoft['StiOptions'].Export.Text.useFullTextBoxWidth;
            this.useFullVerticalBorder = Stimulsoft['StiOptions'].Export.Text.useFullVerticalBorder;
            this.useFullHorizontalBorder = Stimulsoft['StiOptions'].Export.Text.useFullHorizontalBorder;
            const insideScaleX = 9.7;
            const insideScaleY = 18;
            if (killSpaceLines == false)
                killSpaceGraphLines = false;
            if (drawBorder == false)
                killSpaceGraphLines = false;
            if (this.useFullVerticalBorder)
                this.useFullTextBoxWidth = false;
            let ms = new MemoryStream();
            let sw = encoding != null ? new StreamWriter(ms, encoding) : new StreamWriter(ms);
            let pages = pageRange.getSelectedPages(report.renderedPages);
            let pageLines = 0;
            this.styleList = [];
            let baseStyle = new StiTxtStyleInfo();
            this.getStyleNumber(this.styleList, baseStyle);
            this.escapeCodesList = [];
            this.currentPassNumber = 0;
            this.maximumPassNumber = 3;
            let matrix = new __.b.StiMatrix(pages, false, this);
            if (this.isStopped)
                return;
            this.needVerticalBorders = StiArray.create(Boolean, matrix.coordX.countItems);
            for (let columnIndex = 1; columnIndex < matrix.coordX.countItems; columnIndex++) {
                let needVertical = false;
                for (let rowIndex = 1; rowIndex < matrix.coordY.countItems; rowIndex++) {
                    if (matrix.bordersY[rowIndex - 1][columnIndex] != null) {
                        needVertical = true;
                        break;
                    }
                }
                this.needVerticalBorders[columnIndex - 1] = needVertical;
            }
            this.needHorizontalBorders = StiArray.create(Boolean, matrix.coordY.countItems);
            for (let rowIndex = 1; rowIndex < matrix.coordY.countItems; rowIndex++) {
                let needHorizontal = false;
                for (let columnIndex = 1; columnIndex < matrix.coordX.countItems; columnIndex++) {
                    if (matrix.bordersX[rowIndex][columnIndex - 1] != null) {
                        needHorizontal = true;
                        break;
                    }
                }
                this.needHorizontalBorders[rowIndex - 1] = needHorizontal;
            }
            let defaultWidths = StiArray.create(Number, matrix.coordX.countItems);
            for (let columnIndex = 1; columnIndex < matrix.coordX.countItems; columnIndex++) {
                let value2 = matrix.coordX.getByIndex(columnIndex);
                let value1 = matrix.coordX.getByIndex(columnIndex - 1);
                defaultWidths[columnIndex - 1] = Math.round((value2 - value1) / (insideScaleX / zoomX));
                if (this.useFullVerticalBorder && this.needVerticalBorders[columnIndex - 1])
                    defaultWidths[columnIndex - 1]++;
            }
            let readyCells = StiArray.create2(Boolean, matrix.coordY.countItems, matrix.coordX.countItems);
            let widths = StiArray.create2(Number, matrix.coordY.countItems, matrix.coordX.countItems);
            let heights = StiArray.create2(Number, matrix.coordY.countItems, matrix.coordX.countItems);
            for (let rowIndex = 1; rowIndex < matrix.coordY.countItems; rowIndex++) {
                for (let columnIndex = 1; columnIndex < matrix.coordX.countItems; columnIndex++) {
                    if (!readyCells[rowIndex - 1][columnIndex - 1]) {
                        let cell = matrix.cells[rowIndex - 1][columnIndex - 1];
                        widths[rowIndex - 1][columnIndex - 1] = defaultWidths[columnIndex - 1];
                        if (cell != null) {
                            if (cell.width > 0) {
                                for (let index = 0; index < cell.width; index++) {
                                    widths[rowIndex - 1][columnIndex - 1] += defaultWidths[columnIndex - 1 + 1 + index];
                                }
                            }
                            if (cell.component != null) {
                                if (cell.component != null) {
                                    let sTag = cell.component.tagValue;
                                    if (!StiString.isNullOrWhiteSpace(sTag)) {
                                        sTag = sTag.trim();
                                        let param = parseInt(sTag);
                                        if (!isNaN(param) && param > 0) {
                                            widths[rowIndex - 1][columnIndex - 1] = param;
                                            if (this.useFullVerticalBorder && this.needVerticalBorders[columnIndex - 1 + cell.width])
                                                widths[rowIndex - 1][columnIndex - 1]++;
                                        }
                                    }
                                }
                                let str = cell.text;
                                let mCheckbox = cell.component.stimulsoft().as(StiCheckBox);
                                if (mCheckbox != null && mCheckbox.checkedValue != null) {
                                    let isTrue = false;
                                    let isFalse = false;
                                    if (typeof mCheckbox.checkedValue == 'boolean') {
                                        if (mCheckbox.checkedValue)
                                            isTrue = true;
                                        else
                                            isFalse = true;
                                    }
                                    if (typeof mCheckbox.checkedValue == 'string') {
                                        if (mCheckbox.checkedValue == 'True')
                                            isTrue = true;
                                        else
                                            isFalse = true;
                                    }
                                    if (isTrue)
                                        str = Stimulsoft['StiOptions'].Export.Text.checkBoxTextForTrue;
                                    if (isFalse)
                                        str = Stimulsoft['StiOptions'].Export.Text.checkBoxTextForFalse;
                                }
                                if (!cell.component.isExportAsImage(__.a.StiExportFormat.Text) && !StiString.isNullOrEmpty(str)) {
                                    if (cell.component.is(StiText) && cell.component.checkAllowHtmlTags()) {
                                        let baseState = new StiHtmlState('');
                                        let listStates = StiTextRenderer.parseHtmlToStates(str, baseState);
                                        let sb = new StringBuilder();
                                        for (let state of listStates) {
                                            sb.append(StiTextRenderer.prepareStateText(state.text));
                                        }
                                        str = sb.toString();
                                    }
                                    let arraySt = __.b.StiExportUtils.splitString(str.stimulsoft().replaceAll('\r', ''), false);
                                    let refArraySt = { ref: arraySt };
                                    this.checkWordWrap(cell, refArraySt, widths[rowIndex - 1][columnIndex - 1], cutLongLines);
                                    arraySt = refArraySt.ref;
                                    let numLines = arraySt.length;
                                    heights[rowIndex - 1][columnIndex - 1] = numLines;
                                }
                            }
                            for (let yy = 0; yy <= cell.height; yy++) {
                                for (let xx = 0; xx <= cell.width; xx++) {
                                    readyCells[rowIndex - 1 + yy][columnIndex - 1 + xx] = true;
                                }
                                widths[rowIndex - 1 + yy][columnIndex - 1] = widths[rowIndex - 1][columnIndex - 1];
                            }
                        }
                    }
                }
            }
            let rowHeights = StiArray.create(Number, matrix.coordY.countItems);
            pageLines = 1;
            for (let rowIndex = 1; rowIndex < matrix.coordY.countItems; rowIndex++) {
                let value2 = matrix.coordY.getByIndex(rowIndex);
                let value1 = matrix.coordY.getByIndex(rowIndex - 1);
                let defaultHeight = Math.round((value2 - value1) / (insideScaleY / zoomY));
                if (defaultHeight < 1)
                    defaultHeight = 1;
                for (let columnIndex = 1; columnIndex < matrix.coordX.countItems; columnIndex++) {
                    let cell = matrix.cells[rowIndex - 1][columnIndex - 1];
                    if (cell != null && cell.height < 1 && heights[rowIndex - 1][columnIndex - 1] > defaultHeight)
                        defaultHeight = heights[rowIndex - 1][columnIndex - 1];
                }
                if (this.useFullHorizontalBorder && this.needHorizontalBorders[rowIndex - 1])
                    defaultHeight++;
                rowHeights[rowIndex - 1] = defaultHeight;
                pageLines += defaultHeight;
            }
            pageLines++;
            let lines = [];
            let styles = [];
            let pageBreaks = [];
            for (let indexLine = 0; indexLine < pageLines; indexLine++) {
                lines.push([]);
                styles.push([]);
                pageBreaks.push(false);
            }
            readyCells = StiArray.create2(Boolean, matrix.coordY.countItems, matrix.coordX.countItems);
            let cellPositionY = drawBorder ? 1 : 0;
            let checkboxText = new StiText();
            checkboxText.vertAlignment = StiVertAlignment.Center;
            checkboxText.horAlignment = StiTextHorAlignment.Center;
            this.currentPassNumber = 2;
            for (let rowIndex = 1; rowIndex < matrix.coordY.countItems; rowIndex++) {
                this.invokeExporting2(rowIndex, matrix.coordY.countItems, this.currentPassNumber, this.maximumPassNumber);
                for (let indexLine = 0; indexLine < matrix.horizontalPageBreaks.length; indexLine++) {
                    if (matrix.horizontalPageBreaks[indexLine] == rowIndex - 1)
                        pageBreaks[cellPositionY - (drawBorder && rowIndex > 1 && this.needHorizontalBorders[rowIndex - 1 - 1] ? 1 : 0)] = true;
                }
                let cellPositionX = drawBorder ? 1 : 0;
                for (let columnIndex = 1; columnIndex < matrix.coordX.countItems; columnIndex++) {
                    let cell = matrix.cells[rowIndex - 1][columnIndex - 1];
                    let cellSizeX = widths[rowIndex - 1][columnIndex - 1];
                    let cellSizeY = rowHeights[rowIndex - 1];
                    if (!readyCells[rowIndex - 1][columnIndex - 1]) {
                        let cellWidth = 0;
                        let cellHeight = 0;
                        let cellStyleIndex = 0;
                        if (cell != null) {
                            cellWidth = cell.width;
                            cellHeight = cell.height;
                            for (let xx = 0; xx <= cell.width; xx++) {
                                for (let yy = 0; yy <= cell.height; yy++) {
                                    readyCells[rowIndex - 1 + yy][columnIndex - 1 + xx] = true;
                                }
                            }
                            if (cell.height > 0) {
                                for (let index = 0; index < cell.height; index++) {
                                    cellSizeY += rowHeights[rowIndex - 1 + 1 + index];
                                }
                            }
                            if (this.useFullHorizontalBorder && this.needHorizontalBorders[rowIndex - 1 + cellHeight])
                                cellSizeY--;
                            if (cell.component != null) {
                                let textComp = cell.component.stimulsoft().as(StiText);
                                if (textComp != null) {
                                    let styleInfo = new StiTxtStyleInfo();
                                    styleInfo.Bold = textComp.font.bold;
                                    styleInfo.Italic = textComp.font.italic;
                                    styleInfo.Underline = textComp.font.underline;
                                    styleInfo.Codes = null;
                                    cellStyleIndex = this.getStyleNumber(this.styleList, styleInfo);
                                }
                                let str = cell.text;
                                let mCheckbox = cell.component.stimulsoft().as(StiCheckBox);
                                if (mCheckbox != null && mCheckbox.checkedValue != null) {
                                    let isTrue = false;
                                    let isFalse = false;
                                    if (typeof mCheckbox.checkedValue == 'boolean') {
                                        if (mCheckbox.checkedValue)
                                            isTrue = true;
                                        else
                                            isFalse = true;
                                    }
                                    if (typeof mCheckbox.checkedValue == 'string') {
                                        if (mCheckbox.checkedValue == 'True')
                                            isTrue = true;
                                        else
                                            isFalse = true;
                                    }
                                    if (isTrue)
                                        str = Stimulsoft['StiOptions'].Export.Text.checkBoxTextForTrue;
                                    if (isFalse)
                                        str = Stimulsoft['StiOptions'].Export.Text.checkBoxTextForFalse;
                                }
                                if (!cell.component.isExportAsImage(__.a.StiExportFormat.Text) && !StiString.isNullOrEmpty(str)) {
                                    if (cell.component.is(StiText) && cell.component.checkAllowHtmlTags()) {
                                        let baseState = new StiHtmlState('');
                                        let listStates = StiTextRenderer.parseHtmlToStates(str, baseState);
                                        let sb = new StringBuilder();
                                        for (let state of listStates) {
                                            sb.append(StiTextRenderer.prepareStateText(state.text));
                                        }
                                        str = sb.toString();
                                    }
                                    let arraySt = __.b.StiExportUtils.splitString(str.stimulsoft().replaceAll('\r', ''), false);
                                    let refArraySt = { ref: arraySt };
                                    this.checkWordWrap(cell, refArraySt, widths[rowIndex - 1][columnIndex - 1], cutLongLines);
                                    arraySt = refArraySt.ref;
                                    let textOffsetY = 0;
                                    let vertAlignment = cell.component.stimulsoft().as(IStiVertAlignment);
                                    if (mCheckbox != null)
                                        vertAlignment = checkboxText;
                                    if (vertAlignment != null && arraySt.length < cellSizeY) {
                                        if ((vertAlignment.vertAlignment & StiVertAlignment.Center) > 0)
                                            textOffsetY = StiMath.trunc((cellSizeY - arraySt.length) / 2);
                                        if ((vertAlignment.vertAlignment & StiVertAlignment.Bottom) > 0)
                                            textOffsetY = cellSizeY - arraySt.length;
                                    }
                                    for (let indexLine = 0; indexLine < arraySt.length; indexLine++) {
                                        let textOffsetX = 0;
                                        let widthOfText = cellSizeX;
                                        if (this.useFullVerticalBorder) {
                                            if (this.needVerticalBorders[cell.left + cell.width])
                                                widthOfText--;
                                        } else {
                                            if (!this.useFullTextBoxWidth && widthOfText > 1)
                                                widthOfText--;
                                        }
                                        let horAlignment = cell.component.stimulsoft().as(IStiTextHorAlignment);
                                        if (mCheckbox != null)
                                            horAlignment = checkboxText;
                                        if (horAlignment != null) {
                                            if (horAlignment.horAlignment == StiTextHorAlignment.Center)
                                                textOffsetX = StiMath.trunc((widthOfText - arraySt[indexLine].length) / 2);
                                            if (horAlignment.horAlignment == StiTextHorAlignment.Right)
                                                textOffsetX = widthOfText - arraySt[indexLine].length;
                                        }
                                        let textX = cellPositionX + textOffsetX;
                                        let textY = cellPositionY + textOffsetY + indexLine;
                                        if (textX < 0)
                                            textX = 0;
                                        let lineEndPos = textX + arraySt[indexLine].length;
                                        this.checkGrow(lines, pageBreaks, textY);
                                        if (lines[textY].length < lineEndPos) {
                                            this.addCharsToLine(lines, textY, lineEndPos - lines[textY].length, 32);
                                        }
                                        for (let indexChar = 0; indexChar < arraySt[indexLine].length; indexChar++) {
                                            let sym = arraySt[indexLine].charCodeAt(indexChar);
                                            if (sym < 32)
                                                sym += 65280;
                                            lines[textY][textX + indexChar] = sym;
                                        }
                                    }
                                }
                            }
                        } else {
                            if (this.useFullHorizontalBorder && this.needHorizontalBorders[rowIndex - 1])
                                cellSizeY--;
                        }
                        if (!this.useFullHorizontalBorder)
                            cellSizeY--;
                        for (let tempIndexY = 0; tempIndexY < cellSizeY; tempIndexY++) {
                            if (styles[cellPositionY + tempIndexY].length < cellPositionX + cellSizeX) {
                                this.addCharsToLine(styles, cellPositionY + tempIndexY, cellPositionX + cellSizeX - styles[cellPositionY + tempIndexY].length, 0);
                            }
                            let widthOfText = cellSizeX;
                            if (this.useFullVerticalBorder) {
                                if (cell != null && this.needVerticalBorders[cell.left + cell.width])
                                    widthOfText--;
                            } else {
                                if (!this.useFullTextBoxWidth && widthOfText > 1)
                                    widthOfText--;
                            }
                            this.lineFillChar(styles[cellPositionY + tempIndexY], cellStyleIndex, cellPositionX, widthOfText);
                        }
                        if (drawBorder) {
                            let lineEndPos = cellPositionX + cellSizeX - 1;
                            for (let index = -1; index <= cellSizeY; index++) {
                                this.checkGrow(lines, pageBreaks, cellPositionY + index);
                                if (lines[cellPositionY + index].length < lineEndPos + 1)
                                    this.addCharsToLine(lines, cellPositionY + index, lineEndPos + 1 - lines[cellPositionY + index].length, 32);
                            }
                            let needBorderLeft = true;
                            let needBorderRight = true;
                            for (let index = 0; index < cellHeight + 1; index++) {
                                if (matrix.bordersY[rowIndex - 1 + index][columnIndex - 1] == null)
                                    needBorderLeft = false;
                                if (matrix.bordersY[rowIndex - 1 + index][columnIndex - 1 + cellWidth + 1] == null)
                                    needBorderRight = false;
                            }
                            let needBorderTop = true;
                            let needBorderBottom = true;
                            for (let index = 0; index < cellWidth + 1; index++) {
                                if (matrix.bordersX[rowIndex - 1][columnIndex - 1 + index] == null)
                                    needBorderTop = false;
                                if (matrix.bordersX[rowIndex - 1 + cellHeight + 1][columnIndex - 1 + index] == null)
                                    needBorderBottom = false;
                            }
                            if (needBorderTop) {
                                this.lineFill(lines[cellPositionY - 1], 14, cellPositionX - 1, 1);
                                this.lineFill(lines[cellPositionY - 1], 1, cellPositionX, cellSizeX - 1);
                                this.lineFill(lines[cellPositionY - 1], 13, cellPositionX + cellSizeX - 1, 1);
                            }
                            if (needBorderLeft) {
                                this.lineFill(lines[cellPositionY - 1], 15, cellPositionX - 1, 1);
                                for (let index = 0; index < cellSizeY; index++) {
                                    this.lineFill(lines[cellPositionY + index], 2, cellPositionX - 1, 1);
                                }
                                this.lineFill(lines[cellPositionY + cellSizeY], 12, cellPositionX - 1, 1);
                            }
                            if (needBorderRight) {
                                this.lineFill(lines[cellPositionY - 1], 15, cellPositionX + cellSizeX - 1, 1);
                                for (let index = 0; index < cellSizeY; index++) {
                                    this.lineFill(lines[cellPositionY + index], 2, cellPositionX + cellSizeX - 1, 1);
                                }
                                this.lineFill(lines[cellPositionY + cellSizeY], 12, cellPositionX + cellSizeX - 1, 1);
                            }
                            if (needBorderBottom) {
                                this.lineFill(lines[cellPositionY + cellSizeY], 14, cellPositionX - 1, 1);
                                this.lineFill(lines[cellPositionY + cellSizeY], 1, cellPositionX, cellSizeX - 1);
                                this.lineFill(lines[cellPositionY + cellSizeY], 13, cellPositionX + cellSizeX - 1, 1);
                            }
                        }
                    }
                    cellPositionX += cellSizeX;
                }
                cellPositionY += rowHeights[rowIndex - 1];
            }
            if (drawBorder) {
                let isFirstColumnEmpty = true;
                for (let indexLine = 0; indexLine < lines.length; indexLine++) {
                    if (lines[indexLine].length > 0 && lines[indexLine][0] != 32) {
                        isFirstColumnEmpty = false;
                        break;
                    }
                }
                if (isFirstColumnEmpty) {
                    for (let indexLine = 0; indexLine < lines.length; indexLine++) {
                        if (lines[indexLine].length > 0)
                            lines[indexLine].stimulsoft().removeRange(0, 1);
                        if (styles[indexLine].length > 0)
                            styles[indexLine].stimulsoft().removeRange(0, 1);
                    }
                }
            }
            if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                let len = (matrix.coordX.getByIndex(matrix.coordX.countItems - 1) - matrix.coordX.getByIndex(0)) / (insideScaleX / zoomX);
                let offset = Math.max(1, StiMath.trunc(len / 2 - 10));
                sw.writeLine(StiString.fill(' ', offset) + '---=== TRIAL ===---\r\n');
            }
            let lastLine = lines.length - 1;
            while (lastLine > 0 && lines[lastLine].length == 0)
                lastLine--;
            let lastStyleNumber = 0;
            for (let indexLine = 0; indexLine < lines.length; indexLine++) {
                if (lines[indexLine].length > 0) {
                    for (let index = 0; index < this.borderCodes.length; index++) {
                        let borderCode = this.borderCodes[index];
                        let borderChar = this.getBorderChar(index, borderType);
                        for (let indexChar = 0; indexChar < lines[indexLine].length; indexChar++) {
                            if (lines[indexLine][indexChar] == borderCode) {
                                lines[indexLine][indexChar] = borderChar;
                            }
                        }
                    }
                    if (Stimulsoft['StiOptions'].Export.Text.trimTrailingSpaces) {
                    }
                    if (killSpaceGraphLines) {
                        let borderChar = this.getBorderChar(1, borderType);
                        let bb = true;
                        for (let index = 0; index < lines[indexLine].length; index++) {
                            let char = lines[indexLine][index];
                            if (!(char == borderChar || char == 32))
                                bb = false;
                        }
                        if (bb)
                            lines[indexLine] = [];
                    }
                    if (putFeedPageCode && pageBreaks[indexLine]) {
                        if (this.useEscapeCodes)
                            sw.write(this.getEscapeNames(lastStyleNumber, 0).toString());
                        lastStyleNumber = 0;
                        sw.write('');
                    }
                    if (this.useEscapeCodes) {
                    } else {
                    }
                }
                let currLine = lines[indexLine];
                if (!killSpaceLines && indexLine <= lastLine || currLine.length > 0) {
                    let endChar = currLine.length;
                    if (Stimulsoft['StiOptions'].Export.Text.trimTrailingSpaces) {
                        while (endChar > 0 && currLine[endChar - 1] == 32)
                            endChar--;
                    }
                    let res = '';
                    for (let indexSym = 0; indexSym < endChar; indexSym++) {
                        let sym = currLine[indexSym];
                        if (sym >= 65280)
                            sym = sym - 65280;
                        res += String.fromCharCode(sym);
                    }
                    if (Stimulsoft['StiOptions'].Export.Text.removeLastNewLineMarker && indexLine == lastLine)
                        sw.write(res);
                    else
                        sw.writeLine(res);
                }
            }
            let sbb = new StringBuilder();
            if (this.useEscapeCodes)
                sbb.append(this.getEscapeNames(lastStyleNumber, 0));
            if (putFeedPageCode)
                sbb.append('');
            if (sbb.length > 0)
                sw.write(sbb.toString());
            sw.flush();
            if (this.useEscapeCodes) {
            }
            ms.writeTo(stream);
            ms.close();
            this.needVerticalBorders = null;
            this.needHorizontalBorders = null;
            this.styleList = null;
            this.escapeCodesList = null;
        }
    };
    __.b.StiTxtExportService = StiTxtExportService;
    let StiTxtStyleInfo = class {
    };
}
let StiExportService = __.b.StiExportService;
{
    __.b.StiCsvExportService = class extends StiExportService {
        constructor() {
            super(...arguments);
            this.multipleFiles = false;
        }
        implements() {
            return [__.b.IStiCsvExportService];
        }
        get defaultExtension() {
            return 'csv';
        }
        get exportFormat() {
            return __.a.StiExportFormat.Csv;
        }
        get groupCategory() {
            return 'Data';
        }
        get position() {
            return __.b.StiExportPosition.Data;
        }
        get exportNameInMenu() {
            return StiLocalization.get('Export', 'ExportTypeCsvFile');
        }
        exportTo(report, stream, settings) {
            this.exportCsv(report, stream, settings.stimulsoft().as(__.b.StiDataExportSettings));
        }
        exportToAsync(onExport, report, stream, settings) {
            let service = this;
            setTimeout(function () {
                service.exportTo(report, stream, settings);
                onExport();
            });
        }
        get getFilter() {
            return StiLocalization.get('FileFilters', 'CsvFiles');
        }
        exportCsv(report, stream, settings) {
            __.a.StiLogService.write(this.stimulsoft().getType(), 'Export report to Csv format');
            if (settings == null)
                throw new Error("The 'settings' argument cannot be equal in null.");
            let pageRange = settings.pageRange;
            let separator = settings.separator;
            let encoding = settings.encoding;
            let skipColumnHeaders = settings.skipColumnHeaders;
            let mode = settings.dataExportMode;
            if (separator == '\\t')
                separator = '	';
            let pages = pageRange.getSelectedPages(report.renderedPages);
            this.currentPassNumber = 0;
            this.maximumPassNumber = 3;
            let matrix = new __.b.StiMatrix(pages, false, this, null, mode);
            matrix.scanComponentsPlacement(false);
            if (this.isStopped)
                return;
            matrix.prepareDocument(this, mode);
            this.writer = new StreamWriter(stream, encoding);
            if (!skipColumnHeaders) {
                for (let columnIndex = 0; columnIndex < matrix.fields.length; columnIndex++) {
                    let text = matrix.fields[columnIndex].name.stimulsoft().replaceAll('"', '""');
                    if (text.indexOf(separator) != -1 || text.indexOf('"') != -1 || text.indexOf('\n') != -1)
                        text = '"' + text + '"';
                    this.writer.write(text);
                    if (columnIndex < matrix.fields.length - 1) {
                        this.writer.write(separator);
                    }
                }
                this.writer.writeLine('');
            }
            this.currentPassNumber = 2;
            for (let rowIndex = 0; rowIndex < matrix.dataArrayLength; rowIndex++) {
                this.invokeExporting2(rowIndex, matrix.dataArrayLength - 1, this.currentPassNumber, this.maximumPassNumber);
                if (this.isStopped)
                    return;
                for (let columnIndex = 0; columnIndex < matrix.fields.length; columnIndex++) {
                    let text = matrix.fields[columnIndex].dataArray[rowIndex];
                    if (text == null)
                        text = '';
                    if (text != '') {
                        if (text.indexOf(separator) != -1 || text.indexOf('"') != -1 || text.indexOf('\n') != -1) {
                            text = text.stimulsoft().replaceAll('"', '""');
                            text = '"' + text + '"';
                        }
                        this.writer.write(text);
                    }
                    if (columnIndex < matrix.fields.length - 1) {
                        this.writer.write(separator);
                    }
                }
                this.writer.writeLine('');
            }
            this.writer.flush();
            if (matrix != null) {
                matrix.clear();
                matrix = null;
            }
        }
    };
}
{
    __.b.StiDataExportService = class extends __.b.StiExportService {
        constructor() {
            super(...arguments);
            this.multipleFiles = false;
        }
        implements() {
            return [__.b.IStiDataExportService];
        }
        get defaultExtension() {
            if (this.exportSettings.is(__.b.StiDataExportSettings)) {
                let dataType = this.exportSettings.dataType;
                if (dataType == __.b.StiDataType.Dbf)
                    return 'dbf';
                if (dataType == __.b.StiDataType.Dif)
                    return 'dif';
                if (dataType == __.b.StiDataType.Sylk)
                    return 'slk';
                if (dataType == __.b.StiDataType.Xml)
                    return 'xml';
                if (dataType == __.b.StiDataType.Json)
                    return 'json';
            }
            return 'csv';
        }
        get exportFormat() {
            if (this.exportSettings.is(__.b.StiCsvExportSettings))
                return __.a.StiExportFormat.Csv;
            if (this.exportSettings.is(__.b.StiDataExportSettings)) {
                let dataType = this.exportSettings.dataType;
                if (dataType == __.b.StiDataType.Csv)
                    return __.a.StiExportFormat.Csv;
                if (dataType == __.b.StiDataType.Dbf)
                    return __.a.StiExportFormat.Dbf;
                if (dataType == __.b.StiDataType.Dif)
                    return __.a.StiExportFormat.Dif;
                if (dataType == __.b.StiDataType.Sylk)
                    return __.a.StiExportFormat.Sylk;
                if (dataType == __.b.StiDataType.Xml)
                    return __.a.StiExportFormat.Xml;
                if (dataType == __.b.StiDataType.Json)
                    return __.a.StiExportFormat.Json;
            }
            return __.a.StiExportFormat.Data;
        }
        get groupCategory() {
            return 'Data';
        }
        get position() {
            return __.b.StiExportPosition.Data;
        }
        get exportNameInMenu() {
            return StiLocalization.get('Export', 'ExportTypeDataFile');
        }
        exportTo(report, stream, settings) {
            this.exportData(report, stream, settings);
        }
        exportToAsync(onExport, report, stream, settings) {
            let service = this;
            setTimeout(function () {
                service.exportTo(report, stream, settings);
                onExport();
            });
        }
        getFilter() {
            return StiLocalization.get('FileFilters', 'CsvFiles');
        }
        exportData(report, stream, settings) {
            this.exportSettings = settings;
            let csvExportService = new __.b.StiCsvExportService();
            csvExportService.exportCsv(report, stream, settings);
        }
    };
}
let ColorTranslator = Stimulsoft.System.Drawing.ColorTranslator;
{
    __.b.StiHtml5ExportService = class extends __.b.StiExportService {
        constructor() {
            super();
            this.renderAsDocument = true;
            this.multipleFiles = false;
            this.fileName = '';
            this.htmlWriter = null;
            this.imageQuality = 0.75;
            this.imageResolution = 96;
            this.compressToArchive = false;
        }
        implements() {
            return [__.b.IStiHtml5ExportService];
        }
        get defaultExtension() {
            if (this.compressToArchive)
                return 'zip';
            return 'html';
        }
        get exportFormat() {
            return __.a.StiExportFormat.Html5;
        }
        get groupCategory() {
            return 'Web';
        }
        get position() {
            return __.b.StiExportPosition.Html5;
        }
        get exportNameInMenu() {
            return StiLocalization.get('Export', 'ExportTypeHtml5File');
        }
        exportTo(report, writer, settings) {
            this.exportHtml(report, writer, settings);
        }
        exportToAsync(onExport, report, writer, settings) {
            let service = this;
            setTimeout(function () {
                service.exportTo(report, writer, settings);
                onExport();
            });
        }
        getFilter() {
            if (this.compressToArchive)
                return StiLocalization.get('FileFilters', 'ZipArchives');
            return StiLocalization.get('FileFilters', 'HtmlFiles');
        }
        renderPage(report, page, REFclipCounter) {
            let svgString = __.b.StiSvgHelper.saveToString(report, page, false, false, REFclipCounter, this.imageFormat, this.imageQuality, this.imageResolution);
            this.htmlWriter.write(svgString);
            this.htmlWriter.flush();
        }
        renderStartDoc(pages, encoding) {
            this.htmlWriter.write('<!DOCTYPE html>');
            this.htmlWriter.writeLine();
            this.htmlWriter.indent++;
            this.htmlWriter.writeFullBeginTag('head');
            this.htmlWriter.writeLine();
            this.htmlWriter.indent++;
            this.htmlWriter.writeFullBeginTag('title');
            this.htmlWriter.write(this.report.reportAlias);
            this.htmlWriter.writeEndTag('title');
            this.htmlWriter.writeLine();
            this.htmlWriter.writeBeginTag('meta');
            this.htmlWriter.writeAttribute('charset', encoding.webName);
            this.htmlWriter.writeEndTag('meta');
            this.htmlWriter.writeLine();
            this.htmlWriter.indent--;
            this.htmlWriter.writeEndTag('head');
            this.htmlWriter.writeLine();
            this.htmlWriter.writeBeginTag('body');
            this.htmlWriter.writeAttribute('bgcolor', ColorTranslator.toHtml(Color.lightBlue));
            this.htmlWriter.writeAttribute('style', 'text-align:center;');
            this.htmlWriter.write('>');
            this.htmlWriter.indent++;
            this.htmlWriter.writeLine();
        }
        renderEndDoc() {
            this.htmlWriter.indent--;
            this.htmlWriter.writeEndTag('body');
            this.htmlWriter.indent--;
            this.htmlWriter.writeLine();
            this.htmlWriter.writeEndTag('html');
        }
        exportHtml(report, htmlWriter, settings) {
            __.a.StiLogService.write(this.stimulsoft().getType(), 'Export report to Html format');
            if (settings == null)
                throw new Error("The 'settings' argument cannot be equal in null.");
            this.imageFormat = settings.imageFormat;
            this.imageResolution = settings.imageResolution;
            this.imageQuality = settings.imageQuality;
            this.compressToArchive = settings.compressToArchive;
            let continuousPages = settings.continuousPages;
            this.htmlWriter = htmlWriter;
            let pages = settings.pageRange.getSelectedPages(report.renderedPages);
            try {
                this.report = report;
                if (this.renderAsDocument == true)
                    this.renderStartDoc(pages, settings.encoding);
                if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                    let vers = StiString.format('{3}{0}{2}{4}{1}', String.fromCharCode(114), String.fromCharCode(108), String.fromCharCode(105), String.fromCharCode(84), String.fromCharCode(97));
                    htmlWriter.write('<div style="FONT-SIZE: 10px; COLOR: red; FONT-FAMILY: Arial"' + '>' + 'Stimulsoft Reports - ' + vers + ' Version</div>');
                }
                this.htmlWriter.indent = 0;
                let clipCounter = 1;
                for (let page of pages.list) {
                    this.invokeExporting(page, pages, 0, 1);
                    let REFclipCounter = { ref: clipCounter };
                    this.renderPage(report, page, REFclipCounter);
                    clipCounter = REFclipCounter.ref;
                    if (continuousPages) {
                        this.htmlWriter.write('<br/>');
                    }
                    this.htmlWriter.writeLine();
                }
                if (this.renderAsDocument == true)
                    this.renderEndDoc();
                this.htmlWriter.flush();
            } finally {
                report = null;
            }
        }
    };
}
let List = Stimulsoft.System.Collections.List;
let StiDashboardExport = __.a.Dashboard.StiDashboardExport;
let IStiDashboard = __.a.Dashboard.IStiDashboard;
let Size = Stimulsoft.System.Drawing.Size;
let StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
let StiBrush = Stimulsoft.Base.Drawing.StiBrush;
let StiHtmlTagsState = Stimulsoft.Base.Drawing.StiHtmlTagsState;
{
    let StiExcel2007ExportService = class extends __.b.StiExportService {
        constructor() {
            super(...arguments);
            this.matrix = null;
            this.fontList = null;
            this.fillList = null;
            this.borderList = null;
            this.xfList = null;
            this.sstList = null;
            this.sstHash = null;
            this.sstHashIsTags = null;
            this.imageList = null;
            this.formatList = null;
            this.sstCount = 0;
            this.sheetNameList = null;
            this.imageListOffset = 0;
            this.printAreasList = null;
            this.matrixList = null;
            this.firstPageIndexList = null;
            this.hyperlinkList = null;
            this.minRowList = null;
            this.maxRowList = null;
            this.useOnePageHeaderAndFooter = false;
            this.dataExportMode = __.b.StiDataExportMode.AllBands;
            this.exportObjectFormatting = true;
            this.exportEachPageToSheet = false;
            this.exportHorizontalPageBreaks = false;
            this.imageResolution = 1;
            this.imageQuality = 0.75;
            this.imageCache = null;
            this.restrictEditing = __.b.StiExcel2007RestrictEditing.No;
            this.reportCulture = null;
            this.docCompanyString = null;
            this.docLastModifiedString = null;
            this.xmlIndentation = 1;
            this.wrongUrlSymbols = ' "#\'*,;<>[^`{|}';
            this.refChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            this.HiToTwips = 14.4 / 20 * 1.01;
            this.TwipsToColinfo = 2.438 * 0.976 * 0.075;
        }
        implements() {
            return [__.b.IStiExcel2007ExportService];
        }
        get exportFormat() {
            return __.a.StiExportFormat.Excel2007;
        }
        exportTo(report, stream, settings) {
            this.exportExcel(report, stream, settings);
        }
        exportToAsync(onExport, report, stream, settings) {
            setTimeout(() => Stimulsoft.tsfb(this, void 0, void 0, function* () {
                yield __.b.StiExportImageHelper.convertAllImages(report, Stimulsoft.System.Drawing.Imaging.ImageFormat.Jpeg, false, this.exportFormat);
                if (!report.isDocument && report.getCurrentPage().is(IStiDashboard)) {
                    StiDashboardExport.exportAsync(report, stream, settings).try(() => onExport());
                    return;
                }
                this.exportTo(report, stream, settings);
                if (report != null && report.preparedExportImages != null) {
                    report.preparedExportImages.clear();
                    report.preparedExportImages = null;
                }
                onExport();
            }), 0);
        }
        getLineStyle(border) {
            let penStyle = StiPenStyle.None;
            let width = 0;
            let mediumWidth = 1.5;
            let thickWidth = 3;
            if (border != null) {
                penStyle = border.style;
                width = border.size;
            }
            switch (penStyle) {
            case StiPenStyle.Solid:
                if (width > thickWidth)
                    return 'thick';
                if (width > mediumWidth)
                    return 'medium';
                return 'thin';
            case StiPenStyle.Dot:
                if (width > mediumWidth)
                    return 'dotted';
                return 'hair';
            case StiPenStyle.Dash:
                if (width > mediumWidth)
                    return 'mediumDashed';
                return 'dashed';
            case StiPenStyle.DashDot:
                if (width > mediumWidth)
                    return 'mediumDashDot';
                return 'dashDot';
            case StiPenStyle.DashDotDot:
                if (width > mediumWidth)
                    return 'mediumDashDotDot';
                return 'dashDotDot';
            case StiPenStyle.Double:
                return 'double';
            default:
                return null;
            }
        }
        getRefString(column, row) {
            let columnHigh = StiMath.trunc(column / 26);
            let columnLow = StiMath.trunc(column % 26);
            let output = new StringBuilder();
            if (columnHigh > 0) {
                output.append(this.refChars.charAt(columnHigh - 1));
            }
            output.append(this.refChars.charAt(columnLow));
            output.append((row + 1).toString());
            return output.toString();
        }
        getRefAbsoluteString(column, row) {
            let columnHigh = StiMath.trunc(column / 26);
            let columnLow = StiMath.trunc(column % 26);
            let output = new StringBuilder();
            output.append('$');
            if (columnHigh > 0) {
                output.append(this.refChars.charAt(columnHigh - 1));
            }
            output.append(this.refChars.charAt(columnLow));
            output.append('$');
            output.append((row + 1).toString());
            return output.toString();
        }
        floatToString(number_) {
            let output = number_.toString().stimulsoft().replaceAll(',', '.');
            return output;
        }
        stringToUrl(input) {
            let output = new StringBuilder();
            for (let i = 0; i < input.length; i++) {
                let byt = input.charAt(i);
                if (byt == "'") {
                    continue;
                } else {
                    if (byt.charCodeAt(0) < 32 || this.wrongUrlSymbols.indexOf(byt) != -1) {
                        output.append(StiString.format('%{0:x2}', byt.charCodeAt(0)));
                    } else {
                        output.append(byt);
                    }
                }
            }
            return output.toString();
        }
        getFontNumber(dataIn) {
            if (this.fontList.length > 0) {
                for (let index = 0; index < this.fontList.length; index++) {
                    if (this.fontList[index].stimulsoft().equals(dataIn)) {
                        return index;
                    }
                }
            }
            this.fontList.push(dataIn);
            let temp = this.fontList.length - 1;
            return temp;
        }
        getFillNumber(dataIn) {
            if (this.fillList.length > 0) {
                for (let index = 0; index < this.fillList.length; index++) {
                    if (this.fillList[index].stimulsoft().equals(dataIn)) {
                        return index;
                    }
                }
            }
            this.fillList.push(dataIn);
            let temp = this.fillList.length - 1;
            return temp;
        }
        getBorderNumber(dataIn) {
            if (this.borderList.length > 0) {
                for (let index = 0; index < this.borderList.length; index++) {
                    if (this.borderList[index].stimulsoft().equals(dataIn)) {
                        return index;
                    }
                }
            }
            this.borderList.push(dataIn);
            let temp = this.borderList.length - 1;
            return temp;
        }
        getXFNumber(dataIn) {
            if (this.xfList.length > 0) {
                for (let index = 0; index < this.xfList.length; index++) {
                    if (this.xfList[index].equalDataXF(dataIn)) {
                        return index;
                    }
                }
            }
            this.xfList.push(dataIn);
            let temp = this.xfList.length - 1;
            return temp;
        }
        getSSTNumber(dataIn) {
            this.sstCount++;
            if (this.sstList.length > 0) {
                if (this.sstHash.containsKey(dataIn)) {
                    return this.sstHash.get(dataIn);
                }
            }
            this.sstList.push(dataIn);
            let temp = this.sstList.length - 1;
            this.sstHash.add(dataIn, temp);
            return temp;
        }
        getFormatNumber(dataIn) {
            if (this.formatList.length > 0) {
                for (let index = 0; index < this.formatList.length; index++) {
                    if (this.formatList[index] == dataIn) {
                        return index + 164;
                    }
                }
            }
            this.formatList.push(dataIn);
            let temp = this.formatList.length - 1;
            return temp + 164;
        }
        convert(x) {
            return x * this.HiToTwips;
        }
        compareExcellSheetNames(name1, name2) {
            let st1 = name1;
            if (st1 == null || st1.length == 0)
                st1 = '';
            let st2 = name2;
            if (st2 == null || st2.length == 0)
                st2 = '';
            return st1 == st2;
        }
        prepareData() {
            this.fontList = new Array();
            this.fillList = new Array();
            this.borderList = new Array();
            this.xfList = new Array();
            this.sstList = [];
            this.sstHash = new Hashtable();
            this.sstHashIsTags = new Hashtable();
            this.imageList = [];
            this.formatList = [];
            this.sheetNameList = [];
            this.sstCount = 0;
            this.printAreasList = [];
            this.matrixList = [];
            this.firstPageIndexList = [];
            this.minRowList = [];
            this.maxRowList = [];
            this.imageCache = new __.a.StiImageCache(Stimulsoft['StiOptions'].Export.Excel.AllowImageComparer, true, __.a.ImageFormat.Jpeg, this.imageQuality, false);
            let tempFont = new DataFont('Arial', false, false, false, false, 10, Color.black, 1, 0);
            this.getFontNumber(tempFont);
            let tempFill = new DataFill('none', Color.transparent, Color.black);
            this.getFillNumber(tempFill);
            tempFill = new DataFill('gray125', Color.transparent, Color.black);
            this.getFillNumber(tempFill);
            let tempBorder = new DataBorder(null, null, null, null);
            this.getBorderNumber(tempBorder);
            let tempXF = new DataXF(0, 0, 0, 0, 0, StiTextHorAlignment.Left, StiVertAlignment.Bottom, 0, false, false, false);
            this.getXFNumber(tempXF);
        }
        writeContentTypes() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('Types');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/content-types');
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'rels');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-package.relationships+xml');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'xml');
            writer.writeAttributeString('ContentType', 'application/xml');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'jpeg');
            writer.writeAttributeString('ContentType', 'image/jpeg');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'png');
            writer.writeAttributeString('ContentType', 'image/png');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'vml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.vmlDrawing');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/docProps/app.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.extended-properties+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/docProps/core.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-package.core-properties+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/xl/workbook.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml');
            writer.writeEndElement();
            for (let index = 0; index < this.sheetNameList.length; index++) {
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', StiString.format('/xl/worksheets/sheet{0}.xml', index + 1));
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml');
                writer.writeEndElement();
            }
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/xl/styles.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml');
            writer.writeEndElement();
            for (let index = 0; index < this.sheetNameList.length; index++) {
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', StiString.format('/xl/drawings/drawing{0}.xml', index + 1));
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.drawing+xml');
                writer.writeEndElement();
            }
            if (this.sstList.length > 0) {
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', '/xl/sharedStrings.xml');
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml');
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeMainRels() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId1');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument');
            writer.writeAttributeString('Target', 'xl/workbook.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId2');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties');
            writer.writeAttributeString('Target', 'docProps/core.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId3');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties');
            writer.writeAttributeString('Target', 'docProps/app.xml');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeDocPropsApp() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('Properties');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties');
            writer.writeAttributeString('xmlns:vt', 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes');
            writer.writeElementString('Application', 'Microsoft Excel');
            writer.writeElementString('DocSecurity', '0');
            writer.writeElementString('ScaleCrop', 'false');
            writer.writeElementString('Company', this.docCompanyString == null ? '' : this.docCompanyString);
            writer.writeElementString('LinksUpToDate', 'false');
            writer.writeElementString('SharedDoc', 'false');
            writer.writeElementString('HyperlinksChanged', 'false');
            writer.writeElementString('AppVersion', '12.0000');
            writer.writeStartElement('HeadingPairs');
            writer.writeStartElement('vt:vector');
            writer.writeAttributeString('size', '4');
            writer.writeAttributeString('baseType', 'variant');
            writer.writeStartElement('vt:variant');
            writer.writeElementString('vt:lpstr', 'Worksheets');
            writer.writeEndElement();
            writer.writeStartElement('vt:variant');
            writer.writeElementString('vt:i4', StiString.format('{0}', this.sheetNameList.length));
            writer.writeEndElement();
            writer.writeStartElement('vt:variant');
            writer.writeElementString('vt:lpstr', 'Named Ranges');
            writer.writeEndElement();
            writer.writeStartElement('vt:variant');
            writer.writeElementString('vt:i4', StiString.format('{0}', this.sheetNameList.length));
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('TitlesOfParts');
            writer.writeStartElement('vt:vector');
            writer.writeAttributeString('size', StiString.format('{0}', this.sheetNameList.length * 2));
            writer.writeAttributeString('baseType', 'lpstr');
            for (let index = 0; index < this.sheetNameList.length; index++) {
                writer.writeElementString('vt:lpstr', this.sheetNameList[index]);
            }
            for (let index = 0; index < this.sheetNameList.length; index++) {
                writer.writeElementString('vt:lpstr', StiString.format("'{0}'!Print_Area", this.sheetNameList[index]));
            }
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeDocPropsCore() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('cp:coreProperties');
            writer.writeAttributeString('xmlns:cp', 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeAttributeString('xmlns:dcterms', 'http://purl.org/dc/terms/');
            writer.writeAttributeString('xmlns:dcmitype', 'http://purl.org/dc/dcmitype/');
            writer.writeAttributeString('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
            let dateTime = StiString.format('{0}{1}', DateTime.now.toString('yyyy-MM-dd'), DateTime.now.toString('THH:mm:ssZ'));
            writer.writeElementString('dc:title', this.report.reportName == null ? '' : this.report.reportName);
            writer.writeElementString('dc:subject', this.report.reportAlias == null ? '' : this.report.reportAlias);
            writer.writeElementString('dc:creator', this.report.reportAuthor == null ? '' : this.report.reportAuthor);
            writer.writeElementString('dc:description', this.report.reportDescription == null ? '' : this.report.reportDescription);
            writer.writeElementString('cp:lastModifiedBy', this.docLastModifiedString == null ? '' : this.docLastModifiedString);
            writer.writeStartElement('dcterms:created');
            writer.writeAttributeString('xsi:type', 'dcterms:W3CDTF');
            writer.writeString(dateTime);
            writer.writeEndElement();
            writer.writeStartElement('dcterms:modified');
            writer.writeAttributeString('xsi:type', 'dcterms:W3CDTF');
            writer.writeString(dateTime);
            writer.writeEndElement();
            writer.writeElementString('cp:contentStatus', Stimulsoft.StiVersion.platform());
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeWorkbookRels() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            for (let index = 0; index < this.sheetNameList.length; index++) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', index + 1));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet');
                writer.writeAttributeString('Target', StiString.format('worksheets/sheet{0}.xml', index + 1));
                writer.writeEndElement();
            }
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', StiString.format('rId{0}', this.sheetNameList.length + 2));
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles');
            writer.writeAttributeString('Target', 'styles.xml');
            writer.writeEndElement();
            if (this.sstCount > 0) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', this.sheetNameList.length + 3));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings');
                writer.writeAttributeString('Target', 'sharedStrings.xml');
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeWorkbook() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('workbook');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeStartElement('fileVersion');
            writer.writeAttributeString('appName', 'xl');
            writer.writeAttributeString('lastEdited', '4');
            writer.writeAttributeString('lowestEdited', '4');
            writer.writeAttributeString('rupBuild', '4505');
            writer.writeEndElement();
            writer.writeStartElement('workbookPr');
            writer.writeAttributeString('defaultThemeVersion', '124226');
            writer.writeEndElement();
            writer.writeStartElement('bookViews');
            writer.writeStartElement('workbookView');
            writer.writeAttributeString('xWindow', '120');
            writer.writeAttributeString('yWindow', '15');
            writer.writeAttributeString('windowWidth', '18975');
            writer.writeAttributeString('windowHeight', '11955');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('sheets');
            for (let index = 0; index < this.sheetNameList.length; index++) {
                writer.writeStartElement('sheet');
                writer.writeAttributeString('name', this.sheetNameList[index]);
                writer.writeAttributeString('sheetId', StiString.format('{0}', index + 1));
                writer.writeAttributeString('r:id', StiString.format('rId{0}', index + 1));
                writer.writeEndElement();
            }
            writer.writeEndElement();
            writer.writeStartElement('definedNames');
            for (let index = 0; index < this.sheetNameList.length; index++) {
                let area = this.printAreasList[index];
                if (area.height > 1048575)
                    area.height = 1048575;
                if (area.width > 16383)
                    area.width = 16383;
                let sref = this.getRefAbsoluteString(area.width, area.height);
                writer.writeStartElement('definedName');
                writer.writeAttributeString('name', '_xlnm.Print_Area');
                writer.writeAttributeString('localSheetId', StiString.format('{0}', index));
                writer.writeString(StiString.format("'{0}'!$A$1:{1}", this.sheetNameList[index], sref));
                writer.writeEndElement();
            }
            writer.writeEndElement();
            writer.writeStartElement('calcPr');
            writer.writeAttributeString('calcId', '124519');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeSheetRels(indexSheet) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            if (this.imageList.length - this.imageListOffset > 0) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', 1));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing');
                writer.writeAttributeString('Target', StiString.format('../drawings/drawing{0}.xml', indexSheet + 1));
                writer.writeEndElement();
            }
            if (this.hyperlinkList.length > 0) {
                for (let index = 0; index < this.hyperlinkList.length; index++) {
                    writer.writeStartElement('Relationship');
                    writer.writeAttributeString('Id', StiString.format('rId{0}', 2 + index));
                    writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink');
                    writer.writeAttributeString('Target', this.hyperlinkList[index]);
                    writer.writeAttributeString('TargetMode', 'External');
                    writer.writeEndElement();
                }
            }
            if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', 'dId1');
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing');
                writer.writeAttributeString('Target', '../drawings/vmlDrawingAdditional.vml');
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeSheet(indexSheet, page) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('worksheet');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            if (Stimulsoft['StiOptions'].Export.Excel.FitToOnePageWide) {
                writer.writeStartElement('sheetPr');
                writer.writeStartElement('pageSetUpPr');
                writer.writeAttributeString('fitToPage', '1');
                writer.writeEndElement();
                writer.writeEndElement();
            }
            this.matrix = this.matrixList[indexSheet];
            let minRowIndex = this.minRowList[indexSheet];
            let maxRowIndex = this.maxRowList[indexSheet];
            let coordXcountItems = this.matrix.coordX.countItems;
            let printAreaSize = new Size(coordXcountItems - 2, maxRowIndex - minRowIndex - 1);
            if (printAreaSize.width < 0)
                printAreaSize.width = 0;
            if (printAreaSize.height < 0)
                printAreaSize.height = 0;
            this.printAreasList.push(printAreaSize);
            let numberStoredAsText = [];
            writer.writeStartElement('dimension');
            writer.writeAttributeString('ref', StiString.format('{0}:{1}', this.getRefString(0, 0), this.getRefString(printAreaSize.width, printAreaSize.height)));
            writer.writeEndElement();
            let paneX = 0;
            let paneY = 0;
            if (Stimulsoft['StiOptions'].Export.Excel.AllowFreezePanes) {
                for (let indexRow = minRowIndex; indexRow < maxRowIndex; indexRow++) {
                    for (let indexColumn = 0; indexColumn < coordXcountItems - 1; indexColumn++) {
                        let cell = this.matrix.cells[indexRow][indexColumn];
                        if (cell != null && cell.component != null && (cell.component.locked || cell.component.tagValue != null && cell.component.tagValue.toString().contains('excelfreezepanes'))) {
                            let stPlacement = cell.component.componentPlacement;
                            if (stPlacement != null && stPlacement.length > 0 && (stPlacement.stimulsoft().startsWith('rt') || stPlacement.stimulsoft().startsWith('ph') || stPlacement.stimulsoft().startsWith('h'))) {
                                paneX = cell.left;
                                paneY = cell.top + cell.height + 1;
                                break;
                            }
                        }
                    }
                }
            }
            writer.writeStartElement('sheetViews');
            writer.writeStartElement('sheetView');
            if (Stimulsoft['StiOptions'].Export.Excel.ColumnsRightToLeft) {
                writer.writeAttributeString('rightToLeft', '1');
            }
            if (!Stimulsoft['StiOptions'].Export.Excel.ShowGridLines) {
                writer.writeAttributeString('showGridLines', '0');
            }
            writer.writeAttributeString('tabSelected', '1');
            writer.writeAttributeString('workbookViewId', '0');
            if (paneX == 0 && paneY == 0) {
                writer.writeStartElement('selection');
                writer.writeAttributeString('activeCell', 'A1');
                writer.writeAttributeString('sqref', 'A1');
                writer.writeEndElement();
            } else {
                if (paneX == 0) {
                    writer.writeStartElement('pane');
                    writer.writeAttributeString('ySplit', paneY.toString());
                    writer.writeAttributeString('topLeftCell', this.getRefString(paneX, paneY));
                    writer.writeAttributeString('activePane', 'bottomLeft');
                    writer.writeAttributeString('state', 'frozen');
                    writer.writeEndElement();
                    writer.writeStartElement('selection');
                    writer.writeAttributeString('pane', 'bottomLeft');
                    writer.writeAttributeString('activeCell', this.getRefString(0, paneY));
                    writer.writeAttributeString('sqref', this.getRefString(0, paneY));
                    writer.writeEndElement();
                } else {
                    writer.writeStartElement('pane');
                    writer.writeAttributeString('xSplit', paneX.toString());
                    writer.writeAttributeString('ySplit', paneY.toString());
                    writer.writeAttributeString('topLeftCell', this.getRefString(paneX, paneY));
                    writer.writeAttributeString('activePane', 'bottomRight');
                    writer.writeAttributeString('state', 'frozen');
                    writer.writeEndElement();
                    writer.writeStartElement('selection');
                    writer.writeAttributeString('pane', 'topRight');
                    writer.writeAttributeString('activeCell', this.getRefString(paneX, 0));
                    writer.writeAttributeString('sqref', this.getRefString(paneX, 0));
                    writer.writeEndElement();
                    writer.writeStartElement('selection');
                    writer.writeAttributeString('pane', 'bottomLeft');
                    writer.writeAttributeString('activeCell', this.getRefString(0, paneY));
                    writer.writeAttributeString('sqref', this.getRefString(0, paneY));
                    writer.writeEndElement();
                    writer.writeStartElement('selection');
                    writer.writeAttributeString('pane', 'bottomRight');
                    writer.writeAttributeString('activeCell', this.getRefString(paneX, paneY));
                    writer.writeAttributeString('sqref', this.getRefString(paneX, paneY));
                    writer.writeEndElement();
                }
            }
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('sheetFormatPr');
            writer.writeAttributeString('defaultRowHeight', StiString.format('{0}', 15));
            writer.writeEndElement();
            let backgroundStyle = 0;
            let backgroundColor = StiBrush.toColor(page.brush);
            if (!(backgroundColor.equals(Color.white) || backgroundColor.a == 0)) {
                let tempFill = new DataFill('solid', backgroundColor, Color.transparent);
                let fillIndex = this.getFillNumber(tempFill);
                let tempXF = new DataXF(0, 0, fillIndex, 0, 0, StiTextHorAlignment.Left, StiVertAlignment.Bottom, 0, false, false, false);
                backgroundStyle = this.getXFNumber(tempXF);
            }
            let coordXKey = this.matrix.coordX.getKeys();
            let coordYKey = this.matrix.coordY.getKeys();
            if (this.exportObjectFormatting && coordXcountItems > 1) {
                writer.writeStartElement('cols');
                for (let indexCol = 0; indexCol < coordXcountItems - 1; indexCol++) {
                    let value2 = this.matrix.coordX.getByIndex(indexCol + 1, coordXKey);
                    let value1 = this.matrix.coordX.getByIndex(indexCol, coordXKey);
                    let colWidth = this.convert(value2 - value1) * this.TwipsToColinfo;
                    writer.writeStartElement('col');
                    writer.writeAttributeString('min', StiString.format('{0}', indexCol + 1));
                    writer.writeAttributeString('max', StiString.format('{0}', indexCol + 1));
                    writer.writeAttributeString('width', StiString.format('{0}', colWidth));
                    writer.writeAttributeString('customWidth', '1');
                    if (backgroundStyle > 0) {
                        writer.writeAttributeString('style', backgroundStyle.toString());
                    }
                    writer.writeEndElement();
                }
                if (backgroundStyle > 0) {
                    writer.writeStartElement('col');
                    writer.writeAttributeString('min', StiString.format('{0}', coordXcountItems));
                    writer.writeAttributeString('max', StiString.format('{0}', 16384));
                    writer.writeAttributeString('width', '8.7265625');
                    writer.writeAttributeString('style', backgroundStyle.toString());
                    writer.writeEndElement();
                }
                writer.writeEndElement();
            }
            let readyCells = StiArray.create2(Boolean, maxRowIndex + 1, coordXcountItems);
            let mergedCellsStyle = StiArray.create2(Number, maxRowIndex + 1, coordXcountItems);
            let mergedCells = [];
            let hlinks = [];
            writer.writeStartElement('sheetData');
            for (let indexRow = minRowIndex; indexRow < maxRowIndex; indexRow++) {
                let height = this.matrix.coordY.getByIndex(indexRow + 1, coordYKey) - this.matrix.coordY.getByIndex(indexRow, coordYKey);
                writer.writeStartElement('row');
                writer.writeAttributeString('r', StiString.format('{0}', indexRow + 1 - minRowIndex));
                writer.writeAttributeString('spans', StiString.format('{0}:{1}', 1, coordXcountItems - 1));
                if (this.exportObjectFormatting) {
                    writer.writeAttributeString('ht', StiString.format('{0}', this.convert(height)));
                    writer.writeAttributeString('customHeight', '1');
                }
                for (let indexColumn = 0; indexColumn < coordXcountItems - 1; indexColumn++) {
                    let cell = this.matrix.cells[indexRow][indexColumn];
                    if (readyCells[indexRow] && readyCells[indexRow][indexColumn] == false && cell != null) {
                        readyCells[indexRow][indexColumn] = true;
                        let textComp = cell.component.stimulsoft().as(StiText);
                        let str = cell.text;
                        let checkComp = cell.component.stimulsoft().as(StiCheckBox);
                        let hasCheckBoxExcelDataValue = false;
                        let isCheckBox = false;
                        if (checkComp != null && checkComp.excelDataValue != null && checkComp.excelDataValue.length > 0) {
                            hasCheckBoxExcelDataValue = true;
                            str = checkComp.excelDataValue;
                        }
                        let hyperlink = null;
                        if (cell.component.hyperlinkValue != null) {
                            hyperlink = cell.component.hyperlinkValue.toString().trim();
                            if (hyperlink.length > 0 && !hyperlink.stimulsoft().startsWith('javascript:')) {
                                let description = str;
                                if (description == null || description.length == 0)
                                    description = hyperlink;
                                let range = new CellRangeAddress(indexRow - minRowIndex, indexRow - minRowIndex + cell.height, indexColumn, indexColumn + cell.width);
                                let hl = new HlinkData(range, description, hyperlink);
                                hlinks.push(hl);
                            }
                        }
                        let isProcessed = false;
                        let isBarCode = false;
                        if (isBarCode) {
                            isProcessed = true;
                        }
                        let isImage = false;
                        let exportImage = cell.component.stimulsoft().as(IStiExportImageExtended);
                        if (!isProcessed && !isCheckBox && exportImage != null) {
                            let image = null;
                            if (cell.component.isExportAsImage(__.a.StiExportFormat.Excel2007)) {
                                let REFrsImageResolution = { ref: this.imageResolution };
                                image = exportImage.getImage(REFrsImageResolution, __.a.StiExportFormat.Excel);
                            }
                            if (image != null) {
                                let img = this.matrix.getRealImageData(cell, image);
                                if (img != null)
                                    image = img;
                                let imageIndex = this.imageCache.addImageIntRaw(image, image.imageFormat);
                                let imageData = new ExcelImageData(indexRow - minRowIndex, 0, indexColumn, 0, indexRow - minRowIndex + 1 + cell.height, 0, indexColumn + 1 + cell.width, 0, imageIndex, hyperlink);
                                this.imageList.push(imageData);
                                isImage = true;
                                isProcessed = true;
                            }
                        }
                        let isExcelText = false;
                        if (cell.component != null && cell.component.tagValue != null) {
                            let cellTag = cell.component.tagValue.toString().toLowerCase();
                            if (cellTag.indexOf('exceltext') != -1) {
                                isExcelText = true;
                                numberStoredAsText.push(this.getRefString(indexColumn, indexRow));
                            }
                        }
                        let inputFormat = '';
                        if (textComp != null)
                            inputFormat = textComp.format;
                        let isFormatCurrency = false;
                        let isFormatNumeric = false;
                        let isFormatPercent = false;
                        let isFormatDate = false;
                        let isFormatTime = false;
                        let isFormatCustom = false;
                        let isDefaultFormat = false;
                        let outputFormat = '';
                        let decimalDigits = 2;
                        let groupDigits = 0;
                        let currencySymbol = this.reportCulture.numberFormat.currencySymbol;
                        let currencyPositionBefore = this.reportCulture.numberFormat.currencyPositivePattern == 0 || this.reportCulture.numberFormat.currencyPositivePattern == 2;
                        let negativeBraces = false;
                        let hideZeros = textComp != null && textComp.hideZeros;
                        let positivePatternString = null;
                        let negativePatternString = null;
                        let posPatternDelimiter = inputFormat.indexOf('|');
                        if (posPatternDelimiter != -1) {
                            positivePatternString = __.b.StiExportUtils.getPositivePattern(inputFormat.charCodeAt(posPatternDelimiter + 1) - 65);
                            negativePatternString = __.b.StiExportUtils.getNegativePattern(inputFormat.charCodeAt(posPatternDelimiter + 2) - 65);
                            inputFormat = inputFormat.substr(0, posPatternDelimiter);
                        }
                        if (inputFormat != null && inputFormat.length > 0) {
                            if (inputFormat[0] == 'C') {
                                isFormatCurrency = true;
                            } else if (inputFormat[0] == 'N') {
                                isFormatNumeric = true;
                            } else if (inputFormat[0] == 'P') {
                                isFormatPercent = true;
                            } else if (inputFormat[0] == 'D') {
                                isFormatDate = true;
                            } else if (inputFormat[0] == 'T') {
                                isFormatTime = true;
                            } else if (inputFormat[0] == 'U') {
                                isFormatCustom = true;
                            }
                            if (inputFormat.length == 1) {
                                isDefaultFormat = true;
                            } else {
                                if (isFormatCurrency || isFormatNumeric || isFormatPercent) {
                                    let indexPos = 1;
                                    if (Char.isDigit(inputFormat[indexPos])) {
                                        let decimalSB = new StringBuilder();
                                        while (indexPos < inputFormat.length && Char.isDigit(inputFormat[indexPos])) {
                                            decimalSB.append(inputFormat[indexPos]);
                                            indexPos++;
                                        }
                                        decimalDigits = parseInt(decimalSB.toString());
                                    }
                                    if (indexPos < inputFormat.length && inputFormat[indexPos] == 'G') {
                                        indexPos++;
                                        groupDigits = 3;
                                    }
                                    if (indexPos < inputFormat.length && inputFormat[indexPos] == '(') {
                                        indexPos++;
                                        negativeBraces = true;
                                    }
                                    if (indexPos < inputFormat.length && (inputFormat[indexPos] == '.' || inputFormat[indexPos] == ',')) {
                                        indexPos++;
                                    }
                                    if (indexPos < inputFormat.length && (inputFormat[indexPos] == '+' || inputFormat[indexPos] == '-')) {
                                        if (inputFormat[indexPos] == '+')
                                            currencyPositionBefore = true;
                                        indexPos++;
                                        if (indexPos < inputFormat.length) {
                                            currencySymbol = inputFormat.substring(indexPos);
                                        } else {
                                            currencySymbol = '';
                                        }
                                    }
                                }
                            }
                        }
                        if (!(isFormatCurrency || isFormatNumeric || isFormatPercent || isFormatDate || isFormatTime)) {
                            isDefaultFormat = true;
                        }
                        if (isFormatCurrency && isDefaultFormat)
                            isDefaultFormat = false;
                        if (hideZeros && !StiString.isNullOrEmpty(inputFormat)) {
                            if (isDefaultFormat && isFormatNumeric)
                                groupDigits = 3;
                            isDefaultFormat = false;
                        }
                        if (isExcelText)
                            isDefaultFormat = true;
                        if (!isDefaultFormat) {
                            if (posPatternDelimiter != -1) {
                                let outputSB = new StringBuilder();
                                if (groupDigits > 1) {
                                    outputSB.append('#,');
                                    outputSB.appendCount('#', groupDigits - 1);
                                }
                                outputSB.append('0');
                                if (decimalDigits > 0) {
                                    outputSB.append('.');
                                    outputSB.appendCount('0', decimalDigits);
                                }
                                let nn = outputSB.toString();
                                let positivePattern = positivePatternString.stimulsoft().replaceAll('n', nn).stimulsoft().replaceAll('$', '"' + currencySymbol + '"');
                                let negativePattern = negativePatternString.stimulsoft().replaceAll('n', nn).stimulsoft().replaceAll('$', '"' + currencySymbol + '"');
                                outputFormat = positivePattern + ';' + negativePattern + (hideZeros ? ';' : '');
                            } else {
                                let outputSB = new StringBuilder();
                                if (isFormatCurrency && currencyPositionBefore == true) {
                                    outputSB.append('"');
                                    outputSB.append(currencySymbol);
                                    outputSB.append('"');
                                }
                                if (groupDigits > 1) {
                                    outputSB.append('#,');
                                    outputSB.appendCount('#', groupDigits - 1);
                                }
                                outputSB.append('0');
                                if (decimalDigits > 0) {
                                    outputSB.append('.');
                                    outputSB.appendCount('0', decimalDigits);
                                }
                                if (isFormatCurrency && currencyPositionBefore == false) {
                                    outputSB.append('"');
                                    outputSB.append(currencySymbol);
                                    outputSB.append('"');
                                }
                                if (isFormatPercent) {
                                    outputSB.append('%');
                                }
                                outputFormat = outputSB.toString();
                                let negativePattern = (negativeBraces ? '(' : '-') + outputFormat + (negativeBraces ? ')' : '');
                                if (hideZeros) {
                                    outputFormat = outputFormat + ';' + negativePattern + ';';
                                } else {
                                    if (negativeBraces)
                                        outputFormat = outputFormat + ';' + negativePattern;
                                }
                            }
                        }
                        let formatIndex = 0;
                        if (isDefaultFormat) {
                            if (isFormatNumeric) {
                                formatIndex = 4;
                            }
                            if (isFormatPercent) {
                                formatIndex = 10;
                            }
                            if (isFormatDate) {
                                formatIndex = 14;
                            }
                            if (isFormatTime) {
                                formatIndex = 21;
                            }
                            if (isExcelText) {
                                formatIndex = 49;
                            }
                        } else {
                            formatIndex = this.getFormatNumber(outputFormat);
                        }
                        let indexStyle = backgroundStyle;
                        if (this.exportObjectFormatting) {
                            let style = cell.cellStyle;
                            let tempFont = new DataFont(style.font.name, style.font.bold, style.font.italic, style.font.underline, style.font.strikeout, Math.round(style.font.sizeInPoints), style.textColor, 1, 0);
                            if (hasCheckBoxExcelDataValue) {
                                tempFont = new DataFont(Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.name, Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.bold, Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.italic, Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.underline, Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.strikeout, Math.round(Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.Font.sizeInPoints), style.textColor, 1, 0);
                            }
                            let tempFill = new DataFill('solid', style.color, style.color);
                            if (isImage) {
                                tempFill = new DataFill('solid', Color.transparent, Color.transparent);
                            }
                            let needBorderLeft = true;
                            let needBorderRight = true;
                            for (let index = 0; index < cell.height + 1; index++) {
                                if (this.matrix.bordersY[cell.top + index][cell.left] == null)
                                    needBorderLeft = false;
                                if (this.matrix.bordersY[cell.top + index][cell.left + cell.width + 1] == null)
                                    needBorderRight = false;
                            }
                            let needBorderTop = true;
                            let needBorderBottom = true;
                            for (let index = 0; index < cell.width + 1; index++) {
                                if (this.matrix.bordersX[cell.top][cell.left + index] == null)
                                    needBorderTop = false;
                                if (this.matrix.bordersX[cell.top + cell.height + 1][cell.left + index] == null)
                                    needBorderBottom = false;
                            }
                            let tempBorder = new DataBorder(needBorderLeft ? this.matrix.bordersY[cell.top][cell.left] : null, needBorderRight ? this.matrix.bordersY[cell.top][cell.left + cell.width + 1] : null, needBorderTop ? this.matrix.bordersX[cell.top][cell.left] : null, needBorderBottom ? this.matrix.bordersX[cell.top + cell.height + 1][cell.left] : null);
                            let rightToLeft = false;
                            if (style.textOptions != null) {
                                rightToLeft = style.textOptions.rightToLeft;
                            }
                            let textWordWrap = false;
                            if (style.textOptions != null)
                                textWordWrap = style.textOptions.wordWrap;
                            if (!StiString.isNullOrEmpty(str)) {
                                if (str.indexOf('\r') != -1 || str.indexOf('\n') != -1)
                                    textWordWrap = true;
                                if (textComp != null && textComp.checkAllowHtmlTags() && (str.indexOf('<br') != -1 || str.indexOf('<ul') != -1 || str.indexOf('<ol') != -1 || str.indexOf('<p') != -1))
                                    textWordWrap = true;
                            }
                            let rotationAngle = 0;
                            if (style.textOptions != null) {
                                let tempAngle = Math.ceil(style.textOptions.angle);
                                if (tempAngle >= 0 && tempAngle <= 90) {
                                    rotationAngle = tempAngle;
                                }
                                if (tempAngle >= 270 && tempAngle < 360) {
                                    rotationAngle = 360 - tempAngle + 90;
                                }
                            }
                            let editable = this.restrictEditing == __.b.StiExcel2007RestrictEditing.ExceptEditableFields && cell.component != null && cell.component.is(StiText) && cell.component.as(StiText).editable;
                            let tempXF = new DataXF(formatIndex, this.getFontNumber(tempFont), this.getFillNumber(tempFill), this.getBorderNumber(tempBorder), 0, hasCheckBoxExcelDataValue ? Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.HorAlignment : style.horAlignment, hasCheckBoxExcelDataValue ? Stimulsoft['StiOptions'].Export.CheckBoxReplacementForExcelValue.VertAlignment : style.vertAlignment, rotationAngle, textWordWrap, rightToLeft, editable);
                            indexStyle = this.getXFNumber(tempXF);
                        }
                        writer.writeStartElement('c');
                        writer.writeAttributeString('r', this.getRefString(indexColumn, indexRow - minRowIndex));
                        writer.writeAttributeString('s', indexStyle.toString());
                        if (this.exportObjectFormatting) {
                            for (let xx = 0; xx <= cell.width; xx++) {
                                for (let yy = 0; yy <= cell.height; yy++) {
                                    readyCells[indexRow + yy][indexColumn + xx] = true;
                                    mergedCellsStyle[indexRow + yy][indexColumn + xx] = indexStyle;
                                }
                            }
                            if (cell.width > 0 || cell.height > 0) {
                                let tempCellRange = new CellRangeAddress(indexRow - minRowIndex, indexRow - minRowIndex + cell.height, indexColumn, indexColumn + cell.width);
                                mergedCells.push(tempCellRange);
                            }
                        } else {
                            readyCells[indexRow][indexColumn] = true;
                            mergedCellsStyle[indexRow][indexColumn] = indexStyle;
                        }
                        let excelDataValue = null;
                        if (textComp != null) {
                            excelDataValue = textComp.excelDataValue;
                            if (isFormatNumeric && excelDataValue == '' && str == ' ') {
                                str = '';
                            }
                        }
                        if (!isProcessed && (!StiString.isNullOrEmpty(str) || !StiString.isNullOrEmpty(excelDataValue))) {
                            let isFormula = false;
                            let isNumber = false;
                            let number_ = 0;
                            if (!StiString.isNullOrEmpty(excelDataValue) && excelDataValue != '-') {
                                let value = textComp.excelDataValue;
                                let value3 = value;
                                let posDot = value3.indexOf('.');
                                let posComma = value3.indexOf(',');
                                if (posDot != -1 && posComma != -1) {
                                    value3 = value3.stimulsoft().replaceAll(posDot > posComma ? ',' : '.', '');
                                }
                                value3 = value3.trim().stimulsoft().replaceAll(',', '.');
                                if (!StiString.isNullOrEmpty(value3) && this.checkForNumber(value3)) {
                                    isNumber = true;
                                    try {
                                        if (isFormatDate || isFormatTime) {
                                            isNumber = false;
                                        } else {
                                            number_ = parseFloat(value3);
                                            if (isNaN(number_)) {
                                                isNumber = false;
                                                number_ = 0;
                                            }
                                        }
                                    } catch (e) {
                                        Stimulsoft.System.StiError.showError(e, false);
                                        isNumber = false;
                                    }
                                }
                                if (isFormatCustom)
                                    isNumber = false;
                                if (value != str && value.stimulsoft().startsWith('=')) {
                                    isFormula = true;
                                }
                                if (!isNumber && str == null) {
                                    str = value;
                                }
                            }
                            if (isFormula) {
                                let strs = textComp.excelDataValue.stimulsoft().replaceAll('\r', '').stimulsoft().replaceAll('	', ' ').substring(1);
                                if (Stimulsoft['StiOptions'].Export.Excel.TrimTrailingSpaces)
                                    strs = __.b.StiExportUtils.trimEndWhiteSpace(strs);
                                writer.writeElementString('f', strs);
                            } else {
                                if (isNumber == true) {
                                    writer.writeElementString('v', number_.toString().stimulsoft().replaceAll(',', '.'));
                                } else {
                                    let strs = str.stimulsoft().replaceAll('\r', '').stimulsoft().replaceAll('	', ' ');
                                    if (Stimulsoft['StiOptions'].Export.Excel.TrimTrailingSpaces)
                                        strs = __.b.StiExportUtils.trimEndWhiteSpace(strs);
                                    let indexSST = 0;
                                    if (textComp != null && textComp.checkAllowHtmlTags()) {
                                        strs = this.convertAllowHtmlTagsToExcelString(textComp, strs);
                                        indexSST = this.getSSTNumber(strs);
                                        this.sstHashIsTags.add(indexSST, null);
                                    } else {
                                        indexSST = this.getSSTNumber(strs);
                                    }
                                    writer.writeAttributeString('t', 's');
                                    writer.writeElementString('v', indexSST.toString());
                                }
                            }
                        }
                        writer.writeEndElement();
                    } else {
                        let indexStyle = 0;
                        if (readyCells[indexRow][indexColumn]) {
                            indexStyle = mergedCellsStyle[indexRow][indexColumn];
                        }
                        let needBorderLeft = this.matrix.bordersY[indexRow + 0][indexColumn + 0] != null;
                        let needBorderRight = this.matrix.bordersY[indexRow + 0][indexColumn + 1] != null;
                        let needBorderTop = this.matrix.bordersX[indexRow + 0][indexColumn + 0] != null;
                        let needBorderBottom;
                        try {
                            needBorderBottom = this.matrix.bordersX[indexRow + 1][indexColumn + 0] != null;
                        } catch (e) {
                            Stimulsoft.System.StiError.showError(e, false);
                        }
                        if (needBorderLeft || needBorderRight || needBorderTop || needBorderBottom || indexStyle != 0) {
                            let tempBorder = new DataBorder(needBorderLeft ? this.matrix.bordersY[indexRow + 0][indexColumn + 0] : null, needBorderRight ? this.matrix.bordersY[indexRow + 0][indexColumn + 1] : null, needBorderTop ? this.matrix.bordersX[indexRow + 0][indexColumn + 0] : null, needBorderBottom ? this.matrix.bordersX[indexRow + 1][indexColumn + 0] : null);
                            let parentXF = this.xfList[indexStyle];
                            let tempXF = new DataXF(parentXF.FormatIndex, parentXF.FontIndex, parentXF.FillIndex, this.getBorderNumber(tempBorder), parentXF.XFId, parentXF.HorAlign, parentXF.VertAlign, parentXF.TextRotationAngle, parentXF.TextWrapped, parentXF.RightToLeft, parentXF.Editable);
                            let newIndexStyle = this.getXFNumber(tempXF);
                            if (!this.exportObjectFormatting)
                                newIndexStyle = 0;
                            writer.writeStartElement('c');
                            writer.writeAttributeString('r', this.getRefString(indexColumn, indexRow - minRowIndex));
                            writer.writeAttributeString('s', newIndexStyle.toString());
                            writer.writeEndElement();
                        }
                    }
                }
                writer.writeEndElement();
            }
            writer.writeEndElement();
            if (this.restrictEditing != __.b.StiExcel2007RestrictEditing.No) {
                writer.writeStartElement('sheetProtection');
                writer.writeAttributeString('password', 'F05F');
                writer.writeAttributeString('sheet', '1');
                writer.writeAttributeString('objects', '1');
                writer.writeAttributeString('scenarios', '1');
                writer.writeEndElement();
            }
            if (mergedCells.length > 0 && (this.dataExportMode == __.b.StiDataExportMode.AllBands || this.exportObjectFormatting)) {
                writer.writeStartElement('mergeCells');
                writer.writeAttributeString('count', StiString.format('{0}', mergedCells.length));
                for (let index = 0; index < mergedCells.length; index++) {
                    let tempCellRange = mergedCells[index];
                    writer.writeStartElement('mergeCell');
                    writer.writeAttributeString('ref', StiString.format('{0}:{1}', this.getRefString(tempCellRange.FirstColumn, tempCellRange.FirstRow), this.getRefString(tempCellRange.LastColumn, tempCellRange.LastRow)));
                    writer.writeEndElement();
                }
                writer.writeEndElement();
            }
            if (hlinks.length > 0) {
                let found = false;
                for (let indexHlink = 0; indexHlink < hlinks.length; indexHlink++) {
                    let hl = hlinks[indexHlink];
                    let hyperlink = hl.Bookmark;
                    if (hyperlink.stimulsoft().startsWith('#')) {
                        hyperlink = hyperlink.substring(1);
                        for (let indexMatrix = 0; indexMatrix < this.matrixList.length; indexMatrix++) {
                            let bookmarks = this.matrixList[indexMatrix].bookmarksTable;
                            if (bookmarks != null) {
                                let obj = bookmarks.get(hyperlink);
                                if (obj != null) {
                                    let minRow = this.minRowList[indexMatrix];
                                    let maxRow = this.maxRowList[indexMatrix];
                                    let pos = obj.stimulsoft().as(Size);
                                    if (pos.height >= minRow && pos.height < maxRow) {
                                        found = true;
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        found = true;
                    }
                    if (found)
                        break;
                }
                if (found) {
                    writer.writeStartElement('hyperlinks');
                    for (let indexHlink = 0; indexHlink < hlinks.length; indexHlink++) {
                        let hl = hlinks[indexHlink];
                        let hyperlink = hl.Bookmark;
                        if (hyperlink.stimulsoft().startsWith('#')) {
                            hyperlink = hyperlink.substring(1);
                            let isFounded = false;
                            for (let indexMatrix = 0; indexMatrix < this.matrixList.length; indexMatrix++) {
                                let bookmarks = this.matrixList[indexMatrix].bookmarksTable;
                                if (bookmarks != null) {
                                    let obj = bookmarks.get(hyperlink);
                                    if (obj != null) {
                                        let minRow = this.minRowList[indexMatrix];
                                        let maxRow = this.maxRowList[indexMatrix];
                                        let pos = obj.stimulsoft().as(Size);
                                        if (pos.height >= minRow && pos.height < maxRow) {
                                            hyperlink = StiString.format("'{0}'!{1}", this.sheetNameList[indexMatrix], this.getRefString(pos.width, pos.height - minRow));
                                            isFounded = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (isFounded) {
                                writer.writeStartElement('hyperlink');
                                writer.writeAttributeString('ref', this.getRefString(hl.Range.FirstColumn, hl.Range.FirstRow));
                                writer.writeAttributeString('location', hyperlink);
                                writer.writeAttributeString('display', hl.Description);
                                writer.writeEndElement();
                            }
                        } else {
                            let display = hyperlink;
                            if (hyperlink.stimulsoft().startsWith('file:\\\\\\')) {
                                display = hyperlink.substring(8);
                                hyperlink = 'file:///' + display;
                            }
                            if (hyperlink.stimulsoft().startsWith('http:')) {
                                hyperlink = hyperlink.stimulsoft().replaceAll(' ', '');
                            }
                            writer.writeStartElement('hyperlink');
                            writer.writeAttributeString('ref', this.getRefString(hl.Range.FirstColumn, hl.Range.FirstRow));
                            writer.writeAttributeString('r:id', StiString.format('rId{0}', 2 + this.hyperlinkList.length));
                            writer.writeAttributeString('display', display);
                            writer.writeEndElement();
                            this.hyperlinkList.push(this.stringToUrl(hyperlink));
                        }
                    }
                    writer.writeEndElement();
                }
            }
            writer.writeStartElement('pageMargins');
            writer.writeAttributeString('left', this.floatToString(page.convertToHInches(page.unit, page.margins.left) / 100));
            writer.writeAttributeString('right', this.floatToString(page.convertToHInches(page.unit, page.margins.right) / 100));
            writer.writeAttributeString('top', this.floatToString(page.convertToHInches(page.unit, page.margins.top) / 100));
            writer.writeAttributeString('bottom', this.floatToString(page.convertToHInches(page.unit, page.margins.bottom) / 100));
            writer.writeAttributeString('header', this.floatToString(0));
            writer.writeAttributeString('footer', this.floatToString(0));
            writer.writeEndElement();
            writer.writeStartElement('pageSetup');
            writer.writeAttributeString('paperSize', StiString.format('{0}', page.paperSize));
            writer.writeAttributeString('orientation', page.orientation == StiPageOrientation.Portrait ? 'portrait' : 'landscape');
            if (Stimulsoft['StiOptions'].Export.Excel.FitToOnePageWide) {
                writer.writeAttributeString('fitToHeight', '0');
            }
            writer.writeEndElement();
            if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                writer.writeStartElement('headerFooter');
                writer.writeStartElement('oddHeader');
                writer.writeRaw('&amp;C\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n&amp;G');
                writer.writeEndElement();
                writer.writeEndElement();
            }
            let horizontalPageBreaksCount = this.matrix.horizontalPageBreaks.length;
            if (this.exportHorizontalPageBreaks && horizontalPageBreaksCount > 0) {
                writer.writeStartElement('rowBreaks');
                writer.writeAttributeString('count', horizontalPageBreaksCount.toString());
                writer.writeAttributeString('manualBreakCount', horizontalPageBreaksCount.toString());
                for (let indexBreak = 0; indexBreak < horizontalPageBreaksCount; indexBreak++) {
                    writer.writeStartElement('brk');
                    writer.writeAttributeString('id', StiString.format('{0}', this.matrix.horizontalPageBreaks[indexBreak]));
                    writer.writeAttributeString('max', indexBreak == 0 ? '16383' : '8');
                    writer.writeAttributeString('man', '1');
                    writer.writeEndElement();
                }
                writer.writeEndElement();
            }
            if (this.imageList.length > this.imageListOffset) {
                writer.writeStartElement('drawing');
                writer.writeAttributeString('r:id', StiString.format('rId{0}', 1));
                writer.writeEndElement();
            }
            if (numberStoredAsText.length > 0) {
                writer.writeStartElement('ignoredErrors');
                for (let sqref in numberStoredAsText) {
                    writer.writeStartElement('ignoredError');
                    writer.writeAttributeString('sqref', numberStoredAsText[sqref]);
                    writer.writeAttributeString('numberStoredAsText', '1');
                    writer.writeEndElement();
                }
                writer.writeEndElement();
            }
            if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                writer.writeStartElement('legacyDrawingHF');
                writer.writeAttributeString('r:id', 'dId1');
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        checkForNumber(str) {
            let m = str.match(StiExcel2007ExportService.regexCheckInteger1);
            if (m != null)
                return true;
            m = str.match(StiExcel2007ExportService.regexCheckFloat1);
            if (m != null)
                return true;
            return false;
        }
        prepareMatrix(pages) {
            let dataMode = this.dataExportMode;
            if (Stimulsoft['StiOptions'].Export.Excel.AllowExportFootersInDataOnlyMode)
                dataMode |= __.b.StiDataExportMode.Footers;
            this.matrix = new __.b.StiMatrix(pages, Stimulsoft['StiOptions'].Export.Excel.DivideBigCells, this, null, dataMode);
            if (this.useOnePageHeaderAndFooter) {
                this.matrix.scanComponentsPlacement(true, this.exportObjectFormatting);
                let coordXcountItems = this.matrix.coordX.countItems;
                let coordYcountItems = this.matrix.coordY.countItems;
                let coordYKeys = this.matrix.coordY.getKeys();
                let tempOffset = 0;
                while (this.matrix.linePlacement[tempOffset] != __.b.StiTableLineInfo.PageHeader && tempOffset < coordYcountItems - 1)
                    tempOffset++;
                if (this.matrix.linePlacement[tempOffset] == __.b.StiTableLineInfo.PageHeader) {
                    while (this.matrix.linePlacement[tempOffset] == __.b.StiTableLineInfo.PageHeader && tempOffset < coordYcountItems - 1)
                        tempOffset++;
                    while (tempOffset < coordYcountItems - 1) {
                        if (this.matrix.linePlacement[tempOffset] == __.b.StiTableLineInfo.PageHeader) {
                            this.matrix.linePlacement[tempOffset] = __.b.StiTableLineInfo.Trash;
                        }
                        tempOffset++;
                    }
                }
                tempOffset = coordYcountItems - 1;
                while (this.matrix.linePlacement[tempOffset] != __.b.StiTableLineInfo.PageFooter && tempOffset > 0)
                    tempOffset--;
                if (this.matrix.linePlacement[tempOffset] == __.b.StiTableLineInfo.PageFooter) {
                    while (this.matrix.linePlacement[tempOffset] == __.b.StiTableLineInfo.PageFooter && tempOffset > 0)
                        tempOffset--;
                    while (tempOffset > 0) {
                        if (this.matrix.linePlacement[tempOffset] == __.b.StiTableLineInfo.PageFooter) {
                            this.matrix.linePlacement[tempOffset] = __.b.StiTableLineInfo.Trash;
                        }
                        tempOffset--;
                    }
                }
                let linesCount = 0;
                let lineOffset = 0;
                for (let rowIndex = 0; rowIndex < coordYcountItems - 1; rowIndex++) {
                    if (this.matrix.linePlacement[rowIndex] != __.b.StiTableLineInfo.Trash) {
                        for (let columnIndex = 0; columnIndex < coordXcountItems - 1; columnIndex++) {
                            this.matrix.cells[linesCount][columnIndex] = this.matrix.cells[rowIndex][columnIndex];
                            let cell = this.matrix.cells[linesCount][columnIndex];
                            if (cell != null) {
                                cell.top = linesCount;
                                if (cell.exportImage != null) {
                                }
                            }
                            this.matrix.bordersX[linesCount][columnIndex] = this.matrix.bordersX[rowIndex][columnIndex];
                            this.matrix.bordersY[linesCount][columnIndex] = this.matrix.bordersY[rowIndex][columnIndex];
                            this.matrix.bookmarks[linesCount][columnIndex] = this.matrix.bookmarks[rowIndex][columnIndex];
                        }
                        this.matrix.bordersY[linesCount][coordXcountItems - 1] = this.matrix.bordersY[rowIndex][coordXcountItems - 1];
                        let lineHeight = this.matrix.coordY.getByIndex(rowIndex + 1, coordYKeys) - this.matrix.coordY.getByIndex(rowIndex, coordYKeys);
                        this.matrix.coordY.setByIndex(linesCount + 1, this.matrix.coordY.getByIndex(linesCount, coordYKeys) + lineHeight, coordYKeys);
                        linesCount++;
                    } else {
                        lineOffset++;
                    }
                    if (this.exportHorizontalPageBreaks) {
                        for (let indexHPB = 0; indexHPB < this.matrix.horizontalPageBreaks.length; indexHPB++) {
                            if (this.matrix.horizontalPageBreaks[indexHPB] == rowIndex) {
                                this.matrix.horizontalPageBreaks[indexHPB] = this.matrix.horizontalPageBreaks[indexHPB] - (lineOffset - 1);
                            }
                        }
                    }
                }
                for (let columnIndex = 0; columnIndex < coordXcountItems - 1; columnIndex++) {
                    this.matrix.bordersX[linesCount][columnIndex] = this.matrix.bordersX[coordYcountItems - 1][columnIndex];
                }
                coordYKeys = this.matrix.coordY.getKeys();
                let numAbove = coordYcountItems - 1 - linesCount;
                if (numAbove > 0) {
                    let newList = new List();
                    for (let tempIndex = 0; tempIndex < linesCount + 1; tempIndex++) {
                        let vall = this.matrix.coordY.getByIndex(tempIndex, coordYKeys);
                        newList.add(vall);
                    }
                    this.matrix.coordY = newList;
                }
            }
            if (this.dataExportMode != __.b.StiDataExportMode.AllBands) {
                this.matrix.scanComponentsPlacement(true, this.exportObjectFormatting);
                let coordXcountItems = this.matrix.coordX.countItems;
                let coordYcountItems = this.matrix.coordY.countItems;
                let coordYKeys = this.matrix.coordY.getKeys();
                let linesCount = 0;
                let headerNames = new Hashtable();
                let lastParentBandName = null;
                let lastIsHeader = false;
                for (let rowIndex = 0; rowIndex < coordYcountItems - 1; rowIndex++) {
                    let isHeader = false;
                    if (this.matrix.linePlacement[rowIndex] == __.b.StiTableLineInfo.HeaderD || this.matrix.linePlacement[rowIndex] == __.b.StiTableLineInfo.HeaderAP) {
                        let currentParentBandName = this.matrix.parentBandName[rowIndex];
                        if (lastIsHeader && this.getParentBandName(rowIndex) == this.getParentBandName(rowIndex - 1)) {
                            isHeader = true;
                        } else {
                            let symPos = currentParentBandName.indexOf('');
                            if (symPos != -1) {
                                let parentBandName = currentParentBandName.substring(0, symPos);
                                if (parentBandName != lastParentBandName) {
                                    lastParentBandName = parentBandName;
                                    headerNames.clear();
                                }
                            }
                            if (!headerNames.containsKey(currentParentBandName)) {
                                isHeader = true;
                                headerNames.add(currentParentBandName, currentParentBandName);
                            }
                        }
                    }
                    lastIsHeader = isHeader;
                    if (this.matrix.linePlacement[rowIndex] == __.b.StiTableLineInfo.Data || this.matrix.linePlacement[rowIndex] == __.b.StiTableLineInfo.FooterD || isHeader) {
                        for (let columnIndex = 0; columnIndex < coordXcountItems - 1; columnIndex++) {
                            this.matrix.cells[linesCount][columnIndex] = this.matrix.cells[rowIndex][columnIndex];
                            let cell = this.matrix.cells[linesCount][columnIndex];
                            if (cell != null) {
                                cell.top = linesCount;
                                if (cell.exportImage != null) {
                                }
                            }
                            if (linesCount == 0 || this.matrix.bordersX[rowIndex][columnIndex] != null) {
                                this.matrix.bordersX[linesCount][columnIndex] = this.matrix.bordersX[rowIndex][columnIndex];
                            }
                            this.matrix.bordersX[linesCount + 1][columnIndex] = this.matrix.bordersX[rowIndex + 1][columnIndex];
                            this.matrix.bordersY[linesCount][columnIndex] = this.matrix.bordersY[rowIndex][columnIndex];
                            this.matrix.bookmarks[linesCount][columnIndex] = this.matrix.bookmarks[rowIndex][columnIndex];
                        }
                        this.matrix.bordersY[linesCount][coordXcountItems - 1] = this.matrix.bordersY[rowIndex][coordXcountItems - 1];
                        let lineHeight = this.matrix.coordY.getByIndex(rowIndex + 1, coordYKeys) - this.matrix.coordY.getByIndex(rowIndex, coordYKeys);
                        this.matrix.coordY.setByIndex(linesCount + 1, this.matrix.coordY.getByIndex(linesCount, coordYKeys) + lineHeight, coordYKeys);
                        linesCount++;
                    }
                }
                let numAbove = coordYcountItems - 1 - linesCount;
                if (numAbove > 0) {
                    let newList = new List();
                    for (let tempIndex = 0; tempIndex < linesCount + 1; tempIndex++) {
                        let vall = this.matrix.coordY.getByIndex(tempIndex, coordYKeys);
                        newList.add(vall);
                    }
                    this.matrix.coordY = newList;
                }
            }
        }
        getParentBandName(rowIndex) {
            let st = this.matrix.parentBandName[rowIndex];
            let symPos = st.indexOf('');
            if (symPos == -1)
                return st;
            return st.substr(0, symPos);
        }
        convertAllowHtmlTagsToExcelString(textBox, input) {
            let writer = new XmlTextWriter(Encoding.UTF8);
            let baseTagsState = new StiHtmlTagsState(textBox.font.bold, textBox.font.italic, textBox.font.underline, textBox.font.strikeout, textBox.font.sizeInPoints, textBox.font.name, StiBrush.toColor(textBox.textBrush), StiBrush.toColor(textBox.brush), false, false, 0, 0, 1, textBox.horAlignment);
            let baseState = new StiHtmlState(baseTagsState, 0);
            let states = StiTextRenderer.parseHtmlToStates(textBox.text, baseState);
            for (let index = 0; index < states.length; index++) {
                let state = states[index];
                writer.writeStartElement('r');
                writer.writeStartElement('rPr');
                if (state.ts.bold) {
                    writer.writeElementString('b', null);
                }
                if (state.ts.italic) {
                    writer.writeElementString('i', null);
                }
                if (state.ts.underline) {
                    writer.writeElementString('u', null);
                }
                if (state.ts.strikeout) {
                    writer.writeElementString('strike', null);
                }
                if (state.ts.superscript) {
                    writer.writeStartElement('vertAlign');
                    writer.writeAttributeString('val', 'superscript');
                    writer.writeEndElement();
                }
                if (state.ts.subsript) {
                    writer.writeStartElement('vertAlign');
                    writer.writeAttributeString('val', 'subscript');
                    writer.writeEndElement();
                }
                writer.writeStartElement('sz');
                writer.writeAttributeString('val', state.ts.fontSize.toString());
                writer.writeEndElement();
                writer.writeStartElement('color');
                writer.writeAttributeString('rgb', StiString.format('{0:X8}', state.ts.fontColor.toArgb()));
                writer.writeEndElement();
                writer.writeStartElement('rFont');
                writer.writeAttributeString('val', state.ts.fontName);
                writer.writeEndElement();
                writer.writeEndElement();
                let st = StiTextRenderer.prepareStateText(state.text).toString();
                if (StiString.isNullOrEmpty(st))
                    st = ' ';
                this.convertTextToExcelString(writer, st);
                writer.writeEndElement();
            }
            writer.flush();
            writer.close();
            return writer.textWriter.getStringBuilder().toString();
        }
        convertTextToExcelString(writer, input) {
            writer.writeStartElement('t');
            if (input.length > 0 && (Char.isWhitespace(input, input.length - 1) || Char.isWhitespace(input, 0) || input.indexOf('\n') != -1)) {
                writer.writeAttributeString('xml:space', 'preserve');
            }
            writer.writeString(input);
            writer.writeFullEndElement();
        }
        writeDrawingRels(indexSheet) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            for (let index = this.imageListOffset; index < this.imageList.length; index++) {
                let image = this.imageList[index];
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', index - this.imageListOffset + 1));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image');
                writer.writeAttributeString('Target', StiString.format('../media/image{0:D5}.jpeg', image.ImageIndex + 1));
                writer.writeEndElement();
                if (!StiString.isNullOrWhiteSpace(image.Hyperlink)) {
                    writer.writeStartElement('Relationship');
                    writer.writeAttributeString('Id', StiString.format('hId{0}', index - this.imageListOffset + 1));
                    writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink');
                    writer.writeAttributeString('Target', image.Hyperlink);
                    writer.writeAttributeString('TargetMode', 'External');
                    writer.writeEndElement();
                }
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeDrawing(indexSheet) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('xdr:wsDr');
            writer.writeAttributeString('xmlns:xdr', 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing');
            writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
            for (let index = this.imageListOffset; index < this.imageList.length; index++) {
                let image = this.imageList[index];
                writer.writeStartElement('xdr:twoCellAnchor');
                writer.writeAttributeString('editAs', 'oneCell');
                writer.writeStartElement('xdr:from');
                writer.writeElementString('xdr:col', StiString.format('{0}', image.FirstColumnIndex));
                writer.writeElementString('xdr:colOff', StiString.format('{0}', image.FirstColumnOffset));
                writer.writeElementString('xdr:row', StiString.format('{0}', image.FirstRowIndex));
                writer.writeElementString('xdr:rowOff', StiString.format('{0}', image.FirstRowOffset));
                writer.writeEndElement();
                writer.writeStartElement('xdr:to');
                writer.writeElementString('xdr:col', StiString.format('{0}', image.LastColumnIndex));
                writer.writeElementString('xdr:colOff', StiString.format('{0}', image.LastColumnOffset));
                writer.writeElementString('xdr:row', StiString.format('{0}', image.LastRowIndex));
                writer.writeElementString('xdr:rowOff', StiString.format('{0}', image.LastRowOffset));
                writer.writeEndElement();
                writer.writeStartElement('xdr:pic');
                writer.writeStartElement('xdr:nvPicPr');
                writer.writeStartElement('xdr:cNvPr');
                writer.writeAttributeString('id', StiString.format('{0}', index - this.imageListOffset + 2));
                writer.writeAttributeString('name', StiString.format('Picture {0}', index - this.imageListOffset + 1));
                writer.writeAttributeString('descr', StiString.format('image{0:D5}', index + 1));
                if (!StiString.isNullOrWhiteSpace(image.Hyperlink)) {
                    writer.writeStartElement('a:hlinkClick');
                    writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
                    writer.writeAttributeString('r:id', StiString.format('hId{0}', index - this.imageListOffset + 1));
                    writer.writeEndElement();
                }
                writer.writeEndElement();
                writer.writeStartElement('xdr:cNvPicPr');
                writer.writeStartElement('a:picLocks');
                writer.writeAttributeString('noChangeAspect', '1');
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeStartElement('xdr:blipFill');
                writer.writeStartElement('a:blip');
                writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
                writer.writeAttributeString('r:embed', StiString.format('rId{0}', index - this.imageListOffset + 1));
                writer.writeEndElement();
                writer.writeStartElement('a:stretch');
                writer.writeStartElement('a:fillRect');
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeStartElement('xdr:spPr');
                writer.writeStartElement('a:xfrm');
                writer.writeStartElement('a:off');
                writer.writeAttributeString('x', '1');
                writer.writeAttributeString('y', '1');
                writer.writeEndElement();
                writer.writeStartElement('a:ext');
                writer.writeAttributeString('cx', '2');
                writer.writeAttributeString('cy', '2');
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeStartElement('a:prstGeom');
                writer.writeAttributeString('prst', 'rect');
                writer.writeStartElement('a:avLst');
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeStartElement('xdr:clientData');
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeStyles() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('styleSheet');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
            if (this.formatList.length > 0) {
                writer.writeStartElement('numFmts');
                writer.writeAttributeString('count', StiString.format('{0}', this.formatList.length));
                for (let index = 0; index < this.formatList.length; index++) {
                    writer.writeStartElement('numFmt');
                    writer.writeAttributeString('numFmtId', StiString.format('{0}', 164 + index));
                    writer.writeAttributeString('formatCode', this.formatList[index]);
                    writer.writeEndElement();
                }
                writer.writeEndElement();
            }
            writer.writeStartElement('fonts');
            writer.writeAttributeString('count', StiString.format('{0}', this.fontList.length));
            for (let index = 0; index < this.fontList.length; index++) {
                let tempFont = this.fontList[index];
                writer.writeStartElement('font');
                if (tempFont.Bold) {
                    writer.writeElementString('b', '');
                }
                if (tempFont.Italic) {
                    writer.writeElementString('i', '');
                }
                if (tempFont.Underlined) {
                    writer.writeElementString('u', '');
                }
                if (tempFont.Strikeout) {
                    writer.writeElementString('strike', '');
                }
                writer.writeStartElement('sz');
                writer.writeAttributeString('val', StiString.format('{0}', tempFont.Height));
                writer.writeEndElement();
                writer.writeStartElement('color');
                writer.writeAttributeString('rgb', StiString.format('{0:X8}', tempFont.Color.toArgb()));
                writer.writeEndElement();
                writer.writeStartElement('name');
                writer.writeAttributeString('val', tempFont.Name);
                writer.writeEndElement();
                writer.writeStartElement('charset');
                writer.writeAttributeString('val', StiString.format('{0}', tempFont.Charset));
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeEndElement();
            writer.writeStartElement('fills');
            writer.writeAttributeString('count', StiString.format('{0}', this.fillList.length));
            for (let index = 0; index < this.fillList.length; index++) {
                let tempFill = this.fillList[index];
                writer.writeStartElement('fill');
                writer.writeStartElement('patternFill');
                writer.writeAttributeString('patternType', tempFill.Type);
                if (tempFill.Type == 'solid') {
                    writer.writeStartElement('fgColor');
                    writer.writeAttributeString('rgb', StiString.format('{0:X8}', tempFill.FgColor.toArgb()));
                    writer.writeEndElement();
                    writer.writeStartElement('bgColor');
                    writer.writeAttributeString('indexed', StiString.format('{0}', 64));
                    writer.writeEndElement();
                }
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeEndElement();
            writer.writeStartElement('borders');
            writer.writeAttributeString('count', StiString.format('{0}', this.borderList.length));
            for (let index = 0; index < this.borderList.length; index++) {
                let tempBorder = this.borderList[index];
                writer.writeStartElement('border');
                this.writeBorderData(writer, 'left', tempBorder.BorderLeft);
                this.writeBorderData(writer, 'right', tempBorder.BorderRight);
                this.writeBorderData(writer, 'top', tempBorder.BorderTop);
                this.writeBorderData(writer, 'bottom', tempBorder.BorderBottom);
                this.writeBorderData(writer, 'diagonal', null);
                writer.writeEndElement();
            }
            writer.writeEndElement();
            writer.writeStartElement('cellStyleXfs');
            writer.writeAttributeString('count', StiString.format('{0}', 1));
            writer.writeStartElement('xf');
            writer.writeAttributeString('numFmtId', StiString.format('{0}', 0));
            writer.writeAttributeString('fontId', StiString.format('{0}', 0));
            writer.writeAttributeString('fillId', StiString.format('{0}', 0));
            writer.writeAttributeString('borderId', StiString.format('{0}', 0));
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('cellXfs');
            writer.writeAttributeString('count', StiString.format('{0}', this.xfList.length));
            for (let index = 0; index < this.xfList.length; index++) {
                let tempXF = this.xfList[index];
                let tempFill = this.fillList[tempXF.FillIndex];
                let fillIndex = tempXF.FillIndex;
                if (tempFill.FgColor.a == 0)
                    fillIndex = 0;
                writer.writeStartElement('xf');
                writer.writeAttributeString('numFmtId', StiString.format('{0}', tempXF.FormatIndex));
                writer.writeAttributeString('fontId', StiString.format('{0}', tempXF.FontIndex));
                writer.writeAttributeString('fillId', StiString.format('{0}', fillIndex));
                writer.writeAttributeString('borderId', StiString.format('{0}', tempXF.BorderIndex));
                writer.writeAttributeString('xfId', StiString.format('{0}', tempXF.XFId));
                if (tempXF.FormatIndex != 0) {
                    writer.writeAttributeString('applyNumberFormat', '1');
                }
                if (tempXF.FontIndex != 0) {
                    writer.writeAttributeString('applyFont', '1');
                }
                if (tempXF.FillIndex != 0) {
                    writer.writeAttributeString('applyFill', '1');
                }
                if (tempXF.BorderIndex != 0) {
                    writer.writeAttributeString('applyBorder', '1');
                }
                writer.writeAttributeString('applyAlignment', '1');
                if (tempXF.Editable) {
                    writer.writeAttributeString('applyProtection', '1');
                }
                writer.writeStartElement('alignment');
                let horAlign = 'left';
                switch (tempXF.HorAlign) {
                case StiTextHorAlignment.Right:
                    horAlign = 'right';
                    break;
                case StiTextHorAlignment.Center:
                    horAlign = 'center';
                    break;
                case StiTextHorAlignment.Width:
                    horAlign = 'justify';
                    break;
                }
                writer.writeAttributeString('horizontal', horAlign);
                if (tempXF.VertAlign != StiVertAlignment.Bottom) {
                    let vertAlign = '';
                    switch (tempXF.VertAlign) {
                    case StiVertAlignment.Top:
                        vertAlign = 'top';
                        break;
                    case StiVertAlignment.Center:
                        vertAlign = 'center';
                        break;
                    }
                    writer.writeAttributeString('vertical', vertAlign);
                }
                if (tempXF.TextRotationAngle != 0) {
                    writer.writeAttributeString('textRotation', tempXF.TextRotationAngle.toString());
                }
                if (tempXF.TextWrapped) {
                    writer.writeAttributeString('wrapText', '1');
                }
                if (tempXF.RightToLeft) {
                    writer.writeAttributeString('readingOrder', '2');
                }
                writer.writeEndElement();
                if (tempXF.Editable) {
                    writer.writeStartElement('protection');
                    writer.writeAttributeString('locked', '0');
                    writer.writeEndElement();
                }
                writer.writeEndElement();
            }
            writer.writeEndElement();
            writer.writeStartElement('cellStyles');
            writer.writeAttributeString('count', StiString.format('{0}', 1));
            writer.writeStartElement('cellStyle');
            writer.writeAttributeString('name', 'Normal');
            writer.writeAttributeString('xfId', StiString.format('{0}', 0));
            writer.writeAttributeString('builtinId', StiString.format('{0}', 0));
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('dxfs');
            writer.writeAttributeString('count', StiString.format('{0}', 0));
            writer.writeEndElement();
            writer.writeStartElement('tableStyles');
            writer.writeAttributeString('count', StiString.format('{0}', 0));
            writer.writeAttributeString('defaultTableStyle', 'TableStyleMedium9');
            writer.writeAttributeString('defaultPivotStyle', 'PivotStyleLight16');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeBorderData(writer, side, border) {
            writer.writeStartElement(side);
            if (border != null) {
                let style = this.getLineStyle(border);
                let color = border.color;
                if (style != '') {
                    writer.writeAttributeString('style', style);
                    writer.writeStartElement('color');
                    writer.writeAttributeString('rgb', StiString.format('{0:X8}', color.toArgb()));
                    writer.writeEndElement();
                }
            }
            writer.writeEndElement();
        }
        writeSST() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.writeStartDocument();
            writer.writeStartElement('sst');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/spreadsheetml/2006/main');
            writer.writeAttributeString('count', StiString.format('{0}', this.sstCount));
            writer.writeAttributeString('uniqueCount', StiString.format('{0}', this.sstList.length));
            for (let index = 0; index < this.sstList.length; index++) {
                writer.writeStartElement('si');
                let st = this.sstList[index];
                let sb = new StringBuilder();
                for (let i = 0; i < st.length; i++) {
                    if (st.charCodeAt(i) >= 32 || st.charAt(i) == '\n')
                        sb.append(st.charAt(i));
                }
                st = sb.toString();
                if (this.sstHashIsTags.containsKey(index)) {
                    writer.writeRaw(st);
                } else {
                    this.convertTextToExcelString(writer, st);
                }
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeAdditionalData(st, base64) {
            let ms = new MemoryStream();
            let bytes = null;
            if (base64) {
                bytes = Stimulsoft.System.Convert.fromBase64String(st);
            } else {
                bytes = Encoding.ASCII.getBytes(st);
            }
            ms.write(bytes, 0, bytes.length);
            return ms;
        }
        writeImage(_number) {
            let ms = new MemoryStream();
            let bytes = this.imageCache.imagePackedStore[_number];
            if (bytes != null) {
                ms.write(bytes, 0, bytes.length);
            }
            return ms;
        }
        exportExcel(report, stream, settings) {
            __.a.StiLogService.write(this.stimulsoft().getType(), 'Export report to Excel 2007 format');
            let pageRange = settings.pageRange;
            this.useOnePageHeaderAndFooter = settings.useOnePageHeaderAndFooter;
            this.dataExportMode = settings.dataExportMode;
            this.exportObjectFormatting = settings.exportObjectFormatting;
            this.exportEachPageToSheet = settings.exportEachPageToSheet;
            this.exportHorizontalPageBreaks = settings.exportPageBreaks;
            this.imageResolution = settings.imageResolution;
            this.imageQuality = settings.imageQuality;
            this.docCompanyString = settings.companyString;
            this.docLastModifiedString = settings.lastModifiedString;
            this.restrictEditing = settings.restrictEditing;
            this.xmlIndentation = -1;
            if (this.imageResolution < 10)
                this.imageResolution = 10;
            this.imageResolution = this.imageResolution / 100;
            if (this.dataExportMode != __.b.StiDataExportMode.AllBands) {
                this.useOnePageHeaderAndFooter = false;
            } else {
                this.exportObjectFormatting = true;
            }
            if (Stimulsoft['StiOptions'].Export.Excel.RestrictEditing > this.restrictEditing) {
                this.restrictEditing = Stimulsoft['StiOptions'].Export.Excel.RestrictEditing;
            }
            this.report = report;
            try {
                this.reportCulture = CultureInfo.currentCulture;
                let allPages = pageRange.getSelectedPages(report.renderedPages);
                this.currentPassNumber = 0;
                this.maximumPassNumber = 3;
                this.prepareData();
                let indexPage = 0;
                while (indexPage < allPages.length) {
                    let pages = new StiPagesCollection(report, report.renderedPages);
                    pages.cacheMode = report.renderedPages.cacheMode;
                    pages.addV2Internal(allPages.getPageWithoutCache(indexPage));
                    let firstPageIndex = indexPage;
                    if (!this.exportEachPageToSheet) {
                        let pageName = allPages.getPageWithoutCache(indexPage).excelSheetValue;
                        while (indexPage < allPages.length - 1 && this.compareExcellSheetNames(allPages.getPageWithoutCache(indexPage + 1).excelSheetValue, pageName)) {
                            indexPage++;
                            pages.addV2Internal(allPages.getPageWithoutCache(indexPage));
                        }
                    }
                    let sheetName = pages.getByIndex(0).excelSheetValue;
                    if (sheetName == null || sheetName == '') {
                        sheetName = StiString.format('Page {0}', this.sheetNameList.length + 1);
                    }
                    let sheetSuffix = '';
                    let sheetIndex = 1;
                    this.prepareMatrix(pages);
                    let minRowIndex = 0;
                    do {
                        this.firstPageIndexList.push(firstPageIndex);
                        this.matrixList.push(this.matrix);
                        let maxRowIndex = this.matrix.coordY.countItems - 1;
                        if (maxRowIndex - minRowIndex > Stimulsoft['StiOptions'].Export.Excel.MaximumSheetHeight) {
                            maxRowIndex = minRowIndex + Stimulsoft['StiOptions'].Export.Excel.MaximumSheetHeight;
                        } else {
                            this.matrix = null;
                        }
                        this.minRowList.push(minRowIndex);
                        this.maxRowList.push(maxRowIndex);
                        minRowIndex = maxRowIndex;
                        if (this.matrix != null || sheetSuffix.length > 0) {
                            sheetSuffix = StiString.format(' part{0}', sheetIndex++);
                            if (sheetName.length > 24)
                                sheetName = sheetName.substr(0, 24);
                        } else {
                            if (sheetName.length > 30)
                                sheetName = sheetName.substr(0, 30);
                        }
                        this.sheetNameList.push(sheetName + sheetSuffix);
                    } while (this.matrix != null);
                    indexPage++;
                }
                let ht = new Hashtable();
                for (let index = 0; index < this.sheetNameList.length; index++) {
                    let titleString = this.sheetNameList[index];
                    titleString = titleString.stimulsoft().replaceAll('*', '_').stimulsoft().replaceAll('\\', '_').stimulsoft().replaceAll('/', '_').stimulsoft().replaceAll('[', '_').stimulsoft().replaceAll(']', '_').stimulsoft().replaceAll(':', '_').stimulsoft().replaceAll('?', '_');
                    if (ht.contains(titleString)) {
                        let numVariant = 1;
                        while (ht.contains(titleString + '-' + numVariant.toString())) {
                            numVariant++;
                        }
                        titleString = titleString + '-' + numVariant.toString();
                    }
                    ht.add(titleString, titleString);
                    this.sheetNameList[index] = titleString;
                }
                let zip = new StiZipWriter20();
                zip.begin(stream, true);
                this.currentPassNumber = 2;
                this.imageListOffset = 0;
                for (let indexSheet = 0; indexSheet < this.matrixList.length; indexSheet++) {
                    this.hyperlinkList = [];
                    zip.addFile(StiString.format('xl/worksheets/sheet{0}.xml', indexSheet + 1), this.writeSheet(indexSheet, allPages.getByIndex(this.firstPageIndexList[indexSheet])));
                    {
                        zip.addFile(StiString.format('xl/worksheets/_rels/sheet{0}.xml.rels', indexSheet + 1), this.writeSheetRels(indexSheet));
                    }
                    if (this.imageList.length - this.imageListOffset > 0) {
                        zip.addFile(StiString.format('xl/drawings/_rels/drawing{0}.xml.rels', indexSheet + 1), this.writeDrawingRels(indexSheet));
                        zip.addFile(StiString.format('xl/drawings/drawing{0}.xml', indexSheet + 1), this.writeDrawing(indexSheet));
                    }
                    this.imageListOffset = this.imageList.length;
                }
                zip.addFile('[Content_Types].xml', this.writeContentTypes());
                zip.addFile('_rels/.rels', this.writeMainRels());
                zip.addFile('docProps/app.xml', this.writeDocPropsApp());
                zip.addFile('docProps/core.xml', this.writeDocPropsCore());
                zip.addFile('xl/_rels/workbook.xml.rels', this.writeWorkbookRels());
                zip.addFile('xl/workbook.xml', this.writeWorkbook());
                zip.addFile('xl/styles.xml', this.writeStyles());
                if (this.sstList.length > 0) {
                    zip.addFile('xl/sharedStrings.xml', this.writeSST());
                }
                if (this.imageCache.imagePackedStore.length > 0) {
                    for (let index = 0; index < this.imageCache.imagePackedStore.length; index++) {
                        zip.addFile(StiString.format('xl/media/image{0:D5}.jpeg', index + 1), this.writeImage(index));
                    }
                }
                if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                    zip.addFile('xl/media/imageAdditional.png', this.writeAdditionalData(__.b.StiExportUtils.additionalData, true));
                    zip.addFile('xl/drawings/_rels/vmlDrawingAdditional.vml.rels', this.writeAdditionalData('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="dId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="../media/imageAdditional.png"/></Relationships>', false));
                    zip.addFile('xl/drawings/vmlDrawingAdditional.vml', this.writeAdditionalData('<xml xmlns:v="urn:schemas-microsoft-com:vml"\r\n xmlns:o="urn:schemas-microsoft-com:office:office"\r\n xmlns:x="urn:schemas-microsoft-com:office:excel">\r\n <o:shapelayout v:ext="edit">\r\n  <o:idmap v:ext="edit" data="1"/>\r\n' + ' </o:shapelayout><v:shapetype id="_x0000_t75" coordsize="21600,21600" o:spt="75"\r\n  o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">\r\n  <v:stroke joinstyle="miter"/>\r\n  <v:formulas>' + '\r\n   <v:f eqn="if lineDrawn pixelLineWidth 0"/>\r\n   <v:f eqn="sum @0 1 0"/>\r\n   <v:f eqn="sum 0 0 @1"/>\r\n   <v:f eqn="prod @2 1 2"/>\r\n   <v:f eqn="prod @3 21600 pixelWidth"/>\r\n   <v:f eqn="prod @3 21600 pixelHeight"/>\r\n   <v:f eqn="sum @0 0 1"/>' + '\r\n   <v:f eqn="prod @6 1 2"/>\r\n   <v:f eqn="prod @7 21600 pixelWidth"/>\r\n   <v:f eqn="sum @8 21600 0"/>\r\n   <v:f eqn="prod @7 21600 pixelHeight"/>\r\n   <v:f eqn="sum @10 21600 0"/>\r\n  </v:formulas>\r\n  <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>' + '\r\n  <o:lock v:ext="edit" aspectratio="t"/>\r\n </v:shapetype><v:shape id="CH" o:spid="_x0000_s1027" type="#_x0000_t75"\r\n  style=\'position:absolute;margin-left:0;margin-top:0;width:365pt;height:298pt;\r\n  z-index:1\'>' + '\r\n  <v:imagedata o:relid="dId1" o:title="additional"/>\r\n  <o:lock v:ext="edit" rotation="t"/>\r\n </v:shape></xml>', false));
                }
                zip.end();
            } catch (e) {
                Stimulsoft.System.StiError.showError(e, false);
            } finally {
                if (this.matrix != null) {
                    this.matrix.clear();
                    this.matrix = null;
                }
                this.fontList = null;
                this.fillList = null;
                this.borderList = null;
                this.xfList = null;
                this.sstList = null;
                this.sstHash = null;
                this.sstHashIsTags = null;
                this.formatList = null;
                this.sheetNameList = null;
                this.imageList.stimulsoft().clear();
                this.imageList = null;
                this.imageCache.clear();
                this.printAreasList = null;
                this.matrixList = null;
                this.firstPageIndexList = null;
                this.hyperlinkList = null;
                this.minRowList = null;
                this.maxRowList = null;
            }
        }
    };
    StiExcel2007ExportService.regexCheckInteger1 = new RegExp('^[+-]?d+$');
    StiExcel2007ExportService.regexCheckFloat1 = new RegExp('^[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)$');
    __.b.StiExcel2007ExportService = StiExcel2007ExportService;
    let DataFont = class {
        constructor(Name, Bold, Italic, Underlined, Strikeout, Height, Color, Charset, Family) {
            this.Name = Name;
            this.Bold = Bold;
            this.Italic = Italic;
            this.Underlined = Underlined;
            this.Strikeout = Strikeout;
            this.Height = Height;
            this.Color = Color;
            this.Charset = Charset;
            this.Family = Family;
        }
        equals(obj) {
            return this.Name == obj.Name && this.Bold == obj.Bold && this.Italic == obj.Italic && this.Underlined == obj.Underlined && this.Strikeout == obj.Strikeout && this.Height == obj.Height && this.Color.equals(obj.Color) && this.Charset == obj.Charset && this.Family == obj.Family;
        }
    };
    __.b.DataFont = DataFont;
    let DataFill = class {
        constructor(Type, FgColor, BgColor) {
            this.Type = Type;
            this.FgColor = FgColor;
            this.BgColor = BgColor;
        }
        equals(obj) {
            return this.Type == obj.Type && this.FgColor.equals(obj.FgColor) && this.BgColor.equals(obj.BgColor);
        }
    };
    __.b.DataFill = DataFill;
    let DataBorder = class {
        constructor(BorderLeft, BorderRight, BorderTop, BorderBottom) {
            this.BorderLeft = BorderLeft;
            this.BorderRight = BorderRight;
            this.BorderTop = BorderTop;
            this.BorderBottom = BorderBottom;
        }
        equals(obj) {
            return this.eq(this.BorderLeft, obj.BorderLeft) && this.eq(this.BorderRight, obj.BorderRight) && this.eq(this.BorderTop, obj.BorderTop) && this.eq(this.BorderBottom, obj.BorderBottom);
        }
        eq(obj1, obj2) {
            return obj1 == null && obj2 == null || obj1 != null && obj2 != null && obj1.stimulsoft().equals(obj2);
        }
    };
    __.b.DataBorder = DataBorder;
    let DataXF = class {
        constructor(FormatIndex, FontIndex, FillIndex, BorderIndex, XFId, HorAlign, VertAlign, TextRotationAngle, TextWrapped, RightToLeft, Editable) {
            this.FormatIndex = FormatIndex;
            this.FontIndex = FontIndex;
            this.FillIndex = FillIndex;
            this.BorderIndex = BorderIndex;
            this.XFId = XFId;
            this.HorAlign = HorAlign;
            this.VertAlign = VertAlign;
            this.TextRotationAngle = TextRotationAngle;
            this.TextWrapped = TextWrapped;
            this.RightToLeft = RightToLeft;
            this.Editable = Editable;
        }
        equalDataXF(xf) {
            if (this.FormatIndex != xf.FormatIndex || this.FontIndex != xf.FontIndex || this.FillIndex != xf.FillIndex || this.BorderIndex != xf.BorderIndex || this.XFId != xf.XFId || this.HorAlign != xf.HorAlign || this.VertAlign != xf.VertAlign || this.TextRotationAngle != xf.TextRotationAngle || this.TextWrapped != xf.TextWrapped || this.RightToLeft != xf.RightToLeft || this.Editable != xf.Editable)
                return false;
            return true;
        }
    };
    __.b.DataXF = DataXF;
    let ExcelImageData = class {
        constructor(FirstRowIndex, FirstRowOffset, FirstColumnIndex, FirstColumnOffset, LastRowIndex, LastRowOffset, LastColumnIndex, LastColumnOffset, ImageIndex, Hyperlink) {
            this.FirstRowIndex = FirstRowIndex;
            this.FirstRowOffset = FirstRowOffset;
            this.FirstColumnIndex = FirstColumnIndex;
            this.FirstColumnOffset = FirstColumnOffset;
            this.LastRowIndex = LastRowIndex;
            this.LastRowOffset = LastRowOffset;
            this.LastColumnIndex = LastColumnIndex;
            this.LastColumnOffset = LastColumnOffset;
            this.ImageIndex = ImageIndex;
            this.Hyperlink = Hyperlink;
        }
    };
    __.b.ExcelImageData = ExcelImageData;
    let CellRangeAddress = class {
        constructor(FirstRow, LastRow, FirstColumn, LastColumn) {
            this.FirstRow = FirstRow;
            this.LastRow = LastRow;
            this.FirstColumn = FirstColumn;
            this.LastColumn = LastColumn;
        }
    };
    __.b.CellRangeAddress = CellRangeAddress;
    let HlinkData = class {
        constructor(Range, Description, Bookmark) {
            this.Range = Range;
            this.Description = Description;
            this.Bookmark = Bookmark;
        }
    };
    __.b.HlinkData = HlinkData;
}
__.b.StiExcelXmlExportService = class extends __.b.StiExportService {
    implements() {
        return [__.b.IStiExcelXmlExportService];
    }
};
let Rectangle = Stimulsoft.System.Drawing.Rectangle;
let StiImage = __.a.Components.StiImage;
let StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
let StiCapStyle = Stimulsoft.Base.Drawing.StiCapStyle;
let StiVerticalLinePrimitive = __.a.Components.StiVerticalLinePrimitive;
let StiHorizontalLinePrimitive = __.a.Components.StiHorizontalLinePrimitive;
let StiAdvancedBorder = Stimulsoft.Base.Drawing.StiAdvancedBorder;
let StiBorderSides = Stimulsoft.Base.Drawing.StiBorderSides;
let IStiBorder = __.a.Components.IStiBorder;
let StiShape = __.a.Components.StiShape;
let IStiBrush = __.a.Components.IStiBrush;
let StiLinePrimitive = __.a.Components.StiLinePrimitive;
let StiTextQuality = __.a.Components.StiTextQuality;
let StiContainer = __.a.Components.StiContainer;
{
    __.b.StiPpt2007ExportService = class extends __.b.StiExportService {
        constructor() {
            super(...arguments);
            this.imageListOffset = 0;
            this.imageResolution = 1;
            this.imageQuality = 0.75;
            this.imageCache = null;
            this.idCounter = 2;
            this.hyperlinkList = null;
            this.xmlIndentation = 1;
            this.currentCulture = null;
            this.newCulture = null;
            this.wrongUrlSymbols = ' "#\'*,;<>[^`{|}';
            this.HiToTwips = 14.4 * 0.995;
        }
        implements() {
            return [__.b.IStiPpt2007ExportService];
        }
        get exportFormat() {
            return __.a.StiExportFormat.Ppt2007;
        }
        exportTo(report, stream, settings) {
            this.exportPowerPoint(report, stream, settings);
        }
        exportToAsync(onExport, report, stream, settings) {
            setTimeout(() => Stimulsoft.tsfb(this, void 0, void 0, function* () {
                yield __.b.StiExportImageHelper.convertAllImages(report, Stimulsoft['StiOptions'].Export.PowerPoint.StoreImagesAsPng ? Stimulsoft.System.Drawing.Imaging.ImageFormat.Png : Stimulsoft.System.Drawing.Imaging.ImageFormat.Jpeg, false, this.exportFormat);
                if (!report.isDocument && report.getCurrentPage().is(IStiDashboard)) {
                    StiDashboardExport.exportAsync(report, stream, settings).try(() => onExport());
                    return;
                }
                this.exportTo(report, stream, settings);
                if (report != null && report.preparedExportImages != null) {
                    report.preparedExportImages.clear();
                    report.preparedExportImages = null;
                }
                onExport();
            }), 0);
        }
        getLineStyle(penStyle) {
            switch (penStyle) {
            case StiPenStyle.Solid:
                return 'solid';
            case StiPenStyle.Dot:
                return 'sysDot';
            case StiPenStyle.Dash:
                return 'sysDash';
            case StiPenStyle.DashDot:
                return 'sysDashDot';
            case StiPenStyle.DashDotDot:
                return 'sysDashDotDot';
            case StiPenStyle.Double:
                return 'solid';
            default:
                return 'solid';
            }
        }
        stringToUrl(input) {
            let buf = Encoding.UTF8.getBytes(input);
            let output = new StringBuilder();
            for (let byt of buf) {
                let ch = String.fromCharCode(byt);
                if (byt < 32 || byt > 127 || this.wrongUrlSymbols.indexOf(ch) != -1) {
                    output.append(StiString.format('%{0:x2}', byt));
                } else {
                    output.append(ch);
                }
            }
            return output.toString();
        }
        convert(x) {
            return Math.round(x * this.HiToTwips) | 0;
        }
        convertTwipsToEmu(x) {
            return Math.round(x / this.HiToTwips / 100 * 914400) | 0;
        }
        convertToEmu(x) {
            return Math.round(x / 100 * 914400) | 0;
        }
        writeColor(writer, color) {
            writer.writeStartElement('a:srgbClr');
            writer.writeAttributeString('val', StiString.format('{0:X6}', color.toArgb() & 16777215));
            if (color.a != 255) {
                let alphaValue = color.a / 256 * 100000 | 0;
                writer.writeStartElement('a:alpha');
                writer.writeAttributeString('val', StiString.format('{0}', alphaValue));
                writer.writeEndElement();
            }
            writer.writeEndElement();
        }
        writeContentTypes(pagesCount) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Types');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/content-types');
            for (let index = 0; index < 11; index++) {
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', StiString.format('/ppt/slideLayouts/slideLayout{0}.xml', index + 1));
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml');
                writer.writeEndElement();
            }
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/ppt/slideMasters/slideMaster1.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/ppt/presProps.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.presentationml.presProps+xml');
            writer.writeEndElement();
            for (let index = 0; index < pagesCount; index++) {
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', StiString.format('/ppt/slides/slide{0}.xml', index + 1));
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.presentationml.slide+xml');
                writer.writeEndElement();
            }
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/ppt/theme/theme1.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.theme+xml');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'jpeg');
            writer.writeAttributeString('ContentType', 'image/jpeg');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'png');
            writer.writeAttributeString('ContentType', 'image/png');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'rels');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-package.relationships+xml');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'xml');
            writer.writeAttributeString('ContentType', 'application/xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/ppt/presentation.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/docProps/app.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.extended-properties+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/ppt/tableStyles.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/ppt/viewProps.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.presentationml.viewProps+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/docProps/core.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-package.core-properties+xml');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeMainRels() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId1');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument');
            writer.writeAttributeString('Target', 'ppt/presentation.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId2');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties');
            writer.writeAttributeString('Target', 'docProps/core.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId3');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties');
            writer.writeAttributeString('Target', 'docProps/app.xml');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeDocPropsApp(pagesCount) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Properties');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties');
            writer.writeAttributeString('xmlns:vt', 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes');
            writer.writeElementString('Application', 'Microsoft Office PowerPoint');
            writer.writeElementString('Slides', StiString.format('{0}', pagesCount));
            writer.writeElementString('PresentationFormat', 'On-screen Show (4:3)');
            writer.writeElementString('TotalTime', '0');
            writer.writeElementString('Words', '0');
            writer.writeElementString('Paragraphs', '0');
            writer.writeElementString('Notes', '0');
            writer.writeElementString('HiddenSlides', '0');
            writer.writeElementString('MMClips', '0');
            writer.writeElementString('ScaleCrop', 'false');
            writer.writeStartElement('HeadingPairs');
            writer.writeStartElement('vt:vector');
            writer.writeAttributeString('size', '4');
            writer.writeAttributeString('baseType', 'variant');
            writer.writeStartElement('vt:variant');
            writer.writeElementString('vt:lpstr', 'Theme');
            writer.writeEndElement();
            writer.writeStartElement('vt:variant');
            writer.writeElementString('vt:i4', StiString.format('{0}', pagesCount));
            writer.writeEndElement();
            writer.writeStartElement('vt:variant');
            writer.writeElementString('vt:lpstr', 'Slide Titles');
            writer.writeEndElement();
            writer.writeStartElement('vt:variant');
            writer.writeElementString('vt:i4', StiString.format('{0}', pagesCount));
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('TitlesOfParts');
            writer.writeStartElement('vt:vector');
            writer.writeAttributeString('size', StiString.format('{0}', 1 + pagesCount));
            writer.writeAttributeString('baseType', 'lpstr');
            writer.writeElementString('vt:lpstr', 'Office Theme');
            for (let index = 0; index < pagesCount; index++) {
                writer.writeElementString('vt:lpstr', StiString.format('Slide {0}', index + 1));
            }
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeElementString('Company', 'Stimulsoft');
            writer.writeElementString('LinksUpToDate', 'false');
            writer.writeElementString('SharedDoc', 'false');
            writer.writeElementString('HyperlinksChanged', 'false');
            writer.writeElementString('AppVersion', '12.0000');
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeDocPropsCore() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('cp:coreProperties');
            writer.writeAttributeString('xmlns:cp', 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeAttributeString('xmlns:dcterms', 'http://purl.org/dc/terms/');
            writer.writeAttributeString('xmlns:dcmitype', 'http://purl.org/dc/dcmitype/');
            writer.writeAttributeString('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
            let dateTime = StiString.format('{0}', DateTime.now.toString('yyyy-MM-ddTHH:mm:ssZ'));
            writer.writeElementString('dc:title', '');
            writer.writeElementString('dc:subject', '');
            writer.writeElementString('dc:creator', 'Stimulsoft Reports');
            writer.writeElementString('cp:keywords', '');
            writer.writeElementString('dc:description', '');
            writer.writeElementString('cp:lastModifiedBy', 'Stimulsoft Reports');
            writer.writeElementString('cp:revision', '1');
            writer.writeStartElement('dcterms:created');
            writer.writeAttributeString('xsi:type', 'dcterms:W3CDTF');
            writer.writeString(dateTime);
            writer.writeEndElement();
            writer.writeStartElement('dcterms:modified');
            writer.writeAttributeString('xsi:type', 'dcterms:W3CDTF');
            writer.writeString(dateTime);
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeTableStyles() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('a:tblStyleLst');
            writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
            writer.writeAttributeString('def', '{5C22544A-7EE6-4342-B048-85BDC9FD1C3A}');
            writer.writeEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writePresProps() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('p:presentationPr');
            writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:p', 'http://schemas.openxmlformats.org/presentationml/2006/main');
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeViewProps() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('p:viewPr');
            writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:p', 'http://schemas.openxmlformats.org/presentationml/2006/main');
            writer.writeStartElement('p:normalViewPr');
            writer.writeAttributeString('showOutlineIcons', '0');
            writer.writeStartElement('p:restoredLeft');
            writer.writeAttributeString('sz', '15591');
            writer.writeAttributeString('autoAdjust', '0');
            writer.writeEndElement();
            writer.writeStartElement('p:restoredTop');
            writer.writeAttributeString('sz', '94675');
            writer.writeAttributeString('autoAdjust', '0');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('p:slideViewPr');
            writer.writeStartElement('p:cSldViewPr');
            writer.writeStartElement('p:cViewPr');
            writer.writeAttributeString('varScale', '1');
            writer.writeStartElement('p:scale');
            writer.writeStartElement('a:sx');
            writer.writeAttributeString('n', '107');
            writer.writeAttributeString('d', '100');
            writer.writeEndElement();
            writer.writeStartElement('a:sy');
            writer.writeAttributeString('n', '107');
            writer.writeAttributeString('d', '100');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('p:origin');
            writer.writeAttributeString('x', '-1098');
            writer.writeAttributeString('y', '-84');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('p:guideLst');
            writer.writeStartElement('p:guide');
            writer.writeAttributeString('orient', 'horz');
            writer.writeAttributeString('pos', '2160');
            writer.writeEndElement();
            writer.writeStartElement('p:guide');
            writer.writeAttributeString('pos', '2880');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('p:notesTextViewPr');
            writer.writeStartElement('p:cViewPr');
            writer.writeStartElement('p:scale');
            writer.writeStartElement('a:sx');
            writer.writeAttributeString('n', '100');
            writer.writeAttributeString('d', '100');
            writer.writeEndElement();
            writer.writeStartElement('a:sy');
            writer.writeAttributeString('n', '100');
            writer.writeAttributeString('d', '100');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('p:origin');
            writer.writeAttributeString('x', '0');
            writer.writeAttributeString('y', '0');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('p:gridSpacing');
            writer.writeAttributeString('cx', '73736200');
            writer.writeAttributeString('cy', '73736200');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeTheme() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            let data = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000" /></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF" /></a:lt1><a:dk2><a:srgbClr val="1F497D" /></a:dk2><a:lt2><a:srgbClr val="EEECE1" /></a:lt2><a:accent1><a:srgbClr val="4F81BD" /></a:accent1><a:accent2><a:srgbClr val="C0504D" /></a:accent2><a:accent3><a:srgbClr val="9BBB59" /></a:accent3><a:accent4>' + '<a:srgbClr val="8064A2" /></a:accent4><a:accent5><a:srgbClr val="4BACC6" /></a:accent5><a:accent6><a:srgbClr val="F79646" /></a:accent6><a:hlink><a:srgbClr val="0000FF" /></a:hlink><a:folHlink><a:srgbClr val="800080" /></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri" /><a:ea typeface="" /><a:cs typeface="" /><a:font script="Jpan" typeface="ＭＳ Ｐゴシック" /><a:font script="Hang" typeface="맑은 고딕" /><a:font script="Hans" typeface="宋体" /><a:font script="Hant" typeface="新細明體" />' + '<a:font script="Arab" typeface="Times New Roman" /><a:font script="Hebr" typeface="Times New Roman" /><a:font script="Thai" typeface="Angsana New" /><a:font script="Ethi" typeface="Nyala" /><a:font script="Beng" typeface="Vrinda" /><a:font script="Gujr" typeface="Shruti" /><a:font script="Khmr" typeface="MoolBoran" /><a:font script="Knda" typeface="Tunga" /><a:font script="Guru" typeface="Raavi" /><a:font script="Cans" typeface="Euphemia" /><a:font script="Cher" typeface="Plantagenet Cherokee" /><a:font script="Yiii" typeface="Microsoft Yi Baiti" />' + '<a:font script="Tibt" typeface="Microsoft Himalaya" /><a:font script="Thaa" typeface="MV Boli" /><a:font script="Deva" typeface="Mangal" /><a:font script="Telu" typeface="Gautami" /><a:font script="Taml" typeface="Latha" /><a:font script="Syrc" typeface="Estrangelo Edessa" /><a:font script="Orya" typeface="Kalinga" /><a:font script="Mlym" typeface="Kartika" /><a:font script="Laoo" typeface="DokChampa" /><a:font script="Sinh" typeface="Iskoola Pota" /><a:font script="Mong" typeface="Mongolian Baiti" /><a:font script="Viet" typeface="Times New Roman" />' + '<a:font script="Uigh" typeface="Microsoft Uighur" /></a:majorFont><a:minorFont><a:latin typeface="Calibri" /><a:ea typeface="" /><a:cs typeface="" /><a:font script="Jpan" typeface="ＭＳ Ｐゴシック" /><a:font script="Hang" typeface="맑은 고딕" /><a:font script="Hans" typeface="宋体" /><a:font script="Hant" typeface="新細明體" /><a:font script="Arab" typeface="Arial" /><a:font script="Hebr" typeface="Arial" /><a:font script="Thai" typeface="Cordia New" /><a:font script="Ethi" typeface="Nyala" /><a:font script="Beng" typeface="Vrinda" />' + '<a:font script="Gujr" typeface="Shruti" /><a:font script="Khmr" typeface="DaunPenh" /><a:font script="Knda" typeface="Tunga" /><a:font script="Guru" typeface="Raavi" /><a:font script="Cans" typeface="Euphemia" /><a:font script="Cher" typeface="Plantagenet Cherokee" /><a:font script="Yiii" typeface="Microsoft Yi Baiti" /><a:font script="Tibt" typeface="Microsoft Himalaya" /><a:font script="Thaa" typeface="MV Boli" /><a:font script="Deva" typeface="Mangal" /><a:font script="Telu" typeface="Gautami" /><a:font script="Taml" typeface="Latha" />' + '<a:font script="Syrc" typeface="Estrangelo Edessa" /><a:font script="Orya" typeface="Kalinga" /><a:font script="Mlym" typeface="Kartika" /><a:font script="Laoo" typeface="DokChampa" /><a:font script="Sinh" typeface="Iskoola Pota" /><a:font script="Mong" typeface="Mongolian Baiti" /><a:font script="Viet" typeface="Arial" /><a:font script="Uigh" typeface="Microsoft Uighur" /></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr" /></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0">' + '<a:schemeClr val="phClr"><a:tint val="50000" /><a:satMod val="300000" /></a:schemeClr></a:gs><a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000" /><a:satMod val="300000" /></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000" /><a:satMod val="350000" /></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="1" /></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:shade val="51000" /><a:satMod val="130000" /></a:schemeClr></a:gs><a:gs pos="80000"><a:schemeClr val="phClr">' + '<a:shade val="93000" /><a:satMod val="130000" /></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="94000" /><a:satMod val="135000" /></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="0" /></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000" /><a:satMod val="105000" /></a:schemeClr></a:solidFill><a:prstDash val="solid" /></a:ln><a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr" /></a:solidFill>' + '<a:prstDash val="solid" /></a:ln><a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr" /></a:solidFill><a:prstDash val="solid" /></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000" /></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000" /></a:srgbClr></a:outerShdw></a:effectLst>' + '</a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000" /></a:srgbClr></a:outerShdw></a:effectLst><a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0" /></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000" /></a:lightRig></a:scene3d><a:sp3d><a:bevelT w="63500" h="25400" /></a:sp3d></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr" /></a:solidFill><a:gradFill rotWithShape="1">' + '<a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000" /><a:satMod val="350000" /></a:schemeClr></a:gs><a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000" /><a:shade val="99000" /><a:satMod val="350000" /></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000" /><a:satMod val="255000" /></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000" /></a:path></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000" /><a:satMod val="300000" /></a:schemeClr>' + '</a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000" /><a:satMod val="200000" /></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000" /></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults /><a:extraClrSchemeLst /></a:theme>';
            writer.writeRaw(data);
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeSlideMasterRels() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            for (let index = 0; index < 11; index++) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', index + 1));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout');
                writer.writeAttributeString('Target', StiString.format('../slideLayouts/slideLayout{0}.xml', index + 1));
                writer.writeEndElement();
            }
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId12');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme');
            writer.writeAttributeString('Target', '../theme/theme1.xml');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeSlideMaster() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            let data = '<p:sldMaster xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:cSld><p:bg><p:bgRef idx="1001"><a:schemeClr val="bg1" /></p:bgRef></p:bg><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" />' + '<a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title Placeholder 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="457200" y="274638" /><a:ext cx="8229600" cy="1143000" /></a:xfrm><a:prstGeom prst="rect"><a:avLst /></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="ctr">' + '<a:normAutofit /></a:bodyPr><a:lstStyle /><a:p><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Text Placeholder 2" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="body" idx="1" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="457200" y="1600200" /><a:ext cx="8229600" cy="4525963" /></a:xfrm><a:prstGeom prst="rect">' + '<a:avLst /></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"><a:normAutofit /></a:bodyPr><a:lstStyle /><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2" /><a:r><a:rPr lang="en-US" smtClean="0" />' + '<a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fifth level</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Date Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="2" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm>' + '<a:off x="457200" y="6356350" /><a:ext cx="2133600" cy="365125" /></a:xfrm><a:prstGeom prst="rect"><a:avLst /></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="ctr" /><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="1200"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl1pPr></a:lstStyle><a:p>' + '<a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" /><a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Footer Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="3" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="3124200" y="6356350" /><a:ext cx="2895600" cy="365125" /></a:xfrm>' + '<a:prstGeom prst="rect"><a:avLst /></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="ctr" /><a:lstStyle><a:lvl1pPr algn="ctr"><a:defRPr sz="1200"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Slide Number Placeholder 5" />' + '<p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="4" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="6553200" y="6356350" /><a:ext cx="2133600" cy="365125" /></a:xfrm><a:prstGeom prst="rect"><a:avLst /></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="ctr" /><a:lstStyle><a:lvl1pPr algn="r"><a:defRPr sz="1200"><a:solidFill><a:schemeClr val="tx1">' + '<a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl1pPr></a:lstStyle><a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld><p:clrMap bg1="lt1" tx1="dk1" bg2="lt2" tx2="dk2" accent1="accent1" accent2="accent2" accent3="accent3" accent4="accent4" accent5="accent5" accent6="accent6" hlink="hlink" folHlink="folHlink" />' + '<p:sldLayoutIdLst><p:sldLayoutId id="2147483649" r:id="rId1" /><p:sldLayoutId id="2147483650" r:id="rId2" /><p:sldLayoutId id="2147483651" r:id="rId3" /><p:sldLayoutId id="2147483652" r:id="rId4" /><p:sldLayoutId id="2147483653" r:id="rId5" /><p:sldLayoutId id="2147483654" r:id="rId6" /><p:sldLayoutId id="2147483655" r:id="rId7" /><p:sldLayoutId id="2147483656" r:id="rId8" /><p:sldLayoutId id="2147483657" r:id="rId9" /><p:sldLayoutId id="2147483658" r:id="rId10" />' + '<p:sldLayoutId id="2147483659" r:id="rId11" /></p:sldLayoutIdLst><p:txStyles><p:titleStyle><a:lvl1pPr algn="ctr" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="0" /></a:spcBef><a:buNone /><a:defRPr sz="4400" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mj-lt" /><a:ea typeface="+mj-ea" /><a:cs typeface="+mj-cs" /></a:defRPr></a:lvl1pPr></p:titleStyle><p:bodyStyle>' + '<a:lvl1pPr marL="342900" indent="-342900" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000" /></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0" /><a:buChar char="•" /><a:defRPr sz="3200" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl1pPr>' + '<a:lvl2pPr marL="742950" indent="-285750" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000" /></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0" /><a:buChar char="–" /><a:defRPr sz="2800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl2pPr>' + '<a:lvl3pPr marL="1143000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000" /></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0" /><a:buChar char="•" /><a:defRPr sz="2400" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl3pPr>' + '<a:lvl4pPr marL="1600200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000" /></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0" /><a:buChar char="–" /><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl4pPr>' + '<a:lvl5pPr marL="2057400" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000" /></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0" /><a:buChar char="»" /><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl5pPr>' + '<a:lvl6pPr marL="2514600" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000" /></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0" /><a:buChar char="•" /><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl6pPr>' + '<a:lvl7pPr marL="2971800" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000" /></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0" /><a:buChar char="•" /><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl7pPr>' + '<a:lvl8pPr marL="3429000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000" /></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0" /><a:buChar char="•" /><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl8pPr>' + '<a:lvl9pPr marL="3886200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000" /></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0" /><a:buChar char="•" /><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl9pPr>' + '</p:bodyStyle><p:otherStyle><a:defPPr><a:defRPr lang="ru-RU" /></a:defPPr><a:lvl1pPr marL="0" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl1pPr><a:lvl2pPr marL="457200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1">' + '<a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl2pPr><a:lvl3pPr marL="914400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl3pPr>' + '<a:lvl4pPr marL="1371600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl4pPr><a:lvl5pPr marL="1828800" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill>' + '<a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl5pPr><a:lvl6pPr marL="2286000" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl6pPr>' + '<a:lvl7pPr marL="2743200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl7pPr><a:lvl8pPr marL="3200400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill>' + '<a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl8pPr><a:lvl9pPr marL="3657600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1" /></a:solidFill><a:latin typeface="+mn-lt" /><a:ea typeface="+mn-ea" /><a:cs typeface="+mn-cs" /></a:defRPr></a:lvl9pPr></p:otherStyle></p:txStyles></p:sldMaster>';
            writer.writeRaw(data);
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeSlideLayoutRels() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId1');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster');
            writer.writeAttributeString('Target', '../slideMasters/slideMaster1.xml');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeSlideLayout(index, page) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('p:sldLayout');
            writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:p', 'http://schemas.openxmlformats.org/presentationml/2006/main');
            if (index == 1) {
                writer.writeAttributeString('type', 'title');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Title Slide"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ctrTitle" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="685800" y="2130425" /><a:ext cx="7772400" cy="1470025" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Subtitle 2" />' + '<p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="subTitle" idx="1" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="1371600" y="3886200" /><a:ext cx="6400800" cy="1752600" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr marL="0" indent="0" algn="ctr"><a:buNone /><a:defRPr><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl1pPr><a:lvl2pPr marL="457200" indent="0" algn="ctr"><a:buNone /><a:defRPr><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl2pPr><a:lvl3pPr marL="914400" indent="0" algn="ctr"><a:buNone /><a:defRPr><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" />' + '</a:schemeClr></a:solidFill></a:defRPr></a:lvl3pPr><a:lvl4pPr marL="1371600" indent="0" algn="ctr"><a:buNone /><a:defRPr><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl4pPr><a:lvl5pPr marL="1828800" indent="0" algn="ctr"><a:buNone /><a:defRPr><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl5pPr><a:lvl6pPr marL="2286000" indent="0" algn="ctr"><a:buNone /><a:defRPr><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl6pPr><a:lvl7pPr marL="2743200" indent="0" algn="ctr"><a:buNone /><a:defRPr><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" />' + '</a:schemeClr></a:solidFill></a:defRPr></a:lvl7pPr><a:lvl8pPr marL="3200400" indent="0" algn="ctr"><a:buNone /><a:defRPr><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl8pPr><a:lvl9pPr marL="3657600" indent="0" algn="ctr"><a:buNone /><a:defRPr><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl9pPr></a:lstStyle><a:p><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master subtitle style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Date Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr>' + '<p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" /><a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Footer Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Slide Number Placeholder 5" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr>' + '<p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            if (index == 2) {
                writer.writeAttributeString('type', 'obj');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Title and Content"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Content Placeholder 2" />' + '<p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph idx="1" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fifth level</a:t></a:r>' + '<a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Date Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" /><a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Footer Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr>' + '<p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Slide Number Placeholder 5" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            if (index == 3) {
                writer.writeAttributeString('type', 'secHead');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Section Header"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="722313" y="4406900" /><a:ext cx="7772400" cy="1362075" /></a:xfrm></p:spPr><p:txBody><a:bodyPr anchor="t" /><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="4000" b="1" cap="all" /></a:lvl1pPr></a:lstStyle><a:p><a:r>' + '<a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Text Placeholder 2" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="body" idx="1" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="722313" y="2906713" /><a:ext cx="7772400" cy="1500187" /></a:xfrm></p:spPr><p:txBody><a:bodyPr anchor="b" /><a:lstStyle><a:lvl1pPr marL="0" indent="0"><a:buNone /><a:defRPr sz="2000"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl1pPr><a:lvl2pPr marL="457200" indent="0"><a:buNone />' + '<a:defRPr sz="1800"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl2pPr><a:lvl3pPr marL="914400" indent="0"><a:buNone /><a:defRPr sz="1600"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl3pPr><a:lvl4pPr marL="1371600" indent="0"><a:buNone /><a:defRPr sz="1400"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl4pPr><a:lvl5pPr marL="1828800" indent="0"><a:buNone /><a:defRPr sz="1400"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl5pPr>' + '<a:lvl6pPr marL="2286000" indent="0"><a:buNone /><a:defRPr sz="1400"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl6pPr><a:lvl7pPr marL="2743200" indent="0"><a:buNone /><a:defRPr sz="1400"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl7pPr><a:lvl8pPr marL="3200400" indent="0"><a:buNone /><a:defRPr sz="1400"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl8pPr><a:lvl9pPr marL="3657600" indent="0"><a:buNone /><a:defRPr sz="1400"><a:solidFill><a:schemeClr val="tx1"><a:tint val="75000" /></a:schemeClr></a:solidFill></a:defRPr></a:lvl9pPr></a:lstStyle>' + '<a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Date Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" /><a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Footer Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr>' + '<p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Slide Number Placeholder 5" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            if (index == 4) {
                writer.writeAttributeString('type', 'twoObj');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Two Content"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Content Placeholder 2" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr>' + '<p:nvPr><p:ph sz="half" idx="1" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="457200" y="1600200" /><a:ext cx="4038600" cy="4525963" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr><a:defRPr sz="2800" /></a:lvl1pPr><a:lvl2pPr><a:defRPr sz="2400" /></a:lvl2pPr><a:lvl3pPr><a:defRPr sz="2000" /></a:lvl3pPr><a:lvl4pPr><a:defRPr sz="1800" /></a:lvl4pPr><a:lvl5pPr><a:defRPr sz="1800" /></a:lvl5pPr><a:lvl6pPr><a:defRPr sz="1800" /></a:lvl6pPr><a:lvl7pPr><a:defRPr sz="1800" /></a:lvl7pPr><a:lvl8pPr><a:defRPr sz="1800" /></a:lvl8pPr><a:lvl9pPr><a:defRPr sz="1800" /></a:lvl9pPr></a:lstStyle><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" />' + '<a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fifth level</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Content Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph sz="half" idx="2" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="4648200" y="1600200" />' + '<a:ext cx="4038600" cy="4525963" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr><a:defRPr sz="2800" /></a:lvl1pPr><a:lvl2pPr><a:defRPr sz="2400" /></a:lvl2pPr><a:lvl3pPr><a:defRPr sz="2000" /></a:lvl3pPr><a:lvl4pPr><a:defRPr sz="1800" /></a:lvl4pPr><a:lvl5pPr><a:defRPr sz="1800" /></a:lvl5pPr><a:lvl6pPr><a:defRPr sz="1800" /></a:lvl6pPr><a:lvl7pPr><a:defRPr sz="1800" /></a:lvl7pPr><a:lvl8pPr><a:defRPr sz="1800" /></a:lvl8pPr><a:lvl9pPr><a:defRPr sz="1800" /></a:lvl9pPr></a:lstStyle><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1" /><a:r><a:rPr lang="en-US" smtClean="0" />' + '<a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fifth level</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Date Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" />' + '<a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Footer Placeholder 5" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="7" name="Slide Number Placeholder 6" />' + '<p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            if (index == 5) {
                writer.writeAttributeString('type', 'twoTxTwoObj');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Comparison"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr><a:defRPr /></a:lvl1pPr></a:lstStyle><a:p><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Text Placeholder 2" />' + '<p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="body" idx="1" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="457200" y="1535113" /><a:ext cx="4040188" cy="639762" /></a:xfrm></p:spPr><p:txBody><a:bodyPr anchor="b" /><a:lstStyle><a:lvl1pPr marL="0" indent="0"><a:buNone /><a:defRPr sz="2400" b="1" /></a:lvl1pPr><a:lvl2pPr marL="457200" indent="0"><a:buNone /><a:defRPr sz="2000" b="1" /></a:lvl2pPr><a:lvl3pPr marL="914400" indent="0"><a:buNone /><a:defRPr sz="1800" b="1" /></a:lvl3pPr><a:lvl4pPr marL="1371600" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl4pPr><a:lvl5pPr marL="1828800" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl5pPr>' + '<a:lvl6pPr marL="2286000" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl6pPr><a:lvl7pPr marL="2743200" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl7pPr><a:lvl8pPr marL="3200400" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl8pPr><a:lvl9pPr marL="3657600" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl9pPr></a:lstStyle><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Content Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph sz="half" idx="2" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="457200" y="2174875" />' + '<a:ext cx="4040188" cy="3951288" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr><a:defRPr sz="2400" /></a:lvl1pPr><a:lvl2pPr><a:defRPr sz="2000" /></a:lvl2pPr><a:lvl3pPr><a:defRPr sz="1800" /></a:lvl3pPr><a:lvl4pPr><a:defRPr sz="1600" /></a:lvl4pPr><a:lvl5pPr><a:defRPr sz="1600" /></a:lvl5pPr><a:lvl6pPr><a:defRPr sz="1600" /></a:lvl6pPr><a:lvl7pPr><a:defRPr sz="1600" /></a:lvl7pPr><a:lvl8pPr><a:defRPr sz="1600" /></a:lvl8pPr><a:lvl9pPr><a:defRPr sz="1600" /></a:lvl9pPr></a:lstStyle><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1" /><a:r>' + '<a:rPr lang="en-US" smtClean="0" /><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fifth level</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Text Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="body" sz="quarter" idx="3" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="4645025" y="1535113" /><a:ext cx="4041775" cy="639762" /></a:xfrm></p:spPr>' + '<p:txBody><a:bodyPr anchor="b" /><a:lstStyle><a:lvl1pPr marL="0" indent="0"><a:buNone /><a:defRPr sz="2400" b="1" /></a:lvl1pPr><a:lvl2pPr marL="457200" indent="0"><a:buNone /><a:defRPr sz="2000" b="1" /></a:lvl2pPr><a:lvl3pPr marL="914400" indent="0"><a:buNone /><a:defRPr sz="1800" b="1" /></a:lvl3pPr><a:lvl4pPr marL="1371600" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl4pPr><a:lvl5pPr marL="1828800" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl5pPr><a:lvl6pPr marL="2286000" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl6pPr><a:lvl7pPr marL="2743200" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl7pPr><a:lvl8pPr marL="3200400" indent="0">' + '<a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl8pPr><a:lvl9pPr marL="3657600" indent="0"><a:buNone /><a:defRPr sz="1600" b="1" /></a:lvl9pPr></a:lstStyle><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Content Placeholder 5" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph sz="quarter" idx="4" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="4645025" y="2174875" /><a:ext cx="4041775" cy="3951288" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr><a:defRPr sz="2400" /></a:lvl1pPr><a:lvl2pPr><a:defRPr sz="2000" /></a:lvl2pPr>' + '<a:lvl3pPr><a:defRPr sz="1800" /></a:lvl3pPr><a:lvl4pPr><a:defRPr sz="1600" /></a:lvl4pPr><a:lvl5pPr><a:defRPr sz="1600" /></a:lvl5pPr><a:lvl6pPr><a:defRPr sz="1600" /></a:lvl6pPr><a:lvl7pPr><a:defRPr sz="1600" /></a:lvl7pPr><a:lvl8pPr><a:defRPr sz="1600" /></a:lvl8pPr><a:lvl9pPr><a:defRPr sz="1600" /></a:lvl9pPr></a:lstStyle><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3" /><a:r>' + '<a:rPr lang="en-US" smtClean="0" /><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fifth level</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="7" name="Date Placeholder 6" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" /><a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="8" name="Footer Placeholder 7" />' + '<p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="9" name="Slide Number Placeholder 8" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            if (index == 6) {
                writer.writeAttributeString('type', 'titleOnly');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Title Only"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Date Placeholder 2" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr>' + '<p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" /><a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Footer Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Slide Number Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr>' + '<p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            if (index == 7) {
                writer.writeAttributeString('type', 'blank');
                writer.writeAttributeString('preserve', '1');
                writer.writeStartElement('p:cSld');
                writer.writeAttributeString('name', 'Blank');
                writer.writeStartElement('p:spTree');
                writer.writeStartElement('p:nvGrpSpPr');
                writer.writeStartElement('p:cNvPr');
                writer.writeAttributeString('id', '1');
                writer.writeAttributeString('name', '');
                writer.writeEndElement();
                writer.writeStartElement('p:cNvGrpSpPr');
                writer.writeEndElement();
                writer.writeStartElement('p:nvPr');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:grpSpPr');
                writer.writeStartElement('a:xfrm');
                writer.writeStartElement('a:off');
                writer.writeAttributeString('x', '0');
                writer.writeAttributeString('y', '0');
                writer.writeEndElement();
                writer.writeStartElement('a:ext');
                writer.writeAttributeString('cx', '0');
                writer.writeAttributeString('cy', '0');
                writer.writeEndElement();
                writer.writeStartElement('a:chOff');
                writer.writeAttributeString('x', '0');
                writer.writeAttributeString('y', '0');
                writer.writeEndElement();
                writer.writeStartElement('a:chExt');
                writer.writeAttributeString('cx', '0');
                writer.writeAttributeString('cy', '0');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:sp');
                writer.writeStartElement('p:nvSpPr');
                writer.writeStartElement('p:cNvPr');
                writer.writeAttributeString('id', '2');
                writer.writeAttributeString('name', 'Date Placeholder 1');
                writer.writeEndElement();
                writer.writeStartElement('p:cNvSpPr');
                writer.writeStartElement('a:spLocks');
                writer.writeAttributeString('noGrp', '1');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:nvPr');
                writer.writeStartElement('p:ph');
                writer.writeAttributeString('type', 'dt');
                writer.writeAttributeString('sz', 'half');
                writer.writeAttributeString('idx', '10');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:spPr');
                writer.writeEndElement();
                writer.writeStartElement('p:txBody');
                writer.writeStartElement('a:bodyPr');
                writer.writeEndElement();
                writer.writeStartElement('a:lstStyle');
                writer.writeEndElement();
                writer.writeStartElement('a:p');
                writer.writeStartElement('a:fld');
                writer.writeAttributeString('id', '{BBCD0B08-7874-4091-A11F-B0CCB138CA98}');
                writer.writeAttributeString('type', 'datetimeFigureOut');
                writer.writeStartElement('a:rPr');
                writer.writeAttributeString('lang', 'ru-RU');
                writer.writeAttributeString('smtClean', '0');
                writer.writeEndElement();
                writer.writeStartElement('a:t');
                writer.writeString('15.04.2009');
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('a:endParaRPr');
                writer.writeAttributeString('lang', 'ru-RU');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:sp');
                writer.writeStartElement('p:nvSpPr');
                writer.writeStartElement('p:cNvPr');
                writer.writeAttributeString('id', '3');
                writer.writeAttributeString('name', 'Footer Placeholder 2');
                writer.writeEndElement();
                writer.writeStartElement('p:cNvSpPr');
                writer.writeStartElement('a:spLocks');
                writer.writeAttributeString('noGrp', '1');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:nvPr');
                writer.writeStartElement('p:ph');
                writer.writeAttributeString('type', 'ftr');
                writer.writeAttributeString('sz', 'quarter');
                writer.writeAttributeString('idx', '11');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:spPr');
                writer.writeEndElement();
                writer.writeStartElement('p:txBody');
                writer.writeStartElement('a:bodyPr');
                writer.writeEndElement();
                writer.writeStartElement('a:lstStyle');
                writer.writeEndElement();
                writer.writeStartElement('a:p');
                writer.writeStartElement('a:endParaRPr');
                writer.writeAttributeString('lang', 'ru-RU');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:sp');
                writer.writeStartElement('p:nvSpPr');
                writer.writeStartElement('p:cNvPr');
                writer.writeAttributeString('id', '4');
                writer.writeAttributeString('name', 'Slide Number Placeholder 3');
                writer.writeEndElement();
                writer.writeStartElement('p:cNvSpPr');
                writer.writeStartElement('a:spLocks');
                writer.writeAttributeString('noGrp', '1');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:nvPr');
                writer.writeStartElement('p:ph');
                writer.writeAttributeString('type', 'sldNum');
                writer.writeAttributeString('sz', 'quarter');
                writer.writeAttributeString('idx', '12');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('p:spPr');
                writer.writeEndElement();
                writer.writeStartElement('p:txBody');
                writer.writeStartElement('a:bodyPr');
                writer.writeEndElement();
                writer.writeStartElement('a:lstStyle');
                writer.writeEndElement();
                writer.writeStartElement('a:p');
                writer.writeStartElement('a:fld');
                writer.writeAttributeString('id', '{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}');
                writer.writeAttributeString('type', 'slidenum');
                writer.writeStartElement('a:rPr');
                writer.writeAttributeString('lang', 'ru-RU');
                writer.writeAttributeString('smtClean', '0');
                writer.writeEndElement();
                writer.writeStartElement('a:t');
                writer.writeString('‹#›');
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('a:endParaRPr');
                writer.writeAttributeString('lang', 'ru-RU');
                writer.writeEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                    let pageWidth = page.unit.convertToHInches(page.pageWidth - page.margins.left - page.margins.right);
                    let pageHeight = page.unit.convertToHInches(page.pageHeight - page.margins.top - page.margins.bottom);
                    let mgLeft = page.unit.convertToHInches(page.margins.left);
                    let mgTop = page.unit.convertToHInches(page.margins.top);
                    writer.writeRaw('<p:sp><p:nvSpPr><p:cNvPr id="67" name="TextBox Additional"/><p:cNvSpPr txBox="1"/><p:nvPr userDrawn="1"/></p:nvSpPr>' + '<p:spPr><a:xfrm rot="-2700000"><a:off x="' + this.convertToEmu(mgLeft) + '" y="' + this.convertToEmu(mgTop + pageHeight * 0.45) + '"/><a:ext cx="' + this.convertToEmu(pageWidth) + '" cy="' + this.convertToEmu(pageHeight * 0.1) + '"/></a:xfrm>' + '<a:prstGeom prst="rect"><a:avLst/></a:prstGeom><a:noFill/></p:spPr>' + '<p:txBody><a:bodyPr wrap="square" rtlCol="0" anchor="ctr" anchorCtr="0"><a:spAutoFit/></a:bodyPr><a:lstStyle/><a:p><a:pPr algn="ctr"/><a:r><a:rPr lang="en-US" sz="9600" b="1" dirty="0" smtClean="0">' + '<a:solidFill><a:schemeClr val="tx1"><a:alpha val="12000"/></a:schemeClr></a:solidFill>' + '<a:latin typeface="Arial" panose="020B0604020202020204" pitchFamily="34" charset="0"/><a:cs typeface="Arial" panose="020B0604020202020204" pitchFamily="34" charset="0"/>' + '</a:rPr><a:t>Trial</a:t></a:r></a:p></p:txBody></p:sp>');
                }
                writer.writeFullEndElement();
                writer.writeFullEndElement();
            }
            if (index == 8) {
                writer.writeAttributeString('type', 'objTx');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Content with Caption"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="457200" y="273050" /><a:ext cx="3008313" cy="1162050" /></a:xfrm></p:spPr><p:txBody><a:bodyPr anchor="b" /><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="2000" b="1" /></a:lvl1pPr></a:lstStyle><a:p><a:r><a:rPr lang="en-US" smtClean="0" />' + '<a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Content Placeholder 2" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph idx="1" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="3575050" y="273050" /><a:ext cx="5111750" cy="5853113" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr><a:defRPr sz="3200" /></a:lvl1pPr><a:lvl2pPr><a:defRPr sz="2800" /></a:lvl2pPr><a:lvl3pPr><a:defRPr sz="2400" /></a:lvl3pPr><a:lvl4pPr><a:defRPr sz="2000" /></a:lvl4pPr><a:lvl5pPr><a:defRPr sz="2000" /></a:lvl5pPr><a:lvl6pPr><a:defRPr sz="2000" /></a:lvl6pPr><a:lvl7pPr>' + '<a:defRPr sz="2000" /></a:lvl7pPr><a:lvl8pPr><a:defRPr sz="2000" /></a:lvl8pPr><a:lvl9pPr><a:defRPr sz="2000" /></a:lvl9pPr></a:lstStyle><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fifth level</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp>' + '<p:sp><p:nvSpPr><p:cNvPr id="4" name="Text Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="body" sz="half" idx="2" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="457200" y="1435100" /><a:ext cx="3008313" cy="4691063" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr marL="0" indent="0"><a:buNone /><a:defRPr sz="1400" /></a:lvl1pPr><a:lvl2pPr marL="457200" indent="0"><a:buNone /><a:defRPr sz="1200" /></a:lvl2pPr><a:lvl3pPr marL="914400" indent="0"><a:buNone /><a:defRPr sz="1000" /></a:lvl3pPr><a:lvl4pPr marL="1371600" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl4pPr><a:lvl5pPr marL="1828800" indent="0">' + '<a:buNone /><a:defRPr sz="900" /></a:lvl5pPr><a:lvl6pPr marL="2286000" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl6pPr><a:lvl7pPr marL="2743200" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl7pPr><a:lvl8pPr marL="3200400" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl8pPr><a:lvl9pPr marL="3657600" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl9pPr></a:lstStyle><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Date Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr><p:spPr />' + '<p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" /><a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Footer Placeholder 5" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="7" name="Slide Number Placeholder 6" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr><p:spPr />' + '<p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            if (index == 9) {
                writer.writeAttributeString('type', 'picTx');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Picture with Caption"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="1792288" y="4800600" /><a:ext cx="5486400" cy="566738" /></a:xfrm></p:spPr><p:txBody><a:bodyPr anchor="b" /><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="2000" b="1" /></a:lvl1pPr></a:lstStyle><a:p><a:r><a:rPr lang="en-US" smtClean="0" />' + '<a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Picture Placeholder 2" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="pic" idx="1" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="1792288" y="612775" /><a:ext cx="5486400" cy="4114800" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr marL="0" indent="0"><a:buNone /><a:defRPr sz="3200" /></a:lvl1pPr><a:lvl2pPr marL="457200" indent="0"><a:buNone /><a:defRPr sz="2800" /></a:lvl2pPr><a:lvl3pPr marL="914400" indent="0"><a:buNone /><a:defRPr sz="2400" /></a:lvl3pPr>' + '<a:lvl4pPr marL="1371600" indent="0"><a:buNone /><a:defRPr sz="2000" /></a:lvl4pPr><a:lvl5pPr marL="1828800" indent="0"><a:buNone /><a:defRPr sz="2000" /></a:lvl5pPr><a:lvl6pPr marL="2286000" indent="0"><a:buNone /><a:defRPr sz="2000" /></a:lvl6pPr><a:lvl7pPr marL="2743200" indent="0"><a:buNone /><a:defRPr sz="2000" /></a:lvl7pPr><a:lvl8pPr marL="3200400" indent="0"><a:buNone /><a:defRPr sz="2000" /></a:lvl8pPr><a:lvl9pPr marL="3657600" indent="0"><a:buNone /><a:defRPr sz="2000" /></a:lvl9pPr></a:lstStyle><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Text Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr>' + '<p:nvPr><p:ph type="body" sz="half" idx="2" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="1792288" y="5367338" /><a:ext cx="5486400" cy="804862" /></a:xfrm></p:spPr><p:txBody><a:bodyPr /><a:lstStyle><a:lvl1pPr marL="0" indent="0"><a:buNone /><a:defRPr sz="1400" /></a:lvl1pPr><a:lvl2pPr marL="457200" indent="0"><a:buNone /><a:defRPr sz="1200" /></a:lvl2pPr><a:lvl3pPr marL="914400" indent="0"><a:buNone /><a:defRPr sz="1000" /></a:lvl3pPr><a:lvl4pPr marL="1371600" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl4pPr><a:lvl5pPr marL="1828800" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl5pPr><a:lvl6pPr marL="2286000" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl6pPr>' + '<a:lvl7pPr marL="2743200" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl7pPr><a:lvl8pPr marL="3200400" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl8pPr><a:lvl9pPr marL="3657600" indent="0"><a:buNone /><a:defRPr sz="900" /></a:lvl9pPr></a:lstStyle><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Date Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut">' + '<a:rPr lang="ru-RU" smtClean="0" /><a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Footer Placeholder 5" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="7" name="Slide Number Placeholder 6" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle />' + '<a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            if (index == 10) {
                writer.writeAttributeString('type', 'vertTx');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Title and Vertical Text"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr>' + '<p:cNvPr id="3" name="Vertical Text Placeholder 2" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="body" orient="vert" idx="1" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr vert="eaVert" /><a:lstStyle /><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4" />' + '<a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fifth level</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Date Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" /><a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Footer Placeholder 4" /><p:cNvSpPr>' + '<a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Slide Number Placeholder 5" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            if (index == 11) {
                writer.writeAttributeString('type', 'vertTitleAndTx');
                writer.writeAttributeString('preserve', '1');
                let data = '<p:cSld name="Vertical Title and Text"><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name="" /><p:cNvGrpSpPr /><p:nvPr /></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0" /><a:ext cx="0" cy="0" /><a:chOff x="0" y="0" /><a:chExt cx="0" cy="0" /></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Vertical Title 1" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="title" orient="vert" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="6629400" y="274638" /><a:ext cx="2057400" cy="5851525" /></a:xfrm></p:spPr><p:txBody><a:bodyPr vert="eaVert" /><a:lstStyle /><a:p><a:r><a:rPr lang="en-US" smtClean="0" />' + '<a:t>Click to edit Master title style</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Vertical Text Placeholder 2" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="body" orient="vert" idx="1" /></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="457200" y="274638" /><a:ext cx="6019800" cy="5851525" /></a:xfrm></p:spPr><p:txBody><a:bodyPr vert="eaVert" /><a:lstStyle /><a:p><a:pPr lvl="0" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Second level</a:t></a:r></a:p><a:p>' + '<a:pPr lvl="2" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4" /><a:r><a:rPr lang="en-US" smtClean="0" /><a:t>Fifth level</a:t></a:r><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Date Placeholder 3" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="dt" sz="half" idx="10" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:fld id="{BBCD0B08-7874-4091-A11F-B0CCB138CA98}" type="datetimeFigureOut"><a:rPr lang="ru-RU" smtClean="0" />' + '<a:t>15.04.2009</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Footer Placeholder 4" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="11" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle /><a:p><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Slide Number Placeholder 5" /><p:cNvSpPr><a:spLocks noGrp="1" /></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="12" /></p:nvPr></p:nvSpPr><p:spPr /><p:txBody><a:bodyPr /><a:lstStyle />' + '<a:p><a:fld id="{F548980B-80A5-4AC9-8F15-D7D0FD0AEED9}" type="slidenum"><a:rPr lang="ru-RU" smtClean="0" /><a:t>‹#›</a:t></a:fld><a:endParaRPr lang="ru-RU" /></a:p></p:txBody></p:sp></p:spTree></p:cSld>';
                writer.writeRaw(data);
            }
            writer.writeStartElement('p:clrMapOvr');
            writer.writeStartElement('a:masterClrMapping');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writePresentationRels(allPages) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId1');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles');
            writer.writeAttributeString('Target', 'tableStyles.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId2');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/viewProps');
            writer.writeAttributeString('Target', 'viewProps.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId3');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/presProps');
            writer.writeAttributeString('Target', 'presProps.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId4');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme');
            writer.writeAttributeString('Target', 'theme/theme1.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId5');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster');
            writer.writeAttributeString('Target', 'slideMasters/slideMaster1.xml');
            writer.writeEndElement();
            for (let index = 0; index < allPages.count; index++) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', 6 + index));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide');
                writer.writeAttributeString('Target', StiString.format('slides/slide{0}.xml', index + 1));
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writePresentation(allPages) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('p:presentation');
            writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:p', 'http://schemas.openxmlformats.org/presentationml/2006/main');
            writer.writeAttributeString('saveSubsetFonts', '1');
            writer.writeStartElement('p:sldMasterIdLst');
            writer.writeStartElement('p:sldMasterId');
            writer.writeAttributeString('id', '2147483648');
            writer.writeAttributeString('r:id', 'rId5');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('p:sldIdLst');
            for (let index = 0; index < allPages.count; index++) {
                writer.writeStartElement('p:sldId');
                writer.writeAttributeString('id', StiString.format('{0}', 256 + index));
                writer.writeAttributeString('r:id', StiString.format('rId{0}', 6 + index));
                writer.writeEndElement();
            }
            writer.writeEndElement();
            let page = allPages.getByIndex(0);
            writer.writeStartElement('p:sldSz');
            writer.writeAttributeString('cx', this.convertToEmu(page.unit.convertToHInches(page.width + page.margins.left + page.margins.right)).toString());
            writer.writeAttributeString('cy', this.convertToEmu(page.unit.convertToHInches(page.height + page.margins.top + page.margins.bottom)).toString());
            writer.writeEndElement();
            writer.writeStartElement('p:notesSz');
            writer.writeAttributeString('cx', '6858000');
            writer.writeAttributeString('cy', '9144000');
            writer.writeEndElement();
            writer.writeStartElement('p:defaultTextStyle');
            writer.writeStartElement('a:defPPr');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('lang', 'ru-RU');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:lvl1pPr');
            writer.writeAttributeString('marL', '0');
            writer.writeAttributeString('algn', 'l');
            writer.writeAttributeString('defTabSz', '914400');
            writer.writeAttributeString('rtl', '0');
            writer.writeAttributeString('eaLnBrk', '1');
            writer.writeAttributeString('latinLnBrk', '0');
            writer.writeAttributeString('hangingPunct', '1');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('sz', '1800');
            writer.writeAttributeString('kern', '1200');
            writer.writeStartElement('a:solidFill');
            writer.writeStartElement('a:schemeClr');
            writer.writeAttributeString('val', 'tx1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', '+mn-lt');
            writer.writeEndElement();
            writer.writeStartElement('a:ea');
            writer.writeAttributeString('typeface', '+mn-ea');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', '+mn-cs');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:lvl2pPr');
            writer.writeAttributeString('marL', '457200');
            writer.writeAttributeString('algn', 'l');
            writer.writeAttributeString('defTabSz', '914400');
            writer.writeAttributeString('rtl', '0');
            writer.writeAttributeString('eaLnBrk', '1');
            writer.writeAttributeString('latinLnBrk', '0');
            writer.writeAttributeString('hangingPunct', '1');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('sz', '1800');
            writer.writeAttributeString('kern', '1200');
            writer.writeStartElement('a:solidFill');
            writer.writeStartElement('a:schemeClr');
            writer.writeAttributeString('val', 'tx1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', '+mn-lt');
            writer.writeEndElement();
            writer.writeStartElement('a:ea');
            writer.writeAttributeString('typeface', '+mn-ea');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', '+mn-cs');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:lvl3pPr');
            writer.writeAttributeString('marL', '914400');
            writer.writeAttributeString('algn', 'l');
            writer.writeAttributeString('defTabSz', '914400');
            writer.writeAttributeString('rtl', '0');
            writer.writeAttributeString('eaLnBrk', '1');
            writer.writeAttributeString('latinLnBrk', '0');
            writer.writeAttributeString('hangingPunct', '1');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('sz', '1800');
            writer.writeAttributeString('kern', '1200');
            writer.writeStartElement('a:solidFill');
            writer.writeStartElement('a:schemeClr');
            writer.writeAttributeString('val', 'tx1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', '+mn-lt');
            writer.writeEndElement();
            writer.writeStartElement('a:ea');
            writer.writeAttributeString('typeface', '+mn-ea');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', '+mn-cs');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:lvl4pPr');
            writer.writeAttributeString('marL', '1371600');
            writer.writeAttributeString('algn', 'l');
            writer.writeAttributeString('defTabSz', '914400');
            writer.writeAttributeString('rtl', '0');
            writer.writeAttributeString('eaLnBrk', '1');
            writer.writeAttributeString('latinLnBrk', '0');
            writer.writeAttributeString('hangingPunct', '1');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('sz', '1800');
            writer.writeAttributeString('kern', '1200');
            writer.writeStartElement('a:solidFill');
            writer.writeStartElement('a:schemeClr');
            writer.writeAttributeString('val', 'tx1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', '+mn-lt');
            writer.writeEndElement();
            writer.writeStartElement('a:ea');
            writer.writeAttributeString('typeface', '+mn-ea');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', '+mn-cs');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:lvl5pPr');
            writer.writeAttributeString('marL', '1828800');
            writer.writeAttributeString('algn', 'l');
            writer.writeAttributeString('defTabSz', '914400');
            writer.writeAttributeString('rtl', '0');
            writer.writeAttributeString('eaLnBrk', '1');
            writer.writeAttributeString('latinLnBrk', '0');
            writer.writeAttributeString('hangingPunct', '1');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('sz', '1800');
            writer.writeAttributeString('kern', '1200');
            writer.writeStartElement('a:solidFill');
            writer.writeStartElement('a:schemeClr');
            writer.writeAttributeString('val', 'tx1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', '+mn-lt');
            writer.writeEndElement();
            writer.writeStartElement('a:ea');
            writer.writeAttributeString('typeface', '+mn-ea');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', '+mn-cs');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:lvl6pPr');
            writer.writeAttributeString('marL', '2286000');
            writer.writeAttributeString('algn', 'l');
            writer.writeAttributeString('defTabSz', '914400');
            writer.writeAttributeString('rtl', '0');
            writer.writeAttributeString('eaLnBrk', '1');
            writer.writeAttributeString('latinLnBrk', '0');
            writer.writeAttributeString('hangingPunct', '1');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('sz', '1800');
            writer.writeAttributeString('kern', '1200');
            writer.writeStartElement('a:solidFill');
            writer.writeStartElement('a:schemeClr');
            writer.writeAttributeString('val', 'tx1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', '+mn-lt');
            writer.writeEndElement();
            writer.writeStartElement('a:ea');
            writer.writeAttributeString('typeface', '+mn-ea');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', '+mn-cs');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:lvl7pPr');
            writer.writeAttributeString('marL', '2743200');
            writer.writeAttributeString('algn', 'l');
            writer.writeAttributeString('defTabSz', '914400');
            writer.writeAttributeString('rtl', '0');
            writer.writeAttributeString('eaLnBrk', '1');
            writer.writeAttributeString('latinLnBrk', '0');
            writer.writeAttributeString('hangingPunct', '1');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('sz', '1800');
            writer.writeAttributeString('kern', '1200');
            writer.writeStartElement('a:solidFill');
            writer.writeStartElement('a:schemeClr');
            writer.writeAttributeString('val', 'tx1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', '+mn-lt');
            writer.writeEndElement();
            writer.writeStartElement('a:ea');
            writer.writeAttributeString('typeface', '+mn-ea');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', '+mn-cs');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:lvl8pPr');
            writer.writeAttributeString('marL', '3200400');
            writer.writeAttributeString('algn', 'l');
            writer.writeAttributeString('defTabSz', '914400');
            writer.writeAttributeString('rtl', '0');
            writer.writeAttributeString('eaLnBrk', '1');
            writer.writeAttributeString('latinLnBrk', '0');
            writer.writeAttributeString('hangingPunct', '1');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('sz', '1800');
            writer.writeAttributeString('kern', '1200');
            writer.writeStartElement('a:solidFill');
            writer.writeStartElement('a:schemeClr');
            writer.writeAttributeString('val', 'tx1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', '+mn-lt');
            writer.writeEndElement();
            writer.writeStartElement('a:ea');
            writer.writeAttributeString('typeface', '+mn-ea');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', '+mn-cs');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:lvl9pPr');
            writer.writeAttributeString('marL', '3657600');
            writer.writeAttributeString('algn', 'l');
            writer.writeAttributeString('defTabSz', '914400');
            writer.writeAttributeString('rtl', '0');
            writer.writeAttributeString('eaLnBrk', '1');
            writer.writeAttributeString('latinLnBrk', '0');
            writer.writeAttributeString('hangingPunct', '1');
            writer.writeStartElement('a:defRPr');
            writer.writeAttributeString('sz', '1800');
            writer.writeAttributeString('kern', '1200');
            writer.writeStartElement('a:solidFill');
            writer.writeStartElement('a:schemeClr');
            writer.writeAttributeString('val', 'tx1');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', '+mn-lt');
            writer.writeEndElement();
            writer.writeStartElement('a:ea');
            writer.writeAttributeString('typeface', '+mn-ea');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', '+mn-cs');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeSlideRels(indexSheet) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId1');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout');
            writer.writeAttributeString('Target', '../slideLayouts/slideLayout7.xml');
            writer.writeEndElement();
            if (this.imageCache.imageIndex.stimulsoft().countItems > this.imageListOffset) {
                for (let index = 0; index < this.imageCache.imageIndex.stimulsoft().countItems - this.imageListOffset; index++) {
                    writer.writeStartElement('Relationship');
                    writer.writeAttributeString('Id', StiString.format('rId{0}', 2 + index));
                    writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image');
                    writer.writeAttributeString('Target', StiString.format('../media/image{0:D5}.{1}', this.imageCache.imageIndex[this.imageListOffset + index] + 1, Stimulsoft['StiOptions'].Export.PowerPoint.StoreImagesAsPng ? 'png' : 'jpeg'));
                    writer.writeEndElement();
                }
            }
            if (this.hyperlinkList.stimulsoft().countItems > 0) {
                for (let index = 0; index < this.hyperlinkList.stimulsoft().countItems; index++) {
                    writer.writeStartElement('Relationship');
                    writer.writeAttributeString('Id', StiString.format('hId{0}', index + 1));
                    let link = this.hyperlinkList.stimulsoft().getByIndex(index);
                    if (typeof link == 'string') {
                        writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink');
                        writer.writeAttributeString('Target', link);
                        writer.writeAttributeString('TargetMode', 'External');
                    }
                    if (typeof link == 'number') {
                        writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide');
                        writer.writeAttributeString('Target', StiString.format('slide{0}.xml', link));
                    }
                    writer.writeEndElement();
                }
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeSlide(indexPage, allPages) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('p:sld');
            writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:p', 'http://schemas.openxmlformats.org/presentationml/2006/main');
            writer.writeStartElement('p:cSld');
            writer.writeStartElement('p:spTree');
            writer.writeStartElement('p:nvGrpSpPr');
            writer.writeStartElement('p:cNvPr');
            writer.writeAttributeString('id', '1');
            writer.writeAttributeString('name', '');
            writer.writeEndElement();
            writer.writeStartElement('p:cNvGrpSpPr');
            writer.writeEndElement();
            writer.writeStartElement('p:nvPr');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('p:grpSpPr');
            writer.writeStartElement('a:xfrm');
            writer.writeStartElement('a:off');
            writer.writeAttributeString('x', '0');
            writer.writeAttributeString('y', '0');
            writer.writeEndElement();
            writer.writeStartElement('a:ext');
            writer.writeAttributeString('cx', '0');
            writer.writeAttributeString('cy', '0');
            writer.writeEndElement();
            writer.writeStartElement('a:chOff');
            writer.writeAttributeString('x', '0');
            writer.writeAttributeString('y', '0');
            writer.writeEndElement();
            writer.writeStartElement('a:chExt');
            writer.writeAttributeString('cx', '0');
            writer.writeAttributeString('cy', '0');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            this.idCounter = 2;
            let page = allPages.getByIndex(indexPage);
            allPages.getPage(page);
            this.writeWatermark(writer, page, true);
            for (let comp of page.components.list) {
                if (comp.enabled && comp.width > 0 && comp.height > 0) {
                    let textBox = comp.stimulsoft().as(StiText);
                    if (textBox != null && !textBox.checkAllowHtmlTags()) {
                        let angle = textBox.angle % 360;
                        if (angle < 0)
                            angle = 360 + angle;
                        if (angle == 0 || angle == 90 || angle == 270) {
                            this.writeStiTextbox(writer, comp);
                        } else {
                            let tempText = textBox.clone(true);
                            tempText.text = null;
                            tempText.angle = 0;
                            this.writeStiTextbox(writer, tempText);
                            tempText = textBox.clone(true);
                            tempText.border = null;
                            tempText.brush = null;
                            tempText.horAlignment = StiTextHorAlignment.Center;
                            tempText.vertAlignment = StiVertAlignment.Center;
                            this.writeStiTextbox(writer, tempText);
                        }
                    } else {
                        if (comp.is(StiContainer)) {
                            let newText = new StiText(comp.clientRectangle);
                            newText.page = comp.page;
                            newText.border = comp.stimulsoft().as(StiContainer).border;
                            newText.brush = comp.stimulsoft().as(StiContainer).brush;
                            newText.hyperlinkValue = comp.hyperlinkValue;
                            this.writeStiTextbox(writer, newText);
                        } else {
                            this.writeStiImage(writer, comp);
                        }
                    }
                    this.idCounter++;
                }
            }
            this.writeWatermark(writer, page, false);
            if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                let pageWidth = page.unit.convertToHInches(page.pageWidth - page.margins.left - page.margins.right);
                let pageHeight = page.unit.convertToHInches(page.pageHeight - page.margins.top - page.margins.bottom);
                let mgLeft = page.unit.convertToHInches(page.margins.left);
                let mgTop = page.unit.convertToHInches(page.margins.top);
                writer.writeRaw('<p:sp><p:nvSpPr><p:cNvPr id="67" name="TextBox Additional"/><p:cNvSpPr txBox="1"/><p:nvPr userDrawn="1"/></p:nvSpPr>' + '<p:spPr><a:xfrm rot="-2700000"><a:off x="' + this.convertToEmu(mgLeft) + '" y="' + this.convertToEmu(mgTop + pageHeight * 0.45) + '"/><a:ext cx="' + this.convertToEmu(pageWidth) + '" cy="' + this.convertToEmu(pageHeight * 0.1) + '"/></a:xfrm>' + '<a:prstGeom prst="rect"><a:avLst/></a:prstGeom><a:noFill/></p:spPr>' + '<p:txBody><a:bodyPr wrap="square" rtlCol="0" anchor="ctr" anchorCtr="0"><a:spAutoFit/></a:bodyPr><a:lstStyle/><a:p><a:pPr algn="ctr"/><a:r><a:rPr lang="en-US" sz="9600" b="1" dirty="0" smtClean="0">' + '<a:solidFill><a:schemeClr val="tx1"><a:alpha val="12000"/></a:schemeClr></a:solidFill>' + '<a:latin typeface="Arial" panose="020B0604020202020204" pitchFamily="34" charset="0"/><a:cs typeface="Arial" panose="020B0604020202020204" pitchFamily="34" charset="0"/>' + '</a:rPr><a:t>Trial</a:t></a:r></a:p></p:txBody></p:sp>');
            }
            writer.writeFullEndElement();
            writer.writeEndElement();
            writer.writeStartElement('p:clrMapOvr');
            writer.writeStartElement('a:masterClrMapping');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeStiTextbox(writer, comp) {
            let stiText = comp;
            writer.writeStartElement('p:sp');
            writer.writeStartElement('p:nvSpPr');
            writer.writeStartElement('p:cNvPr');
            writer.writeAttributeString('id', StiString.format('{0}', this.idCounter));
            writer.writeAttributeString('name', StiString.format('TextBox {0}', this.idCounter));
            this.writeHyperlinkInfo(writer, comp);
            writer.writeEndElement();
            writer.writeStartElement('p:cNvSpPr');
            writer.writeAttributeString('txBox', '1');
            writer.writeEndElement();
            writer.writeStartElement('p:nvPr');
            writer.writeEndElement();
            writer.writeEndElement();
            let topmost = this.writeSpPr(writer, comp);
            writer.writeStartElement('p:txBody');
            writer.writeStartElement('a:bodyPr');
            let textWordWrap = false;
            let stTextAngle = '';
            if (stiText.textOptions != null) {
                textWordWrap = stiText.textOptions.wordWrap;
                let textAngle = stiText.textOptions.angle % 360;
                if (textAngle < 0)
                    textAngle = 360 + textAngle;
                if (textAngle == 90)
                    stTextAngle = 'vert270';
                if (textAngle == 270)
                    stTextAngle = 'vert';
            }
            if (stTextAngle.length > 0) {
                writer.writeAttributeString('vert', stTextAngle);
            }
            writer.writeAttributeString('horzOverflow', 'clip');
            writer.writeAttributeString('vertOverflow', 'clip');
            let mLeft = this.convertToEmu(stiText.margins.left);
            let mRight = this.convertToEmu(stiText.margins.right);
            let mTop = this.convertToEmu(stiText.margins.top);
            let mBottom = this.convertToEmu(stiText.margins.bottom);
            writer.writeAttributeString('lIns', StiString.format('{0}', mLeft));
            writer.writeAttributeString('tIns', StiString.format('{0}', mTop));
            writer.writeAttributeString('rIns', StiString.format('{0}', mRight));
            writer.writeAttributeString('bIns', StiString.format('{0}', mBottom));
            writer.writeAttributeString('wrap', textWordWrap ? 'square' : 'none');
            writer.writeAttributeString('rtlCol', '0');
            let vertAlign = 't';
            if (stiText.vertAlignment == StiVertAlignment.Center)
                vertAlign = 'ctr';
            if (stiText.vertAlignment == StiVertAlignment.Bottom)
                vertAlign = 'b';
            writer.writeAttributeString('anchor', vertAlign);
            writer.writeAttributeString('anchorCtr', '0');
            writer.writeStartElement('a:noAutofit');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('a:lstStyle');
            writer.writeEndElement();
            writer.writeStartElement('a:p');
            let rightToLeft = false;
            if (stiText.textOptions != null)
                rightToLeft = stiText.textOptions.rightToLeft;
            writer.writeStartElement('a:pPr');
            let horAlign = '';
            if (stiText.horAlignment == StiTextHorAlignment.Center)
                horAlign = 'ctr';
            if (stiText.horAlignment == StiTextHorAlignment.Right && !rightToLeft || stiText.horAlignment == StiTextHorAlignment.Left && rightToLeft)
                horAlign = 'r';
            if (stiText.horAlignment == StiTextHorAlignment.Width)
                horAlign = 'just';
            if (horAlign.length > 0) {
                writer.writeAttributeString('algn', horAlign);
            }
            if (rightToLeft) {
                writer.writeAttributeString('rtl', '1');
            }
            writer.writeStartElement('a:lnSpc');
            writer.writeStartElement('a:spcPct');
            writer.writeAttributeString('val', Math.round(stiText.lineSpacing * 0.94 * 100000).toString());
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('a:r');
            writer.writeStartElement('a:rPr');
            writer.writeAttributeString('lang', 'en-US');
            writer.writeAttributeString('sz', (stiText.font.sizeInPoints * 100 * 0.984 | 0).toString());
            if (stiText.font.bold)
                writer.writeAttributeString('b', '1');
            if (stiText.font.italic)
                writer.writeAttributeString('i', '1');
            if (stiText.font.underline)
                writer.writeAttributeString('u', 'sng');
            if (stiText.font.strikeout)
                writer.writeAttributeString('strike', 'sngStrike');
            writer.writeAttributeString('dirty', '0');
            writer.writeAttributeString('smtClean', '0');
            writer.writeStartElement('a:solidFill');
            this.writeColor(writer, StiBrush.toColor(stiText.textBrush));
            writer.writeFullEndElement();
            let st = '';
            if (stiText.text != null)
                st = stiText.text.toString();
            if ((stiText.textQuality == StiTextQuality.Wysiwyg || stiText.horAlignment == StiTextHorAlignment.Width) && !StiString.isNullOrEmpty(st) && st.stimulsoft().endsWith(StiTextRenderer.StiForceWidthAlignTag)) {
                st = st.substr(0, st.length - StiTextRenderer.StiForceWidthAlignTag.length);
            }
            writer.writeStartElement('a:latin');
            writer.writeAttributeString('typeface', stiText.font.name);
            writer.writeAttributeString('pitchFamily', '18');
            writer.writeAttributeString('charset', '0');
            writer.writeEndElement();
            writer.writeStartElement('a:cs');
            writer.writeAttributeString('typeface', stiText.font.name);
            writer.writeAttributeString('pitchFamily', '18');
            writer.writeAttributeString('charset', '0');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeElementString('a:t', st);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            if (topmost)
                this.writeBorder(writer, comp);
        }
        writeStiImage(writer, comp) {
            let topmost = false;
            let exportImageExtended = comp.stimulsoft().as(IStiExportImageExtended);
            if (exportImageExtended != null) {
                let image = null;
                if (comp.isExportAsImage(__.a.StiExportFormat.Ppt2007)) {
                    try {
                        CultureInfo.currentCulture = this.currentCulture;
                        let REFrsImageResolution = { ref: this.imageResolution };
                        image = exportImageExtended.getImage(REFrsImageResolution, __.a.StiExportFormat.ImagePng);
                    } finally {
                        CultureInfo.currentCulture = this.newCulture;
                    }
                }
                if (image != null) {
                    this.imageCache.addImageInt(image);
                    writer.writeStartElement('p:pic');
                    writer.writeStartElement('p:nvPicPr');
                    writer.writeStartElement('p:cNvPr');
                    writer.writeAttributeString('id', StiString.format('{0}', this.idCounter));
                    writer.writeAttributeString('name', StiString.format('Picture {0}', this.idCounter + 1));
                    writer.writeAttributeString('descr', StiString.format('Picture {0} description', this.idCounter + 1));
                    this.writeHyperlinkInfo(writer, comp);
                    writer.writeEndElement();
                    writer.writeStartElement('p:cNvPicPr');
                    writer.writeStartElement('a:picLocks');
                    writer.writeAttributeString('noChangeAspect', '1');
                    writer.writeEndElement();
                    writer.writeFullEndElement();
                    writer.writeStartElement('p:nvPr');
                    writer.writeEndElement();
                    writer.writeFullEndElement();
                    writer.writeStartElement('p:blipFill');
                    writer.writeStartElement('a:blip');
                    writer.writeAttributeString('r:embed', StiString.format('rId{0}', 1 + this.imageCache.imageIndex.stimulsoft().countItems - this.imageListOffset));
                    writer.writeEndElement();
                    writer.writeStartElement('a:stretch');
                    writer.writeStartElement('a:fillRect');
                    writer.writeEndElement();
                    writer.writeFullEndElement();
                    writer.writeFullEndElement();
                    topmost = this.writeSpPr(writer, comp);
                    writer.writeFullEndElement();
                }
            }
            if (topmost || comp.is(StiLinePrimitive))
                this.writeBorder(writer, comp);
        }
        writeSpPr(writer, comp) {
            let x1 = this.convertToEmu(comp.report.unit.convertToHInches(comp.left + comp.page.margins.left));
            let y1 = this.convertToEmu(comp.report.unit.convertToHInches(comp.top + comp.page.margins.top));
            let x2 = this.convertToEmu(comp.report.unit.convertToHInches(comp.right + comp.page.margins.left));
            let y2 = this.convertToEmu(comp.report.unit.convertToHInches(comp.bottom + comp.page.margins.top));
            let angle = 0;
            let txtOpt = comp.stimulsoft().as(IStiTextOptions);
            if (txtOpt != null && txtOpt.textOptions != null) {
                angle = txtOpt.textOptions.angle % 360;
                if (angle == 90 || angle == 270 || angle == -90 || angle == -270)
                    angle = 0;
            }
            writer.writeStartElement('p:spPr');
            writer.writeStartElement('a:xfrm');
            if (angle != 0) {
                writer.writeAttributeString('rot', StiString.format('{0}', Math.round(-angle * 60000) | 0));
            }
            writer.writeStartElement('a:off');
            writer.writeAttributeString('x', StiString.format('{0}', x1));
            writer.writeAttributeString('y', StiString.format('{0}', y1));
            writer.writeEndElement();
            writer.writeStartElement('a:ext');
            writer.writeAttributeString('cx', StiString.format('{0}', x2 - x1));
            writer.writeAttributeString('cy', StiString.format('{0}', y2 - y1));
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('a:prstGeom');
            writer.writeAttributeString('prst', 'rect');
            writer.writeStartElement('a:avLst');
            writer.writeEndElement();
            writer.writeEndElement();
            let noNeedFill = comp.is(StiShape) || comp.is(StiImage);
            let color = Color.transparent;
            if (comp.is(IStiBrush)) {
                color = StiBrush.toColor(comp.brush);
            }
            if (color.a == 0 || noNeedFill) {
                writer.writeStartElement('a:noFill');
                writer.writeEndElement();
            } else {
                writer.writeStartElement('a:solidFill');
                this.writeColor(writer, color);
                writer.writeFullEndElement();
            }
            let topmost = false;
            let border = null;
            if (comp.is(IStiBorder)) {
                border = comp.border;
            }
            if (border != null && border.side != StiBorderSides.None && border.style != StiPenStyle.None) {
                if (border.side != StiBorderSides.All || border.is(StiAdvancedBorder)) {
                    topmost = true;
                } else {
                    writer.writeStartElement('a:ln');
                    writer.writeAttributeString('w', StiString.format('{0}', this.convertToEmu(border.size)));
                    writer.writeStartElement('a:solidFill');
                    this.writeColor(writer, border.color);
                    writer.writeFullEndElement();
                    writer.writeStartElement('a:prstDash');
                    writer.writeAttributeString('val', this.getLineStyle(border.style));
                    writer.writeEndElement();
                    writer.writeStartElement('a:miter');
                    writer.writeAttributeString('lim', '800000');
                    writer.writeEndElement();
                    writer.writeFullEndElement();
                }
            }
            writer.writeEndElement();
            return topmost;
        }
        writeBorder(writer, comp) {
            let border = comp.as(IStiBorder).border;
            if (border.is(StiAdvancedBorder)) {
                let adv = border;
                if (adv.isLeftBorderSidePresent)
                    this.writeLine(writer, comp, new Rectangle(comp.left, comp.top, 0, comp.height), adv.leftSide.size, adv.leftSide.style, adv.leftSide.color);
                if (adv.isRightBorderSidePresent)
                    this.writeLine(writer, comp, new Rectangle(comp.right, comp.top, 0, comp.height), adv.rightSide.size, adv.rightSide.style, adv.rightSide.color);
                if (adv.isTopBorderSidePresent)
                    this.writeLine(writer, comp, new Rectangle(comp.left, comp.top, comp.width, 0), adv.topSide.size, adv.topSide.style, adv.topSide.color);
                if (adv.isBottomBorderSidePresent)
                    this.writeLine(writer, comp, new Rectangle(comp.left, comp.bottom, comp.width, 0), adv.bottomSide.size, adv.bottomSide.style, adv.bottomSide.color);
            } else {
                if (border.isLeftBorderSidePresent)
                    this.writeLine(writer, comp, new Rectangle(comp.left, comp.top, 0, comp.height), border.size, border.style, border.color);
                if (border.isRightBorderSidePresent)
                    this.writeLine(writer, comp, new Rectangle(comp.right, comp.top, 0, comp.height), border.size, border.style, border.color);
                if (border.isTopBorderSidePresent)
                    this.writeLine(writer, comp, new Rectangle(comp.left, comp.top, comp.width, 0), border.size, border.style, border.color);
                if (border.isBottomBorderSidePresent)
                    this.writeLine(writer, comp, new Rectangle(comp.left, comp.bottom, comp.width, 0), border.size, border.style, border.color);
            }
        }
        writeLine(writer, comp, rect, size, style, color) {
            if (style == StiPenStyle.None || color.a == 0)
                return;
            writer.writeStartElement('p:cxnSp');
            writer.writeStartElement('p:nvCxnSpPr');
            writer.writeStartElement('p:cNvPr');
            writer.writeAttributeString('id', StiString.format('{0}', this.idCounter));
            writer.writeAttributeString('name', StiString.format('Line {0}', this.idCounter));
            writer.writeEndElement();
            writer.writeStartElement('p:cNvCxnSpPr');
            writer.writeEndElement();
            writer.writeStartElement('p:nvPr');
            writer.writeEndElement();
            writer.writeEndElement();
            let x1 = this.convertToEmu(comp.report.unit.convertToHInches(rect.left + comp.page.margins.left));
            let y1 = this.convertToEmu(comp.report.unit.convertToHInches(rect.top + comp.page.margins.top));
            let x2 = this.convertToEmu(comp.report.unit.convertToHInches(rect.right + comp.page.margins.left));
            let y2 = this.convertToEmu(comp.report.unit.convertToHInches(rect.bottom + comp.page.margins.top));
            writer.writeStartElement('p:spPr');
            writer.writeStartElement('a:xfrm');
            writer.writeStartElement('a:off');
            writer.writeAttributeString('x', StiString.format('{0}', x1));
            writer.writeAttributeString('y', StiString.format('{0}', y1));
            writer.writeEndElement();
            writer.writeStartElement('a:ext');
            writer.writeAttributeString('cx', StiString.format('{0}', x2 - x1));
            writer.writeAttributeString('cy', StiString.format('{0}', y2 - y1));
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('a:prstGeom');
            writer.writeAttributeString('prst', 'line');
            writer.writeStartElement('a:avLst');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('a:ln');
            writer.writeAttributeString('w', StiString.format('{0}', this.convertToEmu(size)));
            writer.writeStartElement('a:solidFill');
            this.writeColor(writer, color);
            writer.writeFullEndElement();
            writer.writeStartElement('a:prstDash');
            writer.writeAttributeString('val', this.getLineStyle(style));
            writer.writeEndElement();
            let linePrimitive = comp.as(StiLinePrimitive);
            if (linePrimitive != null) {
                let cap1 = null;
                let cap2 = null;
                if (linePrimitive.is(StiHorizontalLinePrimitive)) {
                    cap1 = linePrimitive.startCap;
                    cap2 = linePrimitive.endCap;
                }
                if (linePrimitive.is(StiVerticalLinePrimitive)) {
                    cap1 = linePrimitive.startCap;
                    cap2 = linePrimitive.endCap;
                }
                if (cap1 != null) {
                    let capStyle = this.capStyleToPptStyle(cap1.style);
                    if (!StiString.isNullOrEmpty(capStyle)) {
                        writer.writeStartElement('a:headEnd');
                        writer.writeAttributeString('type', capStyle);
                        writer.writeEndElement();
                    }
                }
                if (cap2 != null) {
                    let capStyle = this.capStyleToPptStyle(cap2.style);
                    if (!StiString.isNullOrEmpty(capStyle)) {
                        writer.writeStartElement('a:tailEnd');
                        writer.writeAttributeString('type', capStyle);
                        writer.writeEndElement();
                    }
                }
            }
            writer.writeFullEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
        }
        capStyleToPptStyle(capStyle) {
            switch (capStyle) {
            case StiCapStyle.Arrow:
                return 'triangle';
            case StiCapStyle.Diamond:
                return 'diamond';
            case StiCapStyle.Square:
                return 'diamond';
            case StiCapStyle.Open:
                return 'arrow';
            case StiCapStyle.Oval:
                return 'oval';
            case StiCapStyle.Stealth:
                return 'stealth';
            }
            return null;
        }
        writeWatermark(writer, page, showBehind) {
            if (page.watermark != null && (page.watermark.image != null || !StiString.isNullOrWhiteSpace(page.watermark.imageHyperlink)) && page.watermark.showImageBehind == showBehind) {
                let image = new StiImage();
                image.page = page;
                image.image = page.watermark.image;
                image.left = -page.margins.left;
                image.top = -page.margins.top;
                image.width = page.pageWidth;
                image.height = page.pageHeight;
                if (page.watermark.imageStretch)
                    image.stretch = true;
                image.vertAlignment = StiVertAlignment.Center;
                image.horAlignment = StiHorAlignment.Center;
                this.writeStiImage(writer, image);
            }
        }
        writeHyperlinkInfo(writer, comp) {
            if (comp.hyperlinkValue != null) {
                let hyperlink = comp.hyperlinkValue.toString().trim();
                let hypRefId;
                if (hyperlink.length > 0 && !hyperlink.stimulsoft().startsWith('javascript:')) {
                    if (hyperlink.stimulsoft().startsWith('#')) {
                    } else {
                        let hypRefText = this.stringToUrl(hyperlink);
                        hypRefId = this.hyperlinkList.indexOf(hypRefText);
                        if (hypRefId == -1) {
                            this.hyperlinkList.push(hypRefText);
                            hypRefId = this.hyperlinkList.stimulsoft().countItems;
                        }
                        writer.writeStartElement('a:hlinkClick');
                        writer.writeAttributeString('r:id', StiString.format('hId{0}', hypRefId));
                        writer.writeEndElement();
                    }
                }
            }
        }
        writeImage(num) {
            let ms = new MemoryStream();
            let buf = this.imageCache.imagePackedStore.stimulsoft().getByIndex(num);
            ms.write(buf, 0, buf.length);
            return ms;
        }
        exportPowerPoint(report, stream, settings) {
            __.a.StiLogService.write(this.stimulsoft().getType(), 'Export report to PowerPoint 2007 format');
            let pageRange = settings.pageRange;
            this.imageResolution = settings.imageResolution;
            this.imageQuality = settings.imageQuality;
            this.xmlIndentation = -1;
            if (this.imageResolution < 10)
                this.imageResolution = 10;
            this.imageResolution = this.imageResolution / 100;
            this.currentCulture = CultureInfo.currentCulture;
            this.newCulture = CultureInfo.cultures['en-US'];
            try {
                CultureInfo.currentCulture = this.newCulture;
                let allPages = pageRange.getSelectedPages(report.renderedPages);
                if (this.isStopped)
                    return;
                this.imageCache = new __.a.StiImageCache(Stimulsoft['StiOptions'].Export.PowerPoint.AllowImageComparer, true, Stimulsoft['StiOptions'].Export.PowerPoint.StoreImagesAsPng ? __.a.ImageFormat.Png : __.a.ImageFormat.Jpeg, this.imageQuality);
                let zip = new StiZipWriter20();
                zip.begin(stream, true);
                zip.addFile('[Content_Types].xml', this.writeContentTypes(allPages.count));
                zip.addFile('_rels/.rels', this.writeMainRels());
                zip.addFile('docProps/app.xml', this.writeDocPropsApp(allPages.count));
                zip.addFile('docProps/core.xml', this.writeDocPropsCore());
                zip.addFile('ppt/tableStyles.xml', this.writeTableStyles());
                zip.addFile('ppt/presProps.xml', this.writePresProps());
                zip.addFile('ppt/viewProps.xml', this.writeViewProps());
                zip.addFile('ppt/theme/theme1.xml', this.writeTheme());
                zip.addFile('ppt/slideMasters/slideMaster1.xml', this.writeSlideMaster());
                zip.addFile('ppt/slideMasters/_rels/slideMaster1.xml.rels', this.writeSlideMasterRels());
                for (let index = 0; index < 11; index++) {
                    zip.addFile(StiString.format('ppt/slideLayouts/slideLayout{0}.xml', index + 1), this.writeSlideLayout(index + 1, allPages.getByIndex(0)));
                    zip.addFile(StiString.format('ppt/slideLayouts/_rels/slideLayout{0}.xml.rels', index + 1), this.writeSlideLayoutRels());
                }
                zip.addFile('ppt/presentation.xml', this.writePresentation(allPages));
                zip.addFile('ppt/_rels/presentation.xml.rels', this.writePresentationRels(allPages));
                this.imageListOffset = 0;
                this.hyperlinkList = [];
                for (let indexPage = 0; indexPage < allPages.count; indexPage++) {
                    this.invokeExporting2(indexPage, allPages.count, 0, 1);
                    if (this.isStopped)
                        return;
                    let page = allPages.getByIndex(indexPage);
                    allPages.getPage(page);
                    zip.addFile(StiString.format('ppt/slides/slide{0}.xml', indexPage + 1), this.writeSlide(indexPage, allPages));
                    zip.addFile(StiString.format('ppt/slides/_rels/slide{0}.xml.rels', indexPage + 1), this.writeSlideRels(indexPage));
                    this.imageListOffset = this.imageCache.imageIndex.stimulsoft().countItems;
                    this.hyperlinkList.stimulsoft().clear();
                }
                if (this.imageCache.imagePackedStore.stimulsoft().countItems > 0) {
                    for (let index = 0; index < this.imageCache.imagePackedStore.stimulsoft().countItems; index++) {
                        zip.addFile(StiString.format('ppt/media/image{0:D5}.{1}', index + 1, Stimulsoft['StiOptions'].Export.PowerPoint.StoreImagesAsPng ? 'png' : 'jpeg'), this.writeImage(index));
                    }
                }
                zip.end();
            } finally {
                CultureInfo.currentCulture = this.currentCulture;
                this.imageCache.clear();
                this.hyperlinkList = null;
            }
        }
    };
}
let StiRichText = __.a.Components.StiRichText;
let IStiFont = __.a.Components.IStiFont;
let IStiTextBrush = __.a.Components.IStiTextBrush;
{
    let StiWord2007StyleInfo = class {
    };
    let StiWord2007ExportService = class extends __.b.StiExportService {
        constructor() {
            super(...arguments);
            this.multipleFiles = false;
            this.matrix = null;
            this.removeEmptySpaceAtBottom = Stimulsoft['StiOptions'].Export.Word.removeEmptySpaceAtBottom;
            this.fontList = null;
            this.styleList = null;
            this.imageCache = null;
            this.bookmarkList = null;
            this.hyperlinkList = null;
            this.embedsList = null;
            this.xmlIndentation = 1;
            this.imageQuality = 0.75;
            this.imageResolution = 96;
            this.lineSpace = null;
            this.lineSpace2 = null;
            this.usePageHeadersAndFooters = false;
            this.restrictEditing = __.b.StiWord2007RestrictEditing.No;
            this.headersData = null;
            this.headersRels = null;
            this.footersData = null;
            this.footersRels = null;
            this.docCompanyString = null;
            this.docLastModifiedString = null;
            this.wrongUrlSymbols = ' "#\'*,;<>[^`{|}';
        }
        implements() {
            return [__.b.IStiWord2007ExportService];
        }
        get exportFormat() {
            return __.a.StiExportFormat.Word2007;
        }
        exportTo(report, stream, settings) {
            this.exportWord(report, stream, settings);
        }
        exportToAsync(onExport, report, stream, settings) {
            setTimeout(() => Stimulsoft.tsfb(this, void 0, void 0, function* () {
                yield __.b.StiExportImageHelper.convertAllImages(report, Stimulsoft.System.Drawing.Imaging.ImageFormat.Jpeg, false, this.exportFormat);
                this.exportTo(report, stream, settings);
                if (report != null && report.preparedExportImages != null) {
                    report.preparedExportImages.clear();
                    report.preparedExportImages = null;
                }
                onExport();
            }), 0);
        }
        getFilter() {
            return StiLocalization.get('FileFilters', 'Word2007Files');
        }
        static checkFontsToCorrectHeight(name) {
            if (this.fontsToCorrectHeight == null) {
                this.fontsToCorrectHeight = new Hashtable();
                this.fontsToCorrectHeight.add('Arial Unicode MS', null);
                this.fontsToCorrectHeight.add('Cascadia Code ExtraLight', null);
                this.fontsToCorrectHeight.add('Cascadia Code SemiBold', null);
                this.fontsToCorrectHeight.add('Cascadia Code SemiLight', null);
                this.fontsToCorrectHeight.add('Cascadia Mono ExtraLight', null);
                this.fontsToCorrectHeight.add('Cascadia Mono Light', null);
                this.fontsToCorrectHeight.add('Cascadia Mono SemiBold', null);
                this.fontsToCorrectHeight.add('Cascadia Mono SemiLight', null);
                this.fontsToCorrectHeight.add('Malgun Gothic', null);
                this.fontsToCorrectHeight.add('Malgun Gothic Semilight', null);
                this.fontsToCorrectHeight.add('Microsoft JhengHei', null);
                this.fontsToCorrectHeight.add('Microsoft JhengHei Light', null);
                this.fontsToCorrectHeight.add('Microsoft JhengHei UI', null);
                this.fontsToCorrectHeight.add('Microsoft JhengHei UI Light', null);
                this.fontsToCorrectHeight.add('Microsoft YaHei', null);
                this.fontsToCorrectHeight.add('Microsoft YaHei Light', null);
                this.fontsToCorrectHeight.add('Microsoft YaHei UI', null);
                this.fontsToCorrectHeight.add('Microsoft YaHei UI Light', null);
                this.fontsToCorrectHeight.add('MingLiU_HKSCS-ExtB', null);
                this.fontsToCorrectHeight.add('MingLiU-ExtB', null);
                this.fontsToCorrectHeight.add('MS Gothic', null);
                this.fontsToCorrectHeight.add('MS PGothic', null);
                this.fontsToCorrectHeight.add('MS UI Gothic', null);
                this.fontsToCorrectHeight.add('NSimSun', null);
                this.fontsToCorrectHeight.add('PMingLiU-ExtB', null);
                this.fontsToCorrectHeight.add('Segoe MDL2 Assets', null);
                this.fontsToCorrectHeight.add('SimSun', null);
                this.fontsToCorrectHeight.add('SimSun-ExtB', null);
                this.fontsToCorrectHeight.add('Yu Gothic', null);
                this.fontsToCorrectHeight.add('Yu Gothic Light', null);
                this.fontsToCorrectHeight.add('Yu Gothic Medium', null);
                this.fontsToCorrectHeight.add('Yu Gothic UI', null);
                this.fontsToCorrectHeight.add('Yu Gothic UI Light', null);
                this.fontsToCorrectHeight.add('Yu Gothic UI Semibold', null);
                this.fontsToCorrectHeight.add('Yu Gothic UI Semilight', null);
                this.fontsToCorrectHeight.add('微软雅黑', null);
            }
            return this.fontsToCorrectHeight.containsKey(name);
        }
        getLineStyle(penStyle) {
            switch (penStyle) {
            case StiPenStyle.Solid:
                return 'single';
            case StiPenStyle.Dot:
                return 'dotted';
            case StiPenStyle.Dash:
                return 'dashSmallGap';
            case StiPenStyle.DashDot:
                return 'dotDash';
            case StiPenStyle.DashDotDot:
                return 'dotDotDash';
            case StiPenStyle.Double:
                return 'double';
            default:
                return '';
            }
        }
        getColorString(color) {
            if (color.a == 0)
                return 'auto';
            if (color.a < 32)
                return 'FFFFFF';
            return StiString.format('{0:X8}', color.toArgb()).substr(2);
        }
        getStyleNumber(tmpStyleList, styleInfo) {
            if (tmpStyleList.length > 0) {
                for (let index = 0; index < tmpStyleList.length; index++) {
                    let tmpStyle = tmpStyleList[index];
                    if (tmpStyle.alignment == styleInfo.alignment && tmpStyle.name == styleInfo.name && tmpStyle.fontName == styleInfo.fontName && tmpStyle.fontSize == styleInfo.fontSize && tmpStyle.bold == styleInfo.bold && tmpStyle.italic == styleInfo.italic && tmpStyle.underline == styleInfo.underline && tmpStyle.textColor.equals(styleInfo.textColor) && tmpStyle.rightToLeft == styleInfo.rightToLeft) {
                        return index;
                    }
                }
            }
            tmpStyleList.push(styleInfo);
            let temp = tmpStyleList.length - 1;
            return temp;
        }
        getStyleFromComponent(component) {
            if (component != null && !StiString.isNullOrEmpty(component.componentStyle)) {
                let mFont = component.stimulsoft().as(IStiFont);
                let mTextBrush = component.stimulsoft().as(IStiTextBrush);
                let mTextHorAlign = component.stimulsoft().as(IStiTextHorAlignment);
                let textOpt = component.stimulsoft().as(IStiTextOptions);
                let style = new StiWord2007StyleInfo();
                style.name = component.componentStyle;
                if (mFont != null) {
                    style.fontName = mFont.font.name;
                    style.fontSize = StiMath.round2(mFont.font.sizeInPoints * 2, 0);
                    style.bold = mFont.font.bold;
                    style.italic = mFont.font.italic;
                    style.underline = mFont.font.underline;
                }
                if (mTextBrush != null) {
                    style.textColor = StiBrush.toColor(mTextBrush.textBrush);
                }
                if (mTextHorAlign != null) {
                    style.alignment = mTextHorAlign.horAlignment;
                }
                if (textOpt != null) {
                    style.rightToLeft = textOpt.textOptions.rightToLeft;
                }
                return this.getStyleNumber(this.styleList, style);
            }
            return -1;
        }
        stringToUrl(input) {
            if (StiString.isNullOrEmpty(input))
                return '';
            let output = new StringBuilder();
            if (input.stimulsoft().startsWith('file:')) {
                for (let ch of input.split('')) {
                    if (ch.charCodeAt(0) < 32 || ch == '"') {
                        output.append(StiString.format('%{0:x2}', ch));
                    } else {
                        output.append(ch);
                    }
                }
            } else {
                for (let ch of input.split('')) {
                    if (ch.charCodeAt(0) < 32 || this.wrongUrlSymbols.indexOf(ch) != -1) {
                        output.append('_');
                    } else {
                        output.append(ch);
                    }
                }
            }
            return output.toString();
        }
        static get hiToTwips() {
            return 14.4 * 0.995;
        }
        convert(x) {
            return StiMath.round2(x * StiWord2007ExportService.hiToTwips);
        }
        convertHiToTwips(x) {
            return StiMath.round2(x * 14.4);
        }
        convertTwipsToEmu(x) {
            return StiMath.round2(x / StiWord2007ExportService.hiToTwips / 100 * 914400);
        }
        convertStringToBookmark(inputString) {
            let sbOutput = new StringBuilder();
            for (let ch of inputString.split('')) {
                if (Char.isLetterOrDigit(ch))
                    sbOutput.append(ch);
            }
            if (sbOutput.length > 0 && sbOutput.toString()[0] != null && Char.isDigit(sbOutput.toString()[0]))
                sbOutput.insert(0, 'b');
            return sbOutput.toString();
        }
        writeFromMatrix(writer, startLine, endLine, outHeadersAndFooters) {
            let maxCoordX = this.matrix.coordX.countItems;
            let maxCoordY = this.matrix.coordY.countItems;
            let wordCoordX = StiArray.create(Number, maxCoordX);
            let coordXKeys = this.matrix.coordX.getKeys();
            for (let indexColumn = 0; indexColumn < maxCoordX; indexColumn++) {
                let columnX = this.matrix.coordX.getByIndex(indexColumn, coordXKeys);
                wordCoordX[indexColumn] = this.convert(columnX);
            }
            let wordCoordY = StiArray.create(Number, maxCoordY);
            let coordYKeys = this.matrix.coordY.getKeys();
            for (let indexRow = 0; indexRow < maxCoordY; indexRow++) {
                let columnY = this.matrix.coordY.getByIndex(indexRow, coordYKeys);
                wordCoordY[indexRow] = this.convert(columnY);
            }
            let isTable = false;
            let skipCounter = 0;
            let readyCells = StiArray.create2(Boolean, maxCoordY, maxCoordX);
            let readyCellsVert = StiArray.create2(Boolean, maxCoordY, maxCoordX);
            let lastHeaderName = '';
            this.currentPassNumber = 2 + (Stimulsoft['StiOptions'].Export.Word.divideSegmentPages ? 1 : 0);
            for (let indexRow = 1; indexRow < maxCoordY; indexRow++) {
                this.invokeExporting2(indexRow, maxCoordY, this.currentPassNumber, this.maximumPassNumber);
                let needOutLine = indexRow - 1 >= startLine && indexRow - 1 <= endLine;
                if (outHeadersAndFooters == false) {
                    if (this.matrix.linePlacement[indexRow - 1] == __.b.StiTableLineInfo.PageHeader || this.matrix.linePlacement[indexRow - 1] == __.b.StiTableLineInfo.PageFooter || this.matrix.linePlacement[indexRow - 1] == __.b.StiTableLineInfo.Trash) {
                        needOutLine = false;
                    }
                }
                if (skipCounter > 0) {
                    skipCounter--;
                    needOutLine = false;
                }
                let maxTopMargin = 100005;
                let paragraphList = [];
                let needNewPage = false;
                if (needOutLine) {
                    for (let columnIndex = 1; columnIndex < maxCoordX; columnIndex++) {
                        let cell = this.matrix.cells[indexRow - 1][columnIndex - 1];
                        if (readyCells[indexRow][columnIndex] == false && cell != null && cell.component != null) {
                            if (cell.component.tagValue != null) {
                                let cellTag = cell.component.tagValue.toString().toLowerCase();
                                if (cellTag.indexOf('rtfparagraph') != -1) {
                                    paragraphList.push(cell);
                                    needOutLine = false;
                                }
                                if (cellTag.indexOf('rtfnewpage') != -1)
                                    needNewPage = true;
                            }
                            let margins = null;
                            if (cell.component.is(StiText))
                                margins = cell.component.margins;
                            if (cell.component.is(StiRichText))
                                margins = cell.component.margins;
                            if (margins != null) {
                                if (margins.top < maxTopMargin)
                                    maxTopMargin = margins.top;
                                if (cell.height > 0) {
                                    maxTopMargin = 0;
                                }
                            }
                        }
                    }
                }
                maxTopMargin *= StiWord2007ExportService.hiToTwips;
                let maxTopMarginInt = StiMath.round2(maxTopMargin);
                if (needNewPage) {
                    if (isTable) {
                        writer.writeFullEndElement();
                        isTable = false;
                    }
                    writer.writeStartElement('w:p');
                    writer.writeStartElement('w:r');
                    writer.writeStartElement('w:br');
                    writer.writeAttributeString('w:type', 'page');
                    writer.writeEndElement();
                    writer.writeEndElement();
                    writer.writeEndElement();
                }
                if (needOutLine) {
                    if (this.usePageHeadersAndFooters && this.matrix.linePlacement[indexRow - 1] == __.b.StiTableLineInfo.HeaderAP) {
                        let headerName = this.matrix.parentBandName[indexRow - 1];
                        let symPos = headerName.indexOf('');
                        if (symPos != -1) {
                            headerName = headerName.substr(0, symPos);
                        }
                        if (headerName != lastHeaderName) {
                            lastHeaderName = headerName;
                            if (isTable) {
                                writer.writeFullEndElement();
                            }
                            writer.writeStartElement('w:p');
                            writer.writeEndElement();
                            writer.writeStartElement('w:tbl');
                            this.writeTableInfo(writer, wordCoordX, maxCoordX);
                            isTable = true;
                        }
                    }
                    if (!isTable) {
                        writer.writeStartElement('w:tbl');
                        this.writeTableInfo(writer, wordCoordX, maxCoordX);
                        isTable = true;
                    }
                    writer.writeStartElement('w:tr');
                    let rowHeight = wordCoordY[indexRow] - wordCoordY[indexRow - 1];
                    writer.writeStartElement('w:trPr');
                    if (!this.usePageHeadersAndFooters || Stimulsoft['StiOptions'].Export.Word.forceLineHeight) {
                        writer.writeStartElement('w:trHeight');
                        if (!this.usePageHeadersAndFooters && Stimulsoft['StiOptions'].Export.Word.lineHeightExactly || this.usePageHeadersAndFooters && Stimulsoft['StiOptions'].Export.Word.lineHeightExactlyForPHFMode) {
                            writer.writeAttributeString('w:hRule', 'exact');
                        }
                        writer.writeAttributeString('w:val', StiString.format('{0}', rowHeight));
                        writer.writeEndElement();
                    }
                    if (this.usePageHeadersAndFooters && this.matrix.linePlacement[indexRow - 1] == __.b.StiTableLineInfo.HeaderAP) {
                        writer.writeStartElement('w:tblHeader');
                        writer.writeEndElement();
                    }
                    writer.writeEndElement();
                }
                let curCoordX = 0;
                for (let indexColumn = 1; indexColumn < maxCoordX; indexColumn++) {
                    let cell = this.matrix.cells[indexRow - 1][indexColumn - 1];
                    if (!readyCells[indexRow][indexColumn] || readyCellsVert[indexRow][indexColumn]) {
                        curCoordX++;
                        let needContent = true;
                        if (readyCellsVert[indexRow][indexColumn]) {
                            let tempIndexRow = indexRow;
                            while (readyCellsVert[tempIndexRow][indexColumn])
                                tempIndexRow--;
                            cell = this.matrix.cells[tempIndexRow - 1][indexColumn - 1];
                            needContent = false;
                        }
                        if (cell != null && needContent) {
                            for (let yy = 0; yy <= cell.height; yy++) {
                                for (let xx = 0; xx <= cell.width; xx++) {
                                    readyCells[indexRow + yy][indexColumn + xx] = true;
                                }
                            }
                            if (cell.height > 0) {
                                for (let yy = 1; yy <= cell.height; yy++) {
                                    readyCellsVert[indexRow + yy][indexColumn] = true;
                                }
                            }
                        }
                        if (needOutLine) {
                            writer.writeStartElement('w:tc');
                            if (cell != null) {
                                writer.writeStartElement('w:tcPr');
                                let cellWidth = 0;
                                for (let indexMerg = 0; indexMerg < cell.width + 1; indexMerg++) {
                                    cellWidth += wordCoordX[indexColumn + indexMerg] - wordCoordX[indexColumn - 1 + indexMerg];
                                }
                                writer.writeStartElement('w:tcW');
                                writer.writeAttributeString('w:w', StiString.format('{0}', cellWidth));
                                writer.writeAttributeString('w:type', 'dxa');
                                writer.writeEndElement();
                                if (cell.width > 0) {
                                    writer.writeStartElement('w:gridSpan');
                                    writer.writeAttributeString('w:val', StiString.format('{0}', cell.width + 1));
                                    writer.writeEndElement();
                                }
                                if (cell.height > 0) {
                                    if (!readyCellsVert[indexRow][indexColumn]) {
                                        writer.writeStartElement('w:vMerge');
                                        writer.writeAttributeString('w:val', 'restart');
                                        writer.writeEndElement();
                                    } else {
                                        writer.writeStartElement('w:vMerge');
                                        writer.writeEndElement();
                                    }
                                }
                                if (cell.cellStyle.textOptions != null) {
                                    let textAngle = cell.cellStyle.textOptions.angle;
                                    let stTextAngle = '';
                                    if (textAngle > 45 && textAngle < 135)
                                        stTextAngle = 'btLr';
                                    if (textAngle > 225 && textAngle < 315)
                                        stTextAngle = 'tbRl';
                                    if (stTextAngle != '') {
                                        writer.writeStartElement('w:textDirection');
                                        writer.writeAttributeString('w:val', stTextAngle);
                                        writer.writeEndElement();
                                    }
                                }
                                let isEmbedRtfFlag = cell.component.is(StiText) && cell.component.checkAllowHtmlTags() && !Stimulsoft['StiOptions'].Export.Word.renderHtmlTagsAsImage;
                                if (needContent && cell.component.is(StiText) && (!cell.component.isExportAsImage(this.exportFormat) || isEmbedRtfFlag)) {
                                    let stiText = cell.component;
                                    let mLeft = this.convert(stiText.margins.left);
                                    let mRight = this.convert(stiText.margins.right - Stimulsoft['StiOptions'].Export.Word.rightMarginCorrection);
                                    let mTop = this.convert(stiText.margins.top);
                                    if (mTop > maxTopMarginInt)
                                        mTop = maxTopMarginInt;
                                    if (mLeft > 0 || mRight > 0 || mTop > 0) {
                                        writer.writeStartElement('w:tcMar');
                                        if (mTop > 0) {
                                            writer.writeStartElement('w:top');
                                            writer.writeAttributeString('w:w', StiString.format('{0}', mTop));
                                            writer.writeAttributeString('w:type', 'dxa');
                                            writer.writeEndElement();
                                        }
                                        if (mLeft > 0) {
                                            writer.writeStartElement('w:left');
                                            writer.writeAttributeString('w:w', StiString.format('{0}', mLeft));
                                            writer.writeAttributeString('w:type', 'dxa');
                                            writer.writeEndElement();
                                        }
                                        if (mRight > 0) {
                                            writer.writeStartElement('w:right');
                                            writer.writeAttributeString('w:w', StiString.format('{0}', mRight));
                                            writer.writeAttributeString('w:type', 'dxa');
                                            writer.writeEndElement();
                                        }
                                        writer.writeEndElement();
                                    }
                                }
                                let stVertAlign = '';
                                switch (cell.cellStyle.vertAlignment) {
                                case StiVertAlignment.Center:
                                    stVertAlign = 'center';
                                    break;
                                case StiVertAlignment.Bottom:
                                    stVertAlign = 'bottom';
                                    break;
                                }
                                if (stVertAlign != '') {
                                    writer.writeStartElement('w:vAlign');
                                    writer.writeAttributeString('w:val', stVertAlign);
                                    writer.writeEndElement();
                                }
                                this.writeBorders(writer, cell.top, cell.left, cell.height + 1, cell.width + 1);
                                if (!cell.component.isExportAsImage(this.exportFormat)) {
                                    writer.writeStartElement('w:shd');
                                    writer.writeAttributeString('w:val', 'clear');
                                    writer.writeAttributeString('w:color', 'auto');
                                    writer.writeAttributeString('w:fill', this.getColorString(cell.cellStyle.color));
                                    writer.writeEndElement();
                                }
                                writer.writeEndElement();
                                let needPerm = this.restrictEditing == __.b.StiWord2007RestrictEditing.ExceptEditableFields && cell.component != null && cell.component.is(StiText) && cell.component.editable;
                                if (needPerm) {
                                    writer.writeStartElement('w:permStart');
                                    writer.writeAttributeString('w:id', '0');
                                    writer.writeEndElement();
                                }
                                let needEmptyParagraph = true;
                                if (needContent) {
                                    let REFneedEmptyParagraph = { ref: needEmptyParagraph };
                                    this.writeCellContent(writer, cell, REFneedEmptyParagraph, indexRow, indexColumn, wordCoordX, wordCoordY);
                                    needEmptyParagraph = REFneedEmptyParagraph.ref;
                                }
                                if (needEmptyParagraph) {
                                    writer.writeStartElement('w:p');
                                    writer.writeFullEndElement();
                                }
                                if (needPerm) {
                                    writer.writeStartElement('w:permEnd');
                                    writer.writeAttributeString('w:id', '0');
                                    writer.writeEndElement();
                                }
                            } else {
                                let baseSt = null;
                                let REFbaseSt = { ref: baseSt };
                                let baseSides = this.renderBorder2TableGetValues(indexRow, indexColumn, REFbaseSt);
                                let newWidth = 0;
                                if ((baseSides & StiBorderSides.Right) == 0) {
                                    while (indexColumn + newWidth + 1 < maxCoordX && this.matrix.cells[indexRow - 1][indexColumn + newWidth + 1 - 1] == null && readyCells[indexRow][indexColumn + newWidth + 1] == false && readyCellsVert[indexRow][indexColumn + newWidth + 1] == false) {
                                        let newSt = null;
                                        let REFnewSt = { ref: newSt };
                                        let newSides = this.renderBorder2TableGetValues(indexRow, indexColumn + newWidth + 1, REFnewSt);
                                        if ((newSides & StiBorderSides.Left) > 0)
                                            break;
                                        if ((newSides & (StiBorderSides.Top | StiBorderSides.Bottom)) != (baseSides & (StiBorderSides.Top | StiBorderSides.Bottom)))
                                            break;
                                        if (baseSt != newSt)
                                            break;
                                        newWidth++;
                                        if ((newSides & StiBorderSides.Right) > 0)
                                            break;
                                    }
                                    if (newWidth > 0) {
                                        for (let xx = 1; xx <= newWidth; xx++) {
                                            readyCells[indexRow][indexColumn + xx] = true;
                                        }
                                    }
                                }
                                writer.writeStartElement('w:tcPr');
                                let cellWidth = wordCoordX[indexColumn + newWidth] - wordCoordX[indexColumn - 1];
                                writer.writeStartElement('w:tcW');
                                writer.writeAttributeString('w:w', StiString.format('{0}', cellWidth));
                                writer.writeAttributeString('w:type', 'dxa');
                                writer.writeEndElement();
                                if (newWidth > 0) {
                                    writer.writeStartElement('w:gridSpan');
                                    writer.writeAttributeString('w:val', StiString.format('{0}', newWidth + 1));
                                    writer.writeEndElement();
                                }
                                this.writeBorders(writer, indexRow - 1, indexColumn - 1, 1, newWidth + 1);
                                writer.writeEndElement();
                                writer.writeStartElement('w:p');
                                writer.writeFullEndElement();
                            }
                            writer.writeFullEndElement();
                        }
                    }
                    if (curCoordX >= 64)
                        break;
                }
                if (needOutLine) {
                    writer.writeFullEndElement();
                }
                for (let paragraphCell of paragraphList) {
                    if (isTable) {
                        writer.writeEndElement();
                    }
                    isTable = false;
                    skipCounter = paragraphCell.height;
                    let needEmptyParagraph2 = false;
                    let REFneedEmptyParagraph2 = { ref: needEmptyParagraph2 };
                    this.writeCellContent(writer, paragraphCell, REFneedEmptyParagraph2, paragraphCell.top + 1, paragraphCell.left + 1, wordCoordX, wordCoordY);
                    needEmptyParagraph2 = REFneedEmptyParagraph2.ref;
                }
            }
            if (isTable) {
                writer.writeEndElement();
            }
        }
        writeCellContent(writer, cell, REFneedEmptyParagraph, indexRow, indexColumn, wordCoordX, wordCoordY) {
            let needEmptyParagraph = REFneedEmptyParagraph.ref;
            let bkmRefText = null;
            let bkmRefId = -1;
            let bkm = this.matrix.bookmarks[indexRow - 1][indexColumn - 1];
            if (bkm != null && !this.bookmarkList.containsKey(bkm)) {
                bkmRefId = this.bookmarkList.count;
                bkmRefText = this.convertStringToBookmark(bkm);
                this.bookmarkList.set(bkm, bkmRefId);
            }
            let hypRefText = null;
            let hypRefId = -1;
            if (cell.component != null && cell.component.hyperlinkValue != null) {
                let hyperlink = cell.component.hyperlinkValue.toString().trim();
                if (hyperlink.length > 0 && !hyperlink.stimulsoft().startsWith('javascript:')) {
                    if (hyperlink.stimulsoft().startsWith('#')) {
                        hypRefText = this.convertStringToBookmark(hyperlink.substr(1));
                    } else {
                        hypRefText = this.stringToUrl(hyperlink);
                        if (this.hyperlinkList.containsKey(hypRefText)) {
                            hypRefId = StiMath.trunc(this.hyperlinkList.get(hypRefText));
                        } else {
                            hypRefId = this.hyperlinkList.count;
                            this.hyperlinkList.add(hypRefText, hypRefId);
                        }
                    }
                }
            }
            if (cell.component.is(StiText) && !cell.component.isExportAsImage(this.exportFormat) && !cell.component.checkAllowHtmlTags()) {
                let sb = new StringBuilder(cell.text);
                if (this.usePageHeadersAndFooters) {
                    let expr = cell.component.tagValue;
                    if (!StiString.isNullOrEmpty(expr)) {
                        if (expr.toLowerCase().indexOf('rtfnewpage') == -1 && (expr.indexOf('#PageNumber#') != -1 || expr.indexOf('#TotalPageCount#') != -1 || expr.indexOf('#PageRef') != -1)) {
                            sb = new StringBuilder(expr);
                        }
                    }
                }
                let stringList = [];
                let st = '';
                for (let ch of sb.toString().split('')) {
                    if (Char.isControl(ch) && ch != '	') {
                        if (ch == '\n') {
                            stringList.push(st);
                            st = '';
                        }
                    } else {
                        st += ch;
                    }
                }
                if (st != '')
                    stringList.push(st);
                if (stringList.length == 0)
                    stringList.push(st);
                if (stringList.length > 0)
                    needEmptyParagraph = false;
                let styleIndex = this.getStyleFromComponent(cell.component);
                for (let indexLine = 0; indexLine < stringList.length; indexLine++) {
                    let textLine = stringList[indexLine];
                    writer.writeStartElement('w:p');
                    writer.writeStartElement('w:pPr');
                    let lineHeight = cell.component.stimulsoft().as(StiText).lineSpacing;
                    if (this.lineSpace != null || lineHeight != 1) {
                        let stLineSpace = this.lineSpace;
                        if (lineHeight != 1) {
                            stLineSpace = StiMath.round2(Stimulsoft['StiOptions'].Export.Word.lineSpacing * 240 * lineHeight).toString();
                        }
                        let font = cell.component.stimulsoft().as(IStiFont);
                        if (font != null && font.font != null) {
                            if (StiWord2007ExportService.checkFontsToCorrectHeight(font.font.name)) {
                                stLineSpace = this.lineSpace2;
                                if (lineHeight != 1) {
                                    stLineSpace = StiMath.round2(Stimulsoft['StiOptions'].Export.Word.lineSpacing * 240 * 0.772 * lineHeight).toString();
                                }
                            }
                        }
                        writer.writeStartElement('w:spacing');
                        writer.writeAttributeString('w:line', stLineSpace);
                        writer.writeEndElement();
                    }
                    if (styleIndex != -1) {
                        writer.writeStartElement('w:pStyle');
                        writer.writeAttributeString('w:val', StiString.format('Style{0}', styleIndex));
                        writer.writeEndElement();
                    }
                    let horAlignment = cell.cellStyle.horAlignment;
                    let rightToLeft = false;
                    if (cell.cellStyle.textOptions != null)
                        rightToLeft = cell.cellStyle.textOptions.rightToLeft;
                    let stHorAlignment = '';
                    if (horAlignment == StiTextHorAlignment.Left && rightToLeft == true || horAlignment == StiTextHorAlignment.Right && rightToLeft == false) {
                        stHorAlignment = 'right';
                    }
                    if (horAlignment == StiTextHorAlignment.Center)
                        stHorAlignment = 'center';
                    if (horAlignment == StiTextHorAlignment.Width)
                        stHorAlignment = 'both';
                    if (stHorAlignment != '') {
                        writer.writeStartElement('w:jc');
                        writer.writeAttributeString('w:val', stHorAlignment);
                        writer.writeEndElement();
                    }
                    if (styleIndex == -1) {
                        this.writeRunProperties(writer, cell);
                    }
                    writer.writeEndElement();
                    if (hypRefText != null) {
                        writer.writeStartElement('w:hyperlink');
                        if (hypRefId == -1) {
                            writer.writeAttributeString('w:anchor', hypRefText);
                        } else {
                            writer.writeAttributeString('r:id', StiString.format('hId{0}', hypRefId));
                        }
                    }
                    if (bkmRefId != -1) {
                        writer.writeStartElement('w:bookmarkStart');
                        writer.writeAttributeString('w:id', bkmRefId.toString());
                        writer.writeAttributeString('w:name', bkmRefText);
                        writer.writeEndElement();
                    }
                    if (textLine != '') {
                        if (this.usePageHeadersAndFooters) {
                            textLine = textLine.stimulsoft().replaceAll('#PageNumber#', '').stimulsoft().replaceAll('#TotalPageCount#', '');
                            let runList = [];
                            let sbr = new StringBuilder();
                            for (let ch of textLine.split('')) {
                                if (ch == '' || ch == '') {
                                    if (sbr.length > 0)
                                        runList.push(sbr.toString());
                                    runList.push(ch.toString());
                                    sbr = new StringBuilder();
                                } else {
                                    sbr.append(ch);
                                }
                            }
                            if (sbr.length > 0)
                                runList.push(sbr.toString());
                            if (runList.length == 0)
                                runList.push(textLine);
                            for (let indexRun = 0; indexRun < runList.length; indexRun++) {
                                let run = runList[indexRun];
                                if (run.length > 0 && (run[0] == '' || run[0] == '')) {
                                    writer.writeStartElement('w:r');
                                    if (styleIndex == -1) {
                                        this.writeRunProperties(writer, cell);
                                    }
                                    writer.writeStartElement('w:fldChar');
                                    writer.writeAttributeString('w:fldCharType', 'begin');
                                    writer.writeEndElement();
                                    writer.writeEndElement();
                                    writer.writeStartElement('w:r');
                                    this.writeRunProperties(writer, cell);
                                    writer.writeStartElement('w:instrText');
                                    switch (run.charAt(0)) {
                                    case '':
                                        writer.writeString('PAGE');
                                        break;
                                    case '':
                                        writer.writeString('NUMPAGES');
                                        break;
                                    }
                                    writer.writeEndElement();
                                    writer.writeEndElement();
                                    writer.writeStartElement('w:r');
                                    this.writeRunProperties(writer, cell);
                                    writer.writeStartElement('w:fldChar');
                                    writer.writeAttributeString('w:fldCharType', 'end');
                                    writer.writeEndElement();
                                    writer.writeEndElement();
                                } else {
                                    writer.writeStartElement('w:r');
                                    if (styleIndex == -1) {
                                        this.writeRunProperties(writer, cell);
                                    }
                                    writer.writeStartElement('w:t');
                                    writer.writeAttributeString('xml:space', 'preserve');
                                    writer.writeString(run);
                                    writer.writeEndElement();
                                    writer.writeEndElement();
                                }
                            }
                        } else {
                            writer.writeStartElement('w:r');
                            if (styleIndex == -1) {
                                this.writeRunProperties(writer, cell);
                            }
                            writer.writeStartElement('w:t');
                            writer.writeAttributeString('xml:space', 'preserve');
                            writer.writeString(textLine);
                            writer.writeEndElement();
                            writer.writeEndElement();
                        }
                    }
                    if (bkmRefId != -1) {
                        writer.writeStartElement('w:bookmarkEnd');
                        writer.writeAttributeString('w:id', bkmRefId.toString());
                        writer.writeEndElement();
                    }
                    if (hypRefText != null) {
                        writer.writeEndElement();
                    }
                    writer.writeEndElement();
                }
            } else if (cell.component.is(StiRichText) && !Stimulsoft['StiOptions'].Export.Word.renderRichTextAsImage) {
            } else if (cell.component.is(StiText) && cell.component.checkAllowHtmlTags() && !Stimulsoft['StiOptions'].Export.Word.renderHtmlTagsAsImage) {
                if (!StiString.isNullOrWhiteSpace(cell.text)) {
                    this.writeHtmlTags(writer, cell);
                }
            } else if (cell.component.isExportAsImage(this.exportFormat)) {
                let exportImage = cell.component.stimulsoft().as(IStiExportImageExtended);
                if (exportImage != null) {
                    let rsImageResolution = this.imageResolution;
                    let REFzoom = { ref: rsImageResolution };
                    let image = exportImage.getImage(REFzoom);
                    rsImageResolution = REFzoom.ref;
                    if (image != null) {
                        let img = this.matrix.getRealImageData(cell, image);
                        needEmptyParagraph = false;
                        let imageIndex = 0;
                        if (img != null)
                            imageIndex = this.imageCache.addImageIntRaw(img, img.imageFormat);
                        else
                            imageIndex = this.imageCache.addImageIntRaw(image, image.imageFormat);
                        let richWidth = -1;
                        let richHeight = -1;
                        writer.writeStartElement('w:p');
                        writer.writeStartElement('w:pPr');
                        let horAlignment = cell.cellStyle.horAlignment;
                        let rightToLeft = false;
                        if (cell.cellStyle.textOptions != null)
                            rightToLeft = cell.cellStyle.textOptions.rightToLeft;
                        if (cell.component.stimulsoft().as(IStiTextHorAlignment) == null) {
                        }
                        let stHorAlignment = '';
                        if (horAlignment == StiTextHorAlignment.Left && rightToLeft == true || horAlignment == StiTextHorAlignment.Right && rightToLeft == false) {
                            stHorAlignment = 'right';
                        }
                        if (horAlignment == StiTextHorAlignment.Center)
                            stHorAlignment = 'center';
                        if (horAlignment == StiTextHorAlignment.Width)
                            stHorAlignment = 'both';
                        if (stHorAlignment != '') {
                            writer.writeStartElement('w:jc');
                            writer.writeAttributeString('w:val', stHorAlignment);
                            writer.writeEndElement();
                        }
                        writer.writeEndElement();
                        if (bkmRefId != -1) {
                            writer.writeStartElement('w:bookmarkStart');
                            writer.writeAttributeString('w:id', bkmRefId.toString());
                            writer.writeAttributeString('w:name', bkmRefText);
                            writer.writeEndElement();
                        }
                        writer.writeStartElement('w:r');
                        writer.writeStartElement('w:rPr');
                        writer.writeElementString('w:noProof', '');
                        writer.writeEndElement();
                        writer.writeStartElement('w:drawing');
                        writer.writeStartElement('wp:inline');
                        writer.writeAttributeString('distT', '0');
                        writer.writeAttributeString('distB', '0');
                        writer.writeAttributeString('distL', '0');
                        writer.writeAttributeString('distR', '0');
                        let imageHeight = wordCoordY[indexRow - 1 + cell.height + 1] - wordCoordY[indexRow - 1];
                        let imageWidth = wordCoordX[indexColumn - 1 + cell.width + 1] - wordCoordX[indexColumn - 1];
                        if (richWidth != -1) {
                            imageWidth = richWidth;
                            imageHeight = richHeight;
                        }
                        writer.writeStartElement('wp:extent');
                        writer.writeAttributeString('cx', StiString.format('{0}', this.convertTwipsToEmu(imageWidth)));
                        writer.writeAttributeString('cy', StiString.format('{0}', this.convertTwipsToEmu(imageHeight)));
                        writer.writeEndElement();
                        writer.writeStartElement('wp:effectExtent');
                        writer.writeAttributeString('l', '0');
                        writer.writeAttributeString('t', '0');
                        writer.writeAttributeString('r', '0');
                        writer.writeAttributeString('b', '0');
                        writer.writeEndElement();
                        writer.writeStartElement('wp:docPr');
                        writer.writeAttributeString('id', StiString.format('{0}', imageIndex + 2));
                        writer.writeAttributeString('name', StiString.format('Picture {0}', imageIndex + 1));
                        writer.writeAttributeString('descr', StiString.format('Image{0:D5}.jpg', imageIndex + 1));
                        if (hypRefText != null) {
                            if (hypRefId == -1) {
                                hypRefText = '#' + hypRefText;
                                if (this.hyperlinkList.containsKey(hypRefText)) {
                                    hypRefId = this.hyperlinkList.get(hypRefText);
                                } else {
                                    hypRefId = this.hyperlinkList.count;
                                    this.hyperlinkList.add(hypRefText, hypRefId);
                                }
                            }
                            writer.writeStartElement('a:hlinkClick');
                            writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
                            writer.writeAttributeString('r:id', StiString.format('hId{0}', hypRefId));
                            writer.writeEndElement();
                        }
                        writer.writeEndElement();
                        writer.writeStartElement('wp:cNvGraphicFramePr');
                        writer.writeStartElement('a:graphicFrameLocks');
                        writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
                        writer.writeAttributeString('noChangeAspect', '1');
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeStartElement('a:graphic');
                        writer.writeAttributeString('xmlns:a', 'http://schemas.openxmlformats.org/drawingml/2006/main');
                        writer.writeStartElement('a:graphicData');
                        writer.writeAttributeString('uri', 'http://schemas.openxmlformats.org/drawingml/2006/picture');
                        writer.writeStartElement('pic:pic');
                        writer.writeAttributeString('xmlns:pic', 'http://schemas.openxmlformats.org/drawingml/2006/picture');
                        writer.writeStartElement('pic:nvPicPr');
                        writer.writeStartElement('pic:cNvPr');
                        writer.writeAttributeString('id', '0');
                        writer.writeAttributeString('name', StiString.format('Image{0:D5}.jpg', imageIndex + 1));
                        writer.writeEndElement();
                        writer.writeStartElement('pic:cNvPicPr');
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeStartElement('pic:blipFill');
                        writer.writeStartElement('a:blip');
                        writer.writeAttributeString('r:embed', StiString.format('rId{0}', 5 + imageIndex));
                        writer.writeAttributeString('cstate', 'print');
                        writer.writeEndElement();
                        writer.writeStartElement('a:stretch');
                        writer.writeStartElement('a:fillRect');
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeStartElement('pic:spPr');
                        writer.writeStartElement('a:xfrm');
                        writer.writeStartElement('a:off');
                        writer.writeAttributeString('x', '0');
                        writer.writeAttributeString('y', '0');
                        writer.writeEndElement();
                        writer.writeStartElement('a:ext');
                        writer.writeAttributeString('cx', StiString.format('{0}', this.convertTwipsToEmu(imageWidth)));
                        writer.writeAttributeString('cy', StiString.format('{0}', this.convertTwipsToEmu(imageHeight)));
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeStartElement('a:prstGeom');
                        writer.writeAttributeString('prst', 'rect');
                        writer.writeStartElement('a:avLst');
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeEndElement();
                        writer.writeEndElement();
                        if (bkmRefId != -1) {
                            writer.writeStartElement('w:bookmarkEnd');
                            writer.writeAttributeString('w:id', bkmRefId.toString());
                            writer.writeEndElement();
                        }
                        writer.writeEndElement();
                    }
                }
            } else {
                if (bkmRefId != -1) {
                    writer.writeStartElement('w:bookmarkStart');
                    writer.writeAttributeString('w:id', bkmRefId.toString());
                    writer.writeAttributeString('w:name', bkmRefText);
                    writer.writeEndElement();
                    writer.writeStartElement('w:bookmarkEnd');
                    writer.writeAttributeString('w:id', bkmRefId.toString());
                    writer.writeEndElement();
                }
            }
            REFneedEmptyParagraph.ref = needEmptyParagraph;
        }
        writeTableInfo(writer, wordCoordX, maxCoordX) {
            writer.writeStartElement('w:tblPr');
            writer.writeStartElement('w:tblStyle');
            writer.writeAttributeString('w:val', 'a1');
            writer.writeEndElement();
            writer.writeStartElement('w:tblW');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeStartElement('w:tblLayout');
            writer.writeAttributeString('w:type', 'fixed');
            writer.writeEndElement();
            writer.writeStartElement('w:tblCellMar');
            writer.writeStartElement('w:top');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeStartElement('w:left');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeStartElement('w:bottom');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeStartElement('w:right');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('w:tblLook');
            writer.writeAttributeString('w:val', '04A0');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('w:tblGrid');
            for (let indexColumn = 1; indexColumn < maxCoordX; indexColumn++) {
                let columnWidth = wordCoordX[indexColumn] - wordCoordX[indexColumn - 1];
                writer.writeStartElement('w:gridCol');
                writer.writeAttributeString('w:w', StiString.format('{0}', columnWidth));
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
        }
        writeHtmlTags(writer, cell) {
            let stiText = cell.component;
            let inputText = cell.text;
            let baseTagsState = new StiHtmlTagsState(stiText.font.bold, stiText.font.italic, stiText.font.underline, stiText.font.strikeout, stiText.font.sizeInPoints, stiText.font.name, StiBrush.toColor(stiText.textBrush), StiBrush.toColor(stiText.brush), false, false, 0, 0, stiText.lineSpacing, stiText.horAlignment);
            let baseState = new StiHtmlState(baseTagsState, 0);
            let statesList = Stimulsoft.Base.Drawing.StiTextRenderer.parseHtmlToStates(inputText, baseState);
            let styleIndex = this.getStyleFromComponent(cell.component);
            this.writeParagraphBegin(writer, cell, styleIndex, statesList, 0);
            for (let index = 0; index < statesList.length; index++) {
                let htmlState = statesList[index];
                let state = htmlState.ts;
                if (htmlState.text.toString() == '\n' && index < statesList.stimulsoft().countItems - 1) {
                    writer.writeEndElement();
                    this.writeParagraphBegin(writer, cell, styleIndex, statesList, index + 1);
                    continue;
                }
                writer.writeStartElement('w:r');
                writer.writeStartElement('w:rPr');
                if (state.bold) {
                    writer.writeStartElement('w:b');
                    writer.writeEndElement();
                }
                if (state.italic) {
                    writer.writeStartElement('w:i');
                    writer.writeEndElement();
                }
                if (state.underline) {
                    writer.writeStartElement('w:u');
                    writer.writeAttributeString('w:val', 'single');
                    writer.writeEndElement();
                }
                if (state.strikeout) {
                    writer.writeStartElement('w:strike');
                    writer.writeEndElement();
                }
                if (state.superscript) {
                    writer.writeStartElement('w:vertAlign');
                    writer.writeAttributeString('w:val', 'superscript');
                    writer.writeEndElement();
                }
                if (state.subsript) {
                    writer.writeStartElement('w:vertAlign');
                    writer.writeAttributeString('w:val', 'subscript');
                    writer.writeEndElement();
                }
                if (state.fontColor.toArgb() != baseTagsState.fontColor.toArgb()) {
                    writer.writeStartElement('w:color');
                    writer.writeAttributeString('w:val', this.getColorString(state.fontColor));
                    writer.writeEndElement();
                }
                if (state.backColor.toArgb() != baseTagsState.backColor.toArgb()) {
                    writer.writeStartElement('w:shd');
                    writer.writeAttributeString('w:val', 'clear');
                    writer.writeAttributeString('w:color', 'auto');
                    writer.writeAttributeString('w:fill', this.getColorString(state.backColor));
                    writer.writeEndElement();
                }
                writer.writeStartElement('w:sz');
                writer.writeAttributeString('w:val', (state.fontSize * 2).toString());
                writer.writeEndElement();
                writer.writeStartElement('w:szCs');
                writer.writeAttributeString('w:val', (state.fontSize * 2).toString());
                writer.writeEndElement();
                writer.writeStartElement('w:rFonts');
                let fontName = state.fontName;
                this.fontList.set(fontName, fontName);
                writer.writeAttributeString('w:ascii', fontName);
                writer.writeAttributeString('w:hAnsi', fontName);
                writer.writeAttributeString('w:eastAsia', fontName);
                writer.writeAttributeString('w:cs', fontName);
                writer.writeEndElement();
                let letterSpacing = state.letterSpacing * state.fontSize * 18.8 + Stimulsoft['StiOptions'].Export.Word.spaceBetweenCharacters;
                if (letterSpacing != 0) {
                    writer.writeStartElement('w:spacing');
                    writer.writeAttributeString('w:val', letterSpacing.toString());
                    writer.writeEndElement();
                }
                if (cell.cellStyle.textOptions != null && cell.cellStyle.textOptions.rightToLeft) {
                    writer.writeStartElement('w:rtl');
                    writer.writeEndElement();
                }
                writer.writeEndElement();
                writer.writeStartElement('w:t');
                writer.writeAttributeString('xml:space', 'preserve');
                writer.writeString(Stimulsoft.Base.Drawing.StiTextRenderer.prepareStateText(htmlState.text).toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeEndElement();
        }
        writeParagraphBegin(writer, cell, styleIndex, states, stateIndex) {
            writer.writeStartElement('w:p');
            writer.writeStartElement('w:pPr');
            if (styleIndex != -1) {
                writer.writeStartElement('w:pStyle');
                writer.writeAttributeString('w:val', StiString.format('Style{0}', styleIndex));
                writer.writeEndElement();
            } else {
                this.writeRunProperties(writer, cell);
            }
            let lastState = states[stateIndex];
            if (lastState.text.toString() != '\n') {
                let indexS = stateIndex + 1;
                while (indexS < states.length && states[indexS].text.toString() != '\n') {
                    lastState = states[indexS];
                    indexS++;
                }
            }
            let lineSpacing = Stimulsoft['StiOptions'].Export.Word.lineSpacing * lastState.ts.lineHeight;
            if (StiWord2007ExportService.checkFontsToCorrectHeight(lastState.ts.fontName)) {
                lineSpacing *= 0.772;
            }
            if (lineSpacing != 1) {
                writer.writeStartElement('w:spacing');
                writer.writeAttributeString('w:line', StiMath.round2(lineSpacing * 240).toString());
                writer.writeEndElement();
            }
            let stHorAlignment = null;
            if (lastState.ts.textAlign == StiTextHorAlignment.Center)
                stHorAlignment = 'center';
            if (lastState.ts.textAlign == StiTextHorAlignment.Right)
                stHorAlignment = 'right';
            if (lastState.ts.textAlign == StiTextHorAlignment.Width)
                stHorAlignment = 'both';
            if (stHorAlignment != null) {
                writer.writeStartElement('w:jc');
                writer.writeAttributeString('w:val', stHorAlignment);
                writer.writeEndElement();
            }
            writer.writeEndElement();
        }
        writeRunProperties(writer, cell) {
            writer.writeStartElement('w:rPr');
            writer.writeStartElement('w:rFonts');
            let fontName = cell.cellStyle.font.name;
            this.fontList.set(fontName, fontName);
            writer.writeAttributeString('w:ascii', fontName);
            writer.writeAttributeString('w:hAnsi', fontName);
            writer.writeAttributeString('w:eastAsia', fontName);
            writer.writeAttributeString('w:cs', fontName);
            writer.writeEndElement();
            if (cell.cellStyle.font.bold) {
                writer.writeStartElement('w:b');
                writer.writeEndElement();
            }
            if (cell.cellStyle.font.italic) {
                writer.writeStartElement('w:i');
                writer.writeEndElement();
            }
            if (cell.cellStyle.font.underline) {
                writer.writeStartElement('w:u');
                writer.writeAttributeString('w:val', 'single');
                writer.writeEndElement();
            }
            writer.writeStartElement('w:color');
            writer.writeAttributeString('w:val', this.getColorString(cell.cellStyle.textColor));
            writer.writeEndElement();
            writer.writeStartElement('w:sz');
            writer.writeAttributeString('w:val', StiString.format('{0}', cell.cellStyle.font.sizeInPoints * 2));
            writer.writeEndElement();
            if (Stimulsoft['StiOptions'].Export.Word.spaceBetweenCharacters != 0) {
                writer.writeStartElement('w:spacing');
                writer.writeAttributeString('w:val', StiString.format('{0}', Stimulsoft['StiOptions'].Export.Word.spaceBetweenCharacters));
                writer.writeEndElement();
            }
            if (cell.cellStyle.textOptions != null && cell.cellStyle.textOptions.rightToLeft) {
                if (cell.cellStyle.font.bold) {
                    writer.writeStartElement('w:bCs');
                    writer.writeEndElement();
                }
                if (cell.cellStyle.font.italic) {
                    writer.writeStartElement('w:iCs');
                    writer.writeEndElement();
                }
                writer.writeStartElement('w:szCs');
                writer.writeAttributeString('w:val', StiString.format('{0}', cell.cellStyle.font.sizeInPoints * 2));
                writer.writeEndElement();
                writer.writeStartElement('w:rtl');
                writer.writeEndElement();
            }
            writer.writeEndElement();
        }
        renderBorder2TableGetValues(rowIndex, columnIndex, REFstyles) {
            let styles = REFstyles.ref;
            let sides = StiBorderSides.None;
            let sb = new StringBuilder();
            if (this.matrix.bordersY[rowIndex - 1][columnIndex - 1] != null) {
                sides |= StiBorderSides.Left;
            }
            if (this.matrix.bordersY[rowIndex - 1][columnIndex - 1 + 1] != null) {
                sides |= StiBorderSides.Right;
            }
            if (this.matrix.bordersX[rowIndex - 1][columnIndex - 1] != null) {
                sb.append('\\t' + this.getLineStyle2TableGetValues(this.matrix.bordersX[rowIndex - 1][columnIndex - 1]));
                sides |= StiBorderSides.Top;
            }
            if (this.matrix.bordersX[rowIndex - 1 + 1][columnIndex - 1] != null) {
                sb.append('\\b' + this.getLineStyle2TableGetValues(this.matrix.bordersX[rowIndex - 1 + 1][columnIndex - 1]));
                sides |= StiBorderSides.Bottom;
            }
            styles = sb.toString();
            REFstyles.ref = styles;
            return sides;
        }
        getLineStyle2TableGetValues(border) {
            let sb = new StringBuilder();
            sb.append(this.getLineStyle(border.style));
            sb.append(StiMath.trunc(border.size * 15));
            sb.append(StiString.format('c{0}', this.getColorString(border.color)));
            return sb.toString();
        }
        writeDocument(pages, report, hasDividedPages) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('w:document');
            writer.writeAttributeString('xmlns:ve', 'http://schemas.openxmlformats.org/markup-compatibility/2006');
            writer.writeAttributeString('xmlns:o', 'urn:schemas-microsoft-com:office:office');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:m', 'http://schemas.openxmlformats.org/officeDocument/2006/math');
            writer.writeAttributeString('xmlns:v', 'urn:schemas-microsoft-com:vml');
            writer.writeAttributeString('xmlns:wp', 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing');
            writer.writeAttributeString('xmlns:w10', 'urn:schemas-microsoft-com:office:word');
            writer.writeAttributeString('xmlns:w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main');
            writer.writeAttributeString('xmlns:wne', 'http://schemas.microsoft.com/office/word/2006/wordml');
            writer.writeStartElement('w:body');
            let allPages = pages;
            pages = null;
            let indexPage = 0;
            let partIndex = 0;
            while (indexPage < allPages.count) {
                pages = new StiPagesCollection(report, allPages);
                pages.cacheMode = report.renderedPages.cacheMode;
                pages.addV2Internal(allPages.getPageWithoutCache(indexPage));
                while (indexPage < allPages.count - 1 && this.comparePages(allPages.getPageWithoutCache(indexPage + 1), allPages.getPageWithoutCache(indexPage))) {
                    indexPage++;
                    pages.addV2Internal(allPages.getPageWithoutCache(indexPage));
                }
                let firstPage = pages.getByIndex(0);
                if (firstPage != null) {
                    pages.getPage(firstPage);
                    if (this.usePageHeadersAndFooters) {
                        let pages2 = new StiPagesCollection(report, report.renderedPages);
                        pages2.cacheMode = report.renderedPages.cacheMode;
                        pages2.add(pages.getByIndex(0));
                        this.matrix = new __.b.StiMatrix(pages2, Stimulsoft['StiOptions'].Export.Word.divideBigCells, this);
                        this.matrix.scanComponentsPlacement(false);
                        let startLine = 0;
                        let endLine = 0;
                        let needHeader = false;
                        endLine = this.matrix.coordY.countItems - 1 - 1;
                        while (endLine > 0 && this.matrix.linePlacement[endLine] != __.b.StiTableLineInfo.PageHeader)
                            endLine--;
                        if (endLine >= 0 && this.matrix.linePlacement[endLine] == __.b.StiTableLineInfo.PageHeader) {
                            startLine = 0;
                            while (this.matrix.linePlacement[startLine] != __.b.StiTableLineInfo.PageHeader)
                                startLine++;
                            needHeader = true;
                        }
                        this.headersData.push(this.writeHeader(startLine, endLine, needHeader));
                        if (this.imageCache.imagePackedStore.length > 0) {
                            this.headersRels.push(this.writeHeaderFooterRels());
                        } else
                            this.headersRels.push(null);
                        let needFooter = false;
                        startLine = 0;
                        while (this.matrix.linePlacement[startLine] != __.b.StiTableLineInfo.PageFooter && startLine < this.matrix.coordY.countItems - 1 - 1)
                            startLine++;
                        if (this.matrix.linePlacement[startLine] == __.b.StiTableLineInfo.PageFooter) {
                            endLine = this.matrix.coordY.countItems - 1 - 1;
                            while (this.matrix.linePlacement[endLine] != __.b.StiTableLineInfo.PageFooter)
                                endLine--;
                            needFooter = true;
                        }
                        this.footersData.push(this.writeFooter(startLine, endLine, needFooter));
                        if (this.imageCache.imagePackedStore.length > 0) {
                            this.footersRels.push(this.writeHeaderFooterRels());
                        } else
                            this.footersRels.push(null);
                        this.matrix = new __.b.StiMatrix(pages, Stimulsoft['StiOptions'].Export.Word.divideBigCells, this);
                        this.matrix.scanComponentsPlacement(true);
                        endLine = this.matrix.coordY.countItems - 1 - 1;
                        this.writeFromMatrix(writer, 0, endLine, false);
                    } else {
                        this.matrix = new __.b.StiMatrix(pages, Stimulsoft['StiOptions'].Export.Word.divideBigCells, this, null, __.b.StiDataExportMode.AllBands, hasDividedPages);
                        this.writeFromMatrix(writer, 0, this.matrix.coordY.countItems - 1 - 1, true);
                    }
                    if (indexPage < allPages.count - 1) {
                        writer.writeStartElement('w:p');
                        writer.writeStartElement('w:pPr');
                        this.writePageInfo(writer, pages.getByIndex(0), partIndex);
                        writer.writeEndElement();
                        writer.writeEndElement();
                    }
                }
                indexPage++;
                partIndex++;
            }
            if (pages.count > 0) {
                this.writePageInfo(writer, pages.getByIndex(0), partIndex - 1);
            }
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        comparePages(page1, page2) {
            let st1 = page1.excelSheetValue;
            if (StiString.isNullOrEmpty(st1))
                st1 = '';
            let st2 = page2.excelSheetValue;
            if (StiString.isNullOrEmpty(st2))
                st2 = '';
            if (st1 != st2)
                return false;
            if (page1.orientation != page2.orientation)
                return false;
            if (!page1.margins.equals(page2.margins))
                return false;
            if (page1.unlimitedHeight != page2.unlimitedHeight)
                return false;
            return true;
        }
        writePageInfo(writer, page, partIndex) {
            let pageHeight = this.convertHiToTwips(page.unit.convertToHInches(page.pageHeight * (this.usePageHeadersAndFooters ? 1 : page.segmentPerHeight)));
            let pageWidth = this.convertHiToTwips(page.unit.convertToHInches(page.pageWidth * (this.usePageHeadersAndFooters ? 1 : page.segmentPerWidth)));
            let mgLeft = this.convertHiToTwips(page.unit.convertToHInches(page.margins.left));
            let mgRight = this.convertHiToTwips(page.unit.convertToHInches(page.margins.right));
            let mgTop = this.convertHiToTwips(page.unit.convertToHInches(page.margins.top));
            let mgBottom = this.convertHiToTwips(page.unit.convertToHInches(page.margins.bottom)) - Stimulsoft['StiOptions'].Export.Word.bottomMarginCorrection;
            if (mgBottom < 0)
                mgBottom = 0;
            if (pageWidth > 31500)
                pageWidth = 31500;
            if (pageHeight > 31500)
                pageHeight = 31500;
            writer.writeStartElement('w:sectPr');
            if (this.usePageHeadersAndFooters) {
                writer.writeStartElement('w:headerReference');
                writer.writeAttributeString('w:type', 'default');
                writer.writeAttributeString('r:id', StiString.format('rIdh{0}', partIndex + 1));
                writer.writeEndElement();
                writer.writeStartElement('w:footerReference');
                writer.writeAttributeString('w:type', 'default');
                writer.writeAttributeString('r:id', StiString.format('rIdf{0}', partIndex + 1));
                writer.writeEndElement();
            } else if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                writer.writeStartElement('w:headerReference');
                writer.writeAttributeString('w:type', 'default');
                writer.writeAttributeString('r:id', 'rIdh1');
                writer.writeEndElement();
            }
            writer.writeStartElement('w:pgSz');
            writer.writeAttributeString('w:w', StiString.format('{0}', pageWidth));
            writer.writeAttributeString('w:h', StiString.format('{0}', pageHeight));
            if (page.orientation == StiPageOrientation.Landscape) {
                writer.writeAttributeString('w:orient', 'landscape');
            }
            writer.writeEndElement();
            writer.writeStartElement('w:pgMar');
            writer.writeAttributeString('w:top', StiString.format('{0}', mgTop));
            writer.writeAttributeString('w:right', StiString.format('{0}', mgRight));
            writer.writeAttributeString('w:bottom', StiString.format('{0}', mgBottom));
            writer.writeAttributeString('w:left', StiString.format('{0}', mgLeft));
            writer.writeAttributeString('w:header', StiString.format('{0}', mgTop));
            writer.writeAttributeString('w:footer', StiString.format('{0}', mgBottom));
            writer.writeAttributeString('w:gutter', '0');
            writer.writeEndElement();
            writer.writeEndElement();
        }
        writeBorders(writer, indexRow, indexColumn, height, width) {
            let needBorderLeft = true;
            let needBorderRight = true;
            for (let index = 0; index < height; index++) {
                if (this.matrix.bordersY[indexRow + index][indexColumn] == null)
                    needBorderLeft = false;
                if (this.matrix.bordersY[indexRow + index][indexColumn + width] == null)
                    needBorderRight = false;
            }
            let needBorderTop = true;
            let needBorderBottom = true;
            for (let index = 0; index < width; index++) {
                if (this.matrix.bordersX[indexRow][indexColumn + index] == null)
                    needBorderTop = false;
                if (this.matrix.bordersX[indexRow + height][indexColumn + index] == null)
                    needBorderBottom = false;
            }
            if (needBorderTop || needBorderLeft || needBorderBottom || needBorderRight) {
                writer.writeStartElement('w:tcBorders');
                if (needBorderTop)
                    this.writeBorderData(writer, 'w:top', this.matrix.bordersX[indexRow][indexColumn]);
                if (needBorderLeft)
                    this.writeBorderData(writer, 'w:left', this.matrix.bordersY[indexRow][indexColumn]);
                if (needBorderBottom)
                    this.writeBorderData(writer, 'w:bottom', this.matrix.bordersX[indexRow + height][indexColumn]);
                if (needBorderRight)
                    this.writeBorderData(writer, 'w:right', this.matrix.bordersY[indexRow][indexColumn + width]);
                writer.writeEndElement();
            }
        }
        writeBorderData(writer, side, border) {
            if (border != null) {
                let style = this.getLineStyle(border.style);
                if (style != '') {
                    writer.writeStartElement(side);
                    writer.writeAttributeString('w:val', style);
                    writer.writeAttributeString('w:sz', StiString.format('{0}', StiMath.trunc(border.size * 5)));
                    writer.writeAttributeString('w:space', '0');
                    writer.writeAttributeString('w:color', this.getColorString(border.color));
                    writer.writeEndElement();
                }
            }
        }
        writeFootNotes() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('w:footnotes');
            writer.writeAttributeString('xmlns:ve', 'http://schemas.openxmlformats.org/markup-compatibility/2006');
            writer.writeAttributeString('xmlns:o', 'urn:schemas-microsoft-com:office:office');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:m', 'http://schemas.openxmlformats.org/officeDocument/2006/math');
            writer.writeAttributeString('xmlns:v', 'urn:schemas-microsoft-com:vml');
            writer.writeAttributeString('xmlns:wp', 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing');
            writer.writeAttributeString('xmlns:w10', 'urn:schemas-microsoft-com:office:word');
            writer.writeAttributeString('xmlns:w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main');
            writer.writeAttributeString('xmlns:wne', 'http://schemas.microsoft.com/office/word/2006/wordml');
            writer.writeStartElement('w:footnote');
            writer.writeAttributeString('w:type', 'separator');
            writer.writeAttributeString('w:id', '0');
            writer.writeStartElement('w:p');
            writer.writeStartElement('w:r');
            writer.writeStartElement('w:separator');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('w:footnote');
            writer.writeAttributeString('w:type', 'continuationSeparator');
            writer.writeAttributeString('w:id', '1');
            writer.writeStartElement('w:p');
            writer.writeStartElement('w:r');
            writer.writeStartElement('w:continuationSeparator');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeEndNotes() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('w:endnotes');
            writer.writeAttributeString('xmlns:ve', 'http://schemas.openxmlformats.org/markup-compatibility/2006');
            writer.writeAttributeString('xmlns:o', 'urn:schemas-microsoft-com:office:office');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:m', 'http://schemas.openxmlformats.org/officeDocument/2006/math');
            writer.writeAttributeString('xmlns:v', 'urn:schemas-microsoft-com:vml');
            writer.writeAttributeString('xmlns:wp', 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing');
            writer.writeAttributeString('xmlns:w10', 'urn:schemas-microsoft-com:office:word');
            writer.writeAttributeString('xmlns:w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main');
            writer.writeAttributeString('xmlns:wne', 'http://schemas.microsoft.com/office/word/2006/wordml');
            writer.writeStartElement('w:endnote');
            writer.writeAttributeString('w:type', 'separator');
            writer.writeAttributeString('w:id', '0');
            writer.writeStartElement('w:p');
            writer.writeStartElement('w:r');
            writer.writeStartElement('w:separator');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('w:endnote');
            writer.writeAttributeString('w:type', 'continuationSeparator');
            writer.writeAttributeString('w:id', '1');
            writer.writeStartElement('w:p');
            writer.writeStartElement('w:r');
            writer.writeStartElement('w:continuationSeparator');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeHeader(startLine, endLine, needHeader) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('w:hdr');
            writer.writeAttributeString('xmlns:ve', 'http://schemas.openxmlformats.org/markup-compatibility/2006');
            writer.writeAttributeString('xmlns:o', 'urn:schemas-microsoft-com:office:office');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:m', 'http://schemas.openxmlformats.org/officeDocument/2006/math');
            writer.writeAttributeString('xmlns:v', 'urn:schemas-microsoft-com:vml');
            writer.writeAttributeString('xmlns:wp', 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing');
            writer.writeAttributeString('xmlns:w10', 'urn:schemas-microsoft-com:office:word');
            writer.writeAttributeString('xmlns:w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main');
            writer.writeAttributeString('xmlns:wne', 'http://schemas.microsoft.com/office/word/2006/wordml');
            if (needHeader) {
                this.writeFromMatrix(writer, startLine, endLine, true);
            } else {
                writer.writeStartElement('w:p');
                writer.writeStartElement('w:r');
                writer.writeStartElement('w:cr');
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeFooter(startLine, endLine, needFooter) {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('w:ftr');
            writer.writeAttributeString('xmlns:ve', 'http://schemas.openxmlformats.org/markup-compatibility/2006');
            writer.writeAttributeString('xmlns:o', 'urn:schemas-microsoft-com:office:office');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:m', 'http://schemas.openxmlformats.org/officeDocument/2006/math');
            writer.writeAttributeString('xmlns:v', 'urn:schemas-microsoft-com:vml');
            writer.writeAttributeString('xmlns:wp', 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing');
            writer.writeAttributeString('xmlns:w10', 'urn:schemas-microsoft-com:office:word');
            writer.writeAttributeString('xmlns:w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main');
            writer.writeAttributeString('xmlns:wne', 'http://schemas.microsoft.com/office/word/2006/wordml');
            if (needFooter) {
                this.writeFromMatrix(writer, startLine, endLine, true);
            } else {
                writer.writeStartElement('w:p');
                writer.writeStartElement('w:r');
                writer.writeStartElement('w:cr');
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeContentTypes() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Types');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/content-types');
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'rels');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-package.relationships+xml');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'xml');
            writer.writeAttributeString('ContentType', 'application/xml');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'jpeg');
            writer.writeAttributeString('ContentType', 'image/jpeg');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'emf');
            writer.writeAttributeString('ContentType', 'image/x-emf');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'rtf');
            writer.writeAttributeString('ContentType', 'application/rtf');
            writer.writeEndElement();
            writer.writeStartElement('Default');
            writer.writeAttributeString('Extension', 'png');
            writer.writeAttributeString('ContentType', 'image/png');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/docProps/app.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.extended-properties+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/docProps/core.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-package.core-properties+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/word/document.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/word/styles.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/word/settings.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/word/webSettings.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml');
            writer.writeEndElement();
            writer.writeStartElement('Override');
            writer.writeAttributeString('PartName', '/word/fontTable.xml');
            writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml');
            writer.writeEndElement();
            if (this.usePageHeadersAndFooters) {
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', '/word/footnotes.xml');
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml');
                writer.writeEndElement();
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', '/word/endnotes.xml');
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml');
                writer.writeEndElement();
                for (let index = 0; index < this.headersData.length; index++) {
                    writer.writeStartElement('Override');
                    writer.writeAttributeString('PartName', StiString.format('/word/footer{0}.xml', index + 1));
                    writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml');
                    writer.writeEndElement();
                    writer.writeStartElement('Override');
                    writer.writeAttributeString('PartName', StiString.format('/word/header{0}.xml', index + 1));
                    writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml');
                    writer.writeEndElement();
                }
            } else if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', '/word/footnotes.xml');
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml');
                writer.writeEndElement();
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', '/word/endnotes.xml');
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml');
                writer.writeEndElement();
                writer.writeStartElement('Override');
                writer.writeAttributeString('PartName', '/word/headerAdditional.xml');
                writer.writeAttributeString('ContentType', 'application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml');
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeMainRels() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId1');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument');
            writer.writeAttributeString('Target', 'word/document.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId2');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties');
            writer.writeAttributeString('Target', 'docProps/core.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId3');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties');
            writer.writeAttributeString('Target', 'docProps/app.xml');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeDocPropsApp() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Properties');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties');
            writer.writeAttributeString('xmlns:vt', 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes');
            writer.writeElementString('Application', 'Microsoft Office Word');
            writer.writeElementString('Company', this.docCompanyString == null ? '' : this.docCompanyString);
            writer.writeElementString('Template', 'Normal.dotm');
            writer.writeElementString('TotalTime', '0');
            writer.writeElementString('Pages', '1');
            writer.writeElementString('Words', '1');
            writer.writeElementString('Characters', '1');
            writer.writeElementString('DocSecurity', this.restrictEditing == __.b.StiWord2007RestrictEditing.No ? '0' : '8');
            writer.writeElementString('Lines', '1');
            writer.writeElementString('Paragraphs', '1');
            writer.writeElementString('ScaleCrop', 'false');
            writer.writeElementString('LinksUpToDate', 'false');
            writer.writeElementString('CharactersWithSpaces', '1');
            writer.writeElementString('SharedDoc', 'false');
            writer.writeElementString('HyperlinksChanged', 'false');
            writer.writeElementString('AppVersion', '12.0000');
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeDocPropsCore() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('cp:coreProperties');
            writer.writeAttributeString('xmlns:cp', 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeAttributeString('xmlns:dcterms', 'http://purl.org/dc/terms/');
            writer.writeAttributeString('xmlns:dcmitype', 'http://purl.org/dc/dcmitype/');
            writer.writeAttributeString('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
            let dateTime = StiString.format('{0}{1}', DateTime.now.toString('yyyy-MM-dd'), DateTime.now.toString('THH:mm:ssZ'));
            writer.writeElementString('dc:title', this.report.reportName == null ? '' : this.report.reportName);
            writer.writeElementString('dc:subject', this.report.reportAlias == null ? '' : this.report.reportAlias);
            writer.writeElementString('dc:creator', this.report.reportAuthor == null ? '' : this.report.reportAuthor);
            writer.writeElementString('cp:keywords', '');
            writer.writeElementString('dc:description', this.report.reportDescription == null ? '' : this.report.reportDescription);
            writer.writeElementString('cp:lastModifiedBy', this.docLastModifiedString == null ? '' : this.docLastModifiedString);
            writer.writeElementString('cp:revision', '1');
            writer.writeStartElement('dcterms:created');
            writer.writeAttributeString('xsi:type', 'dcterms:W3CDTF');
            writer.writeString(dateTime);
            writer.writeEndElement();
            writer.writeStartElement('dcterms:modified');
            writer.writeAttributeString('xsi:type', 'dcterms:W3CDTF');
            writer.writeString(dateTime);
            writer.writeEndElement();
            writer.writeElementString('cp:contentStatus', Stimulsoft.StiVersion.platform());
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeSettings() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('w:settings');
            writer.writeAttributeString('xmlns:o', 'urn:schemas-microsoft-com:office:office');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:m', 'http://schemas.openxmlformats.org/officeDocument/2006/math');
            writer.writeAttributeString('xmlns:v', 'urn:schemas-microsoft-com:vml');
            writer.writeAttributeString('xmlns:w10', 'urn:schemas-microsoft-com:office:word');
            writer.writeAttributeString('xmlns:w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main');
            writer.writeAttributeString('xmlns:sl', 'http://schemas.openxmlformats.org/schemaLibrary/2006/main');
            if (this.restrictEditing != __.b.StiWord2007RestrictEditing.No) {
                writer.writeStartElement('w:documentProtection');
                writer.writeAttributeString('w:edit', 'readOnly');
                writer.writeAttributeString('w:enforcement', '1');
                writer.writeAttributeString('w:cryptProviderType', 'rsaFull');
                writer.writeAttributeString('w:cryptAlgorithmClass', 'hash');
                writer.writeAttributeString('w:cryptAlgorithmType', 'typeAny');
                writer.writeAttributeString('w:cryptAlgorithmSid', '4');
                writer.writeAttributeString('w:cryptSpinCount', '50000');
                writer.writeAttributeString('w:hash', 'aw5VYrxGrQVOl7/SJDI9GvbcwaE=');
                writer.writeAttributeString('w:salt', '974T1u8C/8p0OAB+3ev3nQ==');
                writer.writeEndElement();
            }
            writer.writeStartElement('w:zoom');
            writer.writeAttributeString('w:percent', '100');
            writer.writeEndElement();
            writer.writeStartElement('w:proofState');
            writer.writeAttributeString('w:spelling', 'clean');
            writer.writeAttributeString('w:grammar', 'clean');
            writer.writeEndElement();
            writer.writeStartElement('w:defaultTabStop');
            writer.writeAttributeString('w:val', '708');
            writer.writeEndElement();
            writer.writeStartElement('w:characterSpacingControl');
            writer.writeAttributeString('w:val', 'doNotCompress');
            writer.writeEndElement();
            if (this.usePageHeadersAndFooters) {
                writer.writeStartElement('w:footnotePr');
                writer.writeStartElement('w:footnote');
                writer.writeAttributeString('w:id', '0');
                writer.writeEndElement();
                writer.writeStartElement('w:footnote');
                writer.writeAttributeString('w:id', '1');
                writer.writeEndElement();
                writer.writeEndElement();
                writer.writeStartElement('w:endnotePr');
                writer.writeStartElement('w:endnote');
                writer.writeAttributeString('w:id', '0');
                writer.writeEndElement();
                writer.writeStartElement('w:endnote');
                writer.writeAttributeString('w:id', '1');
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement('w:compat');
            writer.writeEndElement();
            writer.writeStartElement('m:mathPr');
            writer.writeStartElement('m:mathFont');
            writer.writeAttributeString('m:val', 'Cambria Math');
            writer.writeEndElement();
            writer.writeStartElement('m:brkBin');
            writer.writeAttributeString('m:val', 'before');
            writer.writeEndElement();
            writer.writeStartElement('m:brkBinSub');
            writer.writeAttributeString('m:val', '--');
            writer.writeEndElement();
            writer.writeStartElement('m:smallFrac');
            writer.writeAttributeString('m:val', 'off');
            writer.writeEndElement();
            writer.writeStartElement('m:dispDef');
            writer.writeEndElement();
            writer.writeStartElement('m:lMargin');
            writer.writeAttributeString('m:val', '0');
            writer.writeEndElement();
            writer.writeStartElement('m:rMargin');
            writer.writeAttributeString('m:val', '0');
            writer.writeEndElement();
            writer.writeStartElement('m:defJc');
            writer.writeAttributeString('m:val', 'centerGroup');
            writer.writeEndElement();
            writer.writeStartElement('m:wrapIndent');
            writer.writeAttributeString('m:val', '1440');
            writer.writeEndElement();
            writer.writeStartElement('m:intLim');
            writer.writeAttributeString('m:val', 'subSup');
            writer.writeEndElement();
            writer.writeStartElement('m:naryLim');
            writer.writeAttributeString('m:val', 'undOvr');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('w:themeFontLang');
            writer.writeAttributeString('w:val', 'en-EN');
            writer.writeEndElement();
            writer.writeStartElement('w:clrSchemeMapping');
            writer.writeAttributeString('w:bg1', 'light1');
            writer.writeAttributeString('w:t1', 'dark1');
            writer.writeAttributeString('w:bg2', 'light2');
            writer.writeAttributeString('w:t2', 'dark2');
            writer.writeAttributeString('w:accent1', 'accent1');
            writer.writeAttributeString('w:accent2', 'accent2');
            writer.writeAttributeString('w:accent3', 'accent3');
            writer.writeAttributeString('w:accent4', 'accent4');
            writer.writeAttributeString('w:accent5', 'accent5');
            writer.writeAttributeString('w:accent6', 'accent6');
            writer.writeAttributeString('w:hyperlink', 'hyperlink');
            writer.writeAttributeString('w:followedHyperlink', 'followedHyperlink');
            writer.writeEndElement();
            writer.writeStartElement('w:shapeDefaults');
            writer.writeStartElement('o:shapedefaults');
            writer.writeAttributeString('v:ext', 'edit');
            writer.writeAttributeString('spidmax', '2050');
            writer.writeEndElement();
            writer.writeStartElement('o:shapelayout');
            writer.writeAttributeString('v:ext', 'edit');
            writer.writeStartElement('o:idmap');
            writer.writeAttributeString('v:ext', 'edit');
            writer.writeAttributeString('data', '1');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('w:decimalSymbol');
            writer.writeAttributeString('w:val', ',');
            writer.writeEndElement();
            writer.writeStartElement('w:listSeparator');
            writer.writeAttributeString('w:val', ';');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeWebSettings() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('w:webSettings');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main');
            writer.writeStartElement('w:optimizeForBrowser');
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeFontTable() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('w:fonts');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main');
            this.fontList.set('Calibri', 'Calibri');
            this.fontList.set('Cambria', 'Cambria');
            for (let fontName of this.fontList.values) {
                writer.writeStartElement('w:font');
                writer.writeAttributeString('w:name', fontName);
                writer.writeFullEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeDocumentRels() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId1');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles');
            writer.writeAttributeString('Target', 'styles.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId2');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings');
            writer.writeAttributeString('Target', 'settings.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId3');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings');
            writer.writeAttributeString('Target', 'webSettings.xml');
            writer.writeEndElement();
            writer.writeStartElement('Relationship');
            writer.writeAttributeString('Id', 'rId4');
            writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable');
            writer.writeAttributeString('Target', 'fontTable.xml');
            writer.writeEndElement();
            for (let index = 0; index < this.imageCache.imagePackedStore.length; index++) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', 5 + index));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image');
                writer.writeAttributeString('Target', StiString.format('media/image{0:D5}.jpeg', index + 1));
                writer.writeEndElement();
            }
            if (this.usePageHeadersAndFooters) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', 5 + this.imageCache.imagePackedStore.length + 0));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes');
                writer.writeAttributeString('Target', 'footnotes.xml');
                writer.writeEndElement();
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', 5 + this.imageCache.imagePackedStore.length + 1));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes');
                writer.writeAttributeString('Target', 'endnotes.xml');
                writer.writeEndElement();
                for (let index = 0; index < this.headersData.length; index++) {
                    writer.writeStartElement('Relationship');
                    writer.writeAttributeString('Id', StiString.format('rIdh{0}', index + 1));
                    writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/header');
                    writer.writeAttributeString('Target', StiString.format('header{0}.xml', index + 1));
                    writer.writeEndElement();
                    writer.writeStartElement('Relationship');
                    writer.writeAttributeString('Id', StiString.format('rIdf{0}', index + 1));
                    writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer');
                    writer.writeAttributeString('Target', StiString.format('footer{0}.xml', index + 1));
                    writer.writeEndElement();
                }
            } else if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', 5 + this.imageCache.imagePackedStore.length + 0));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes');
                writer.writeAttributeString('Target', 'footnotes.xml');
                writer.writeEndElement();
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', 5 + this.imageCache.imagePackedStore.length + 1));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes');
                writer.writeAttributeString('Target', 'endnotes.xml');
                writer.writeEndElement();
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', 'rIdh1');
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/header');
                writer.writeAttributeString('Target', 'headerAdditional.xml');
                writer.writeEndElement();
            }
            if (this.hyperlinkList.count > 0) {
                for (let key of this.hyperlinkList.keys) {
                    writer.writeStartElement('Relationship');
                    writer.writeAttributeString('Id', StiString.format('hId{0}', StiMath.trunc(this.hyperlinkList.get(key))));
                    writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink');
                    writer.writeAttributeString('Target', key);
                    writer.writeAttributeString('TargetMode', 'External');
                    writer.writeEndElement();
                }
            }
            if (this.embedsList.length > 0) {
                for (let index = 0; index < this.embedsList.length; index++) {
                    writer.writeStartElement('Relationship');
                    writer.writeAttributeString('Id', StiString.format('reId{0}', 1 + index));
                    writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/aFChunk');
                    writer.writeAttributeString('Target', StiString.format('embeddings/richtext{0:D5}.rtf', index + 1));
                    writer.writeAttributeString('TargetMode', 'Internal');
                    writer.writeEndElement();
                }
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeHeaderFooterRels() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('Relationships');
            writer.writeAttributeString('xmlns', 'http://schemas.openxmlformats.org/package/2006/relationships');
            for (let index = 0; index < this.imageCache.imagePackedStore.length; index++) {
                writer.writeStartElement('Relationship');
                writer.writeAttributeString('Id', StiString.format('rId{0}', 5 + index));
                writer.writeAttributeString('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image');
                writer.writeAttributeString('Target', StiString.format('media/image{0:D5}.jpeg', index + 1));
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeStyles() {
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Encoding.UTF8, ms);
            writer.indentation = this.xmlIndentation < 0 ? 0 : this.xmlIndentation;
            writer.formatting = this.xmlIndentation < 0 ? Formatting.None : Formatting.Indented;
            writer.writeStartDocument();
            writer.writeStartElement('w:styles');
            writer.writeAttributeString('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
            writer.writeAttributeString('xmlns:w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main');
            writer.writeStartElement('w:style');
            writer.writeAttributeString('w:type', 'paragraph');
            writer.writeAttributeString('w:default', '1');
            writer.writeAttributeString('w:styleId', 'a');
            writer.writeStartElement('w:name');
            writer.writeAttributeString('w:val', 'Normal');
            writer.writeEndElement();
            writer.writeStartElement('w:qFormat');
            writer.writeEndElement();
            writer.writeStartElement('w:pPr');
            writer.writeStartElement('w:spacing');
            writer.writeAttributeString('w:after', '0');
            writer.writeAttributeString('w:line', '240');
            writer.writeAttributeString('w:lineRule', 'auto');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('w:rPr');
            writer.writeStartElement('w:sz');
            writer.writeAttributeString('w:val', StiString.format('{0}', StiMath.round2(Stimulsoft['StiOptions'].Export.Word.normalStyleDefaultFontSize * 2)));
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('w:style');
            writer.writeAttributeString('w:type', 'character');
            writer.writeAttributeString('w:default', '1');
            writer.writeAttributeString('w:styleId', 'a0');
            writer.writeStartElement('w:name');
            writer.writeAttributeString('w:val', 'Default Paragraph Font');
            writer.writeEndElement();
            writer.writeStartElement('w:uiPriority');
            writer.writeAttributeString('w:val', '1');
            writer.writeEndElement();
            writer.writeStartElement('w:semiHidden');
            writer.writeEndElement();
            writer.writeStartElement('w:unhideWhenUsed');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('w:style');
            writer.writeAttributeString('w:type', 'table');
            writer.writeAttributeString('w:default', '1');
            writer.writeAttributeString('w:styleId', 'a1');
            writer.writeStartElement('w:name');
            writer.writeAttributeString('w:val', 'Normal Table');
            writer.writeEndElement();
            writer.writeStartElement('w:uiPriority');
            writer.writeAttributeString('w:val', '99');
            writer.writeEndElement();
            writer.writeStartElement('w:semiHidden');
            writer.writeEndElement();
            writer.writeStartElement('w:unhideWhenUsed');
            writer.writeEndElement();
            writer.writeStartElement('w:qFormat');
            writer.writeEndElement();
            writer.writeStartElement('w:tblPr');
            writer.writeStartElement('w:tblInd');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeStartElement('w:tblCellMar');
            writer.writeStartElement('w:top');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeStartElement('w:left');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeStartElement('w:bottom');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeStartElement('w:right');
            writer.writeAttributeString('w:w', '0');
            writer.writeAttributeString('w:type', 'dxa');
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeStartElement('w:style');
            writer.writeAttributeString('w:type', 'numbering');
            writer.writeAttributeString('w:default', '1');
            writer.writeAttributeString('w:styleId', 'a2');
            writer.writeStartElement('w:name');
            writer.writeAttributeString('w:val', 'No List');
            writer.writeEndElement();
            writer.writeStartElement('w:uiPriority');
            writer.writeAttributeString('w:val', '99');
            writer.writeEndElement();
            writer.writeStartElement('w:semiHidden');
            writer.writeEndElement();
            writer.writeStartElement('w:unhideWhenUsed');
            writer.writeEndElement();
            writer.writeEndElement();
            for (let index = 0; index < this.styleList.length; index++) {
                let style = this.styleList[index];
                writer.writeStartElement('w:style');
                writer.writeAttributeString('w:type', 'paragraph');
                writer.writeAttributeString('w:customStyle', '1');
                writer.writeAttributeString('w:styleId', StiString.format('Style{0}', index));
                writer.writeStartElement('w:name');
                writer.writeAttributeString('w:val', style.name);
                writer.writeEndElement();
                writer.writeStartElement('w:basedOn');
                writer.writeAttributeString('w:val', 'a');
                writer.writeEndElement();
                writer.writeStartElement('w:rPr');
                writer.writeStartElement('w:rFonts');
                writer.writeAttributeString('w:ascii', style.fontName);
                writer.writeAttributeString('w:hAnsi', style.fontName);
                writer.writeAttributeString('w:cs', style.fontName);
                writer.writeEndElement();
                if (style.bold) {
                    writer.writeStartElement('w:b');
                    writer.writeEndElement();
                }
                if (style.italic) {
                    writer.writeStartElement('w:i');
                    writer.writeEndElement();
                }
                if (style.underline) {
                    writer.writeStartElement('w:u');
                    writer.writeAttributeString('w:val', 'single');
                    writer.writeEndElement();
                }
                writer.writeStartElement('w:color');
                writer.writeAttributeString('w:val', this.getColorString(style.textColor));
                writer.writeEndElement();
                writer.writeStartElement('w:sz');
                writer.writeAttributeString('w:val', StiString.format('{0}', style.fontSize));
                writer.writeEndElement();
                if (Stimulsoft['StiOptions'].Export.Word.spaceBetweenCharacters != 0) {
                    writer.writeStartElement('w:spacing');
                    writer.writeAttributeString('w:val', StiString.format('{0}', Stimulsoft['StiOptions'].Export.Word.spaceBetweenCharacters));
                    writer.writeEndElement();
                }
                if (style.rightToLeft) {
                    if (style.bold) {
                        writer.writeStartElement('w:bCs');
                        writer.writeEndElement();
                    }
                    if (style.italic) {
                        writer.writeStartElement('w:iCs');
                        writer.writeEndElement();
                    }
                    writer.writeStartElement('w:szCs');
                    writer.writeAttributeString('w:val', StiString.format('{0}', style.fontSize));
                    writer.writeEndElement();
                    writer.writeStartElement('w:rtl');
                    writer.writeEndElement();
                }
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeFullEndElement();
            writer.writeEndDocument();
            writer.flush();
            return ms;
        }
        writeImage(_number) {
            let ms = new MemoryStream();
            let buf = this.imageCache.imagePackedStore[_number];
            if (buf != null) {
                ms.write(buf, 0, buf.length);
            }
            return ms;
        }
        writeAdditionalData(st, base64) {
            let ms = new MemoryStream();
            let bytes = null;
            if (base64) {
                bytes = Stimulsoft.System.Convert.fromBase64String(st);
            } else {
                bytes = Encoding.ASCII.getBytes(st);
            }
            ms.write(bytes, 0, bytes.length);
            return ms;
        }
        exportWord(report, stream, settings) {
            __.a.StiLogService.write(this.stimulsoft().getType(), 'Export report to Word 2007 format');
            if (settings == null)
                throw new Error("The 'settings' argument cannot be equal in null.");
            let pageRange = settings.pageRange;
            this.usePageHeadersAndFooters = settings.usePageHeadersAndFooters;
            this.removeEmptySpaceAtBottom = settings.removeEmptySpaceAtBottom;
            this.imageResolution = settings.imageResolution;
            this.imageQuality = settings.imageQuality;
            this.docCompanyString = settings.companyString;
            this.docLastModifiedString = settings.lastModifiedString;
            this.restrictEditing = settings.restrictEditing;
            this.xmlIndentation = -1;
            if (this.imageQuality < 0)
                this.imageQuality = 0;
            if (this.imageQuality > 1)
                this.imageQuality = 1;
            if (this.imageResolution < 10)
                this.imageResolution = 10;
            this.imageResolution = this.imageResolution / 100;
            if (Stimulsoft['StiOptions'].Export.Word.lineSpacing != 1) {
                this.lineSpace = StiMath.round2(Stimulsoft['StiOptions'].Export.Word.lineSpacing * 240).toString();
                this.lineSpace2 = StiMath.round2(Stimulsoft['StiOptions'].Export.Word.lineSpacing * 0.772 * 240).toString();
            }
            if (Stimulsoft['StiOptions'].Export.Word.restrictEditing > this.restrictEditing) {
                this.restrictEditing = Stimulsoft['StiOptions'].Export.Word.restrictEditing;
            }
            this.report = report;
            try {
                this.styleList = [];
                this.fontList = new Hashtable();
                this.imageCache = new __.a.StiImageCache(Stimulsoft['StiOptions'].Export.Word.allowImageComparer, true, __.a.ImageFormat.Jpeg, this.imageQuality, false);
                this.bookmarkList = new Hashtable();
                this.hyperlinkList = new Hashtable();
                this.embedsList = [];
                this.currentPassNumber = 0;
                this.maximumPassNumber = 3 + (Stimulsoft['StiOptions'].Export.Word.divideSegmentPages ? 1 : 0);
                let hasDividedPages = false;
                let pages = pageRange.getSelectedPages(report.renderedPages);
                if (Stimulsoft['StiOptions'].Export.Word.divideSegmentPages) {
                    let needDivideSegments = true;
                    if (this.usePageHeadersAndFooters && pages.count > 0 && pages.getByIndex(0).unlimitedHeight && pages.getByIndex(0).segmentPerWidth == 1)
                        needDivideSegments = false;
                    if (needDivideSegments) {
                        let newPages = __.b.StiSegmentPagesDivider.divide(pages, this);
                        if (pages != newPages)
                            hasDividedPages = true;
                        pages = newPages;
                        this.currentPassNumber++;
                    }
                }
                let zip = new StiZipWriter20();
                zip.begin(stream, true);
                if (this.usePageHeadersAndFooters) {
                    this.headersData = [];
                    this.headersRels = [];
                    this.footersData = [];
                    this.footersRels = [];
                }
                zip.addFile('word/document.xml', this.writeDocument(pages, report, hasDividedPages), true);
                if (this.usePageHeadersAndFooters) {
                    for (let index = 0; index < this.headersData.length; index++) {
                        zip.addFile(StiString.format('word/header{0}.xml', index + 1), this.headersData[index]);
                        if (this.headersRels[index] != null)
                            zip.addFile(StiString.format('word/_rels/header{0}.xml.rels', index + 1), this.headersRels[index]);
                        zip.addFile(StiString.format('word/footer{0}.xml', index + 1), this.footersData[index]);
                        if (this.footersRels[index] != null)
                            zip.addFile(StiString.format('word/_rels/footer{0}.xml.rels', index + 1), this.footersRels[index]);
                    }
                }
                if (this.usePageHeadersAndFooters) {
                    zip.addFile('word/footnotes.xml', this.writeFootNotes());
                    zip.addFile('word/endnotes.xml', this.writeEndNotes());
                }
                zip.addFile('[Content_Types].xml', this.writeContentTypes());
                zip.addFile('_rels/.rels', this.writeMainRels());
                zip.addFile('docProps/app.xml', this.writeDocPropsApp());
                zip.addFile('docProps/core.xml', this.writeDocPropsCore());
                zip.addFile('word/settings.xml', this.writeSettings());
                zip.addFile('word/webSettings.xml', this.writeWebSettings());
                zip.addFile('word/fontTable.xml', this.writeFontTable());
                zip.addFile('word/_rels/document.xml.rels', this.writeDocumentRels());
                zip.addFile('word/styles.xml', this.writeStyles());
                if (this.imageCache.imagePackedStore.length > 0) {
                    for (let index = 0; index < this.imageCache.imagePackedStore.length; index++) {
                        zip.addFile(StiString.format('word/media/image{0:D5}.jpeg', index + 1), this.writeImage(index));
                    }
                }
                if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !this.usePageHeadersAndFooters && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                    zip.addFile('word/footnotes.xml', this.writeFootNotes());
                    zip.addFile('word/endnotes.xml', this.writeEndNotes());
                    zip.addFile('word/media/imageAdditional.png', this.writeAdditionalData(__.b.StiExportUtils.additionalData, true));
                    zip.addFile('word/headerAdditional.xml', this.writeAdditionalData('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n<w:hdr xmlns:ve="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:o="urn:schemas-microsoft-com:office:office" ' + 'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" ' + 'xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" ' + 'xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml"><w:p><w:pPr><w:pStyle w:val="a3"/></w:pPr><w:r><w:rPr><w:noProof/><w:lang w:eastAsia="ru-RU"/></w:rPr><w:pict>' + '<v:shapetype id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"> <v:stroke joinstyle="miter"/> <v:formulas>' + '<v:f eqn="if lineDrawn pixelLineWidth 0"/><v:f eqn="sum @0 1 0"/><v:f eqn="sum 0 0 @1"/><v:f eqn="prod @2 1 2"/><v:f eqn="prod @3 21600 pixelWidth"/><v:f eqn="prod @3 21600 pixelHeight"/><v:f eqn="sum @0 0 1"/>' + '<v:f eqn="prod @6 1 2"/><v:f eqn="prod @7 21600 pixelWidth"/><v:f eqn="sum @8 21600 0"/><v:f eqn="prod @7 21600 pixelHeight"/><v:f eqn="sum @10 21600 0"/></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>' + '<o:lock v:ext="edit" aspectratio="t"/></v:shapetype><v:shape id="WordPictureWatermark11777093" o:spid="_x0000_s2050" type="#_x0000_t75" ' + 'style="position:absolute;margin-left:0;margin-top:0;width:467.45pt;height:433.85pt;z-index:-251657216;mso-position-horizontal:center;mso-position-horizontal-relative:margin;mso-position-vertical:center;mso-position-vertical-relative:margin" ' + 'o:allowincell="f"><v:imagedata r:id="rId1" o:title="additional"/></v:shape></w:pict></w:r></w:p></w:hdr>', false));
                    zip.addFile('word/_rels/headerAdditional.xml.rels', this.writeAdditionalData('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="media/imageAdditional.png" /></Relationships>', false));
                }
                zip.end();
            } finally {
                if (this.matrix != null) {
                    this.matrix.clear();
                    this.matrix = null;
                }
                this.fontList.clear();
                this.fontList = null;
                this.imageCache.clear();
                this.imageCache = null;
                this.styleList.stimulsoft().clear();
                this.styleList = null;
                this.bookmarkList.clear();
                this.bookmarkList = null;
                this.hyperlinkList.clear();
                this.hyperlinkList = null;
                this.embedsList.stimulsoft().clear();
                this.embedsList = null;
                if (this.usePageHeadersAndFooters) {
                    this.headersData.stimulsoft().clear();
                    this.headersData = null;
                    this.headersRels.stimulsoft().clear();
                    this.headersRels = null;
                    this.footersData.stimulsoft().clear();
                    this.footersData = null;
                    this.footersRels.stimulsoft().clear();
                    this.footersRels = null;
                }
                if (report.renderedPages.cacheMode)
                    __.b.StiMatrix.GCCollect();
            }
        }
    };
    StiWord2007ExportService.fontsToCorrectHeight = null;
    __.b.StiWord2007ExportService = StiWord2007ExportService;
}
let Font = Stimulsoft.System.Drawing.Font;
let StiHtmlTextRender = __.a.Components.StiHtmlTextRender;
let StiPdfEmbeddedFileData = __.b.StiPdfEmbeddedFileData;
let StiSparkline = __.a.Components.StiSparkline;
let StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
let StiDataBarIndicator = __.a.Components.StiDataBarIndicator;
let StiIconSetHelper = __.a.Components.StiIconSetHelper;
let StiIcon = __.a.Components.StiIcon;
let StiIconSetIndicator = __.a.Components.StiIconSetIndicator;
let StiBookmarksCollection = __.a.Components.StiBookmarksCollection;
let StiBookmark = __.a.Components.StiBookmark;
let StiHtmlTag = Stimulsoft.Base.Drawing.StiHtmlTag;
let StiImageRotation = __.a.Components.StiImageRotation;
let StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
let StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
let StiHatchBrush = Stimulsoft.Base.Drawing.StiHatchBrush;
let StiGlassBrush = Stimulsoft.Base.Drawing.StiGlassBrush;
let StiRectanglePrimitive = __.a.Components.StiRectanglePrimitive;
let IStiChart = __.a.Chart.IStiChart;
let RectangleD = Stimulsoft.System.Drawing.Rectangle;
let StiBarCode = __.a.BarCodes.StiBarCode;
{
    let StiPdfData = class {
        constructor(service) {
            this.X = 0;
            this.Y = 0;
            this.Width = 0;
            this.Height = 0;
            this.Component = null;
            this.service = null;
            this.service = service;
        }
        get Right() {
            return this.X + this.Width;
        }
        get Top() {
            return this.Y + this.Height;
        }
    };
    __.b.StiPdfData = StiPdfData;
    let StiImageData = class {
    };
    __.b.StiImageData = StiImageData;
    let StiShadingData = class {
    };
    __.b.StiShadingData = StiShadingData;
    let StiShadingFunctionData = class {
    };
    __.b.StiShadingFunctionData = StiShadingFunctionData;
    let StiEditableObject = class {
        constructor() {
            this.FontColor = Color.black;
        }
    };
    __.b.StiEditableObject = StiEditableObject;
    let StiLinkObject = class {
    };
    __.b.StiLinkObject = StiLinkObject;
    let StiPdfBookmarkTreeNode = class {
    };
    let StiPdfExportService = class extends __.b.StiExportService {
        constructor() {
            super(...arguments);
            this.multipleFiles = false;
            this.imageQuality = 0.75;
            this.imageResolutionMain = 1;
            this.imageResolutionMode = __.b.StiImageResolutionMode.Auto;
            this.sw = null;
            this.pageStream = null;
            this.imageList = null;
            this.imageCache = null;
            this.imageInterpolationTable = null;
            this.imageCacheIndexToList = null;
            this.imageInfoList = null;
            this.imageInfoCounter = 0;
            this.colorTable = StiArray.create(String, 256);
            this.alphaTable = StiArray.create(Boolean, 256);
            this.pdfFont = null;
            this.bidi = null;
            this.standardPdfFonts = true;
            this.embeddedFonts = false;
            this.useUnicodeMode = false;
            this.reduceFontSize = true;
            this.compressed = false;
            this.compressedFonts = false;
            this.encrypted = false;
            this.usePdfA = false;
            this.pdfComplianceMode = __.b.StiPdfComplianceMode.None;
            this.exportRtfTextAsImage = false;
            this.autoPrint = __.b.StiPdfAutoPrintMode.None;
            this.imageCompressionMethod = __.b.StiPdfImageCompressionMethod.Jpeg;
            this.imageFormat = __.b.StiImageFormat.Color;
            this.monochromeDitheringType = __.b.StiMonochromeDitheringType.FloydSteinberg;
            this.allowEditable = __.b.StiPdfAllowEditable.No;
            this.useTransparency = true;
            this.embeddedFiles = null;
            this.zugferdComplianceMode = __.b.StiPdfZUGFeRDComplianceMode.None;
            this.zugferdConformanceLevel = 'BASIC';
            this.fontGlyphsReduceNotNeed = null;
            this.bookmarksTree = null;
            this.bookmarksTreeTemp = null;
            this.linksArray = null;
            this.tagsArray = null;
            this.tooltipsArray = null;
            this.shadingArray = null;
            this.hatchArray = null;
            this.shadingFunctionArray = null;
            this.haveBookmarks = false;
            this.haveLinks = false;
            this.haveAnnots = false;
            this.haveTooltips = false;
            this.CodePage1252part80AF = [
                8364,
                8226,
                8218,
                402,
                8222,
                8230,
                8224,
                8225,
                710,
                8240,
                352,
                8249,
                338,
                8226,
                381,
                8226,
                8226,
                8216,
                8217,
                8220,
                8221,
                8226,
                8211,
                8212,
                732,
                8482,
                353,
                8250,
                339,
                8226,
                382,
                376
            ];
            this.CodePage1252 = StiArray.create(Number, 256);
            this.hiToTwips = 0.72;
            this.precision_digits_font = 3;
            this.pdfCKT = 0.55228;
            this.IDValue = null;
            this.IDValueString = '';
            this.IDValueStringMeta = '';
            this.currentDateTime = '';
            this.currentDateTimeMeta = '';
            this.producerName = 'Stimulsoft Reports';
            this.creatorName = '';
            this.keywords = '';
            this.keyLength = __.b.StiPdfEncryptionKeyLength.Bit40;
            this.lastColorStrokeA = 255;
            this.lastColorNonStrokeA = 255;
            this.colorStack = null;
            this.info = null;
            this.haveDigitalSignature = false;
            this.pdfSecurity = null;
            this.printScaling = true;
            this.colorHash1 = new Hashtable();
            this.colorHash2 = new Hashtable();
            this._gsTable = null;
        }
        implements() {
            return [__.b.IStiPdfExportService];
        }
        get exportFormat() {
            return __.a.StiExportFormat.Pdf;
        }
        exportTo(report, stream, settings) {
            this.exportPdf1(report, stream, settings);
        }
        exportToAsync(onExport, report, stream, settings) {
            let flate = settings.imageCompressionMethod == __.b.StiPdfImageCompressionMethod.Flate;
            setTimeout(() => Stimulsoft.tsfb(this, void 0, void 0, function* () {
                yield __.b.StiExportImageHelper.convertAllImages(report, Stimulsoft.System.Drawing.Imaging.ImageFormat.Jpeg, flate, this.exportFormat);
                if (!report.isDocument && report.getCurrentPage().is(IStiDashboard)) {
                    StiDashboardExport.exportAsync(report, stream, settings).try(() => onExport());
                    return;
                }
                this.exportTo(report, stream, settings);
                if (report != null && report.preparedExportImages != null) {
                    report.preparedExportImages.clear();
                    report.preparedExportImages = null;
                }
                onExport();
            }), 0);
        }
        stringReplace(st, oldValue, newValue) {
            oldValue = oldValue.replace(StiPdfExportService.regexEscape, '\\$1');
            let reg = new RegExp(oldValue, 'g');
            return st.replace(reg, newValue);
        }
        getHatchNumber(brush) {
            if (this.hatchArray.length > 0) {
                for (let index = 0; index < this.hatchArray.length; index++) {
                    let tempBrush = this.hatchArray[index];
                    if (brush.style == tempBrush.style && brush.backColor.equals(tempBrush.backColor) && brush.foreColor.equals(tempBrush.foreColor)) {
                        return index;
                    }
                }
            }
            this.hatchArray.push(brush);
            return this.hatchArray.length - 1;
        }
        getShadingFunctionNumber(color1, color2, isGlare) {
            if (this.shadingFunctionArray.length > 0) {
                for (let index = 0; index < this.shadingFunctionArray.length; index++) {
                    let tempSf = this.shadingFunctionArray[index];
                    if (tempSf.Color1.equals(color1) && tempSf.Color2.equals(color2) && tempSf.IsGlare == isGlare) {
                        return index;
                    }
                }
            }
            let sf = new StiShadingFunctionData();
            sf.Color1 = color1;
            sf.Color2 = color2;
            sf.IsGlare = isGlare;
            this.shadingFunctionArray.push(sf);
            return this.shadingFunctionArray.length - 1;
        }
        addXref(num) {
            let offs = this.sw.position;
            this.xref[num] = offs.toString().stimulsoft().padLeft(10, '0') + ' 00000 n';
            this.currentObjectNumber = num;
            this.currentGenerationNumber = 0;
        }
        convertToString(value, precision = 2) {
            let numValue = StiMath.round2(value, precision);
            return numValue.toString().split(',').join(Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
        }
        static convertToEscapeSequence(value) {
            let escapeChars = [
                40,
                41,
                92,
                13,
                10,
                8,
                12
            ];
            let replaceChars = '()\\rnbf';
            let flg;
            let sb;
            if (value == null) {
                return '';
            } else {
                sb = new StringBuilder();
                for (let index = 0; index < value.length; index++) {
                    flg = false;
                    for (let index2 = 0; index2 < escapeChars.length; index2++) {
                        if (value.charCodeAt(index) == escapeChars[index2]) {
                            sb.append('\\' + replaceChars[index2]);
                            flg = true;
                            break;
                        }
                    }
                    if (!flg) {
                        sb.append(value.charAt(index));
                    }
                }
            }
            return sb.toString();
        }
        static convertToEscapeSequencePlusTabs(value) {
            let escapeChars = [
                40,
                41,
                92,
                13,
                10,
                9,
                8,
                12
            ];
            let replaceChars = '()\\rntbf';
            let flg;
            let sb;
            if (value == null) {
                return '';
            } else {
                sb = '';
                for (let index = 0; index < value.length; index++) {
                    flg = false;
                    for (let index2 = 0; index2 < escapeChars.length; index2++) {
                        if (value.charCodeAt(index) == escapeChars[index2]) {
                            sb += '\\' + replaceChars[index2];
                            flg = true;
                            break;
                        }
                    }
                    if (!flg) {
                        sb += value.charAt(index);
                    }
                }
            }
            return sb;
        }
        setStrokeColor(tempColor) {
            let st = this.colorHash1.get(tempColor);
            if (st == null) {
                st = StiString.format('{0} {1} {2} RG', this.colorTable[tempColor.r], this.colorTable[tempColor.g], this.colorTable[tempColor.b]);
                this.colorHash1.set(tempColor, st);
            }
            this.pageStream.writeLine(st);
            let alpha = tempColor.a;
            if (alpha != this.lastColorStrokeA && (Stimulsoft['StiOptions'].Export.Pdf.allowExtGState && !this.usePdfA)) {
                this.pageStream.writeLine(this.gsTable[alpha][0]);
                this.lastColorStrokeA = alpha;
                this.alphaTable[alpha] = true;
            }
        }
        setNonStrokeColor(tempColor) {
            let st = this.colorHash2.get(tempColor);
            if (st == null) {
                st = StiString.format('{0} {1} {2} rg', this.colorTable[tempColor.r], this.colorTable[tempColor.g], this.colorTable[tempColor.b]);
                this.colorHash2.set(tempColor, st);
            }
            this.pageStream.writeLine(st);
            let alpha = tempColor.a;
            if (alpha != this.lastColorNonStrokeA && (Stimulsoft['StiOptions'].Export.Pdf.allowExtGState && !this.usePdfA)) {
                this.pageStream.writeLine(this.gsTable[alpha][1]);
                this.lastColorNonStrokeA = alpha;
                this.alphaTable[alpha] = true;
            }
        }
        get gsTable() {
            if (this._gsTable == null) {
                this._gsTable = StiArray.create2(String, 256, 2);
                for (let index = 0; index < 256; index++) {
                    this._gsTable[index][0] = StiString.format('/GS{0:X2}S gs', index);
                    this._gsTable[index][1] = StiString.format('/GS{0:X2}N gs', index);
                }
            }
            return this._gsTable;
        }
        pushColorToStack() {
            this.colorStack.push(this.lastColorStrokeA);
            this.colorStack.push(this.lastColorNonStrokeA);
        }
        popColorFromStack() {
            this.lastColorNonStrokeA = this.colorStack.pop();
            this.lastColorStrokeA = this.colorStack.pop();
        }
        fillRectBrush(brush, rect) {
            let tempColor = StiBrush.toColor(brush);
            this.setNonStrokeColor(tempColor);
            this.storeShadingData2(rect.x, rect.y, rect.width, rect.height, brush);
            if (brush.is(StiGradientBrush) || brush.is(StiGlareBrush)) {
                this.pageStream.writeLine1('/Pattern cs /P{0} scn', 1 + this.shadingCurrent);
            }
            if (brush.is(StiHatchBrush)) {
                let hBrush = brush;
                this.pageStream.writeLine1('/Cs1 cs /PH{0} scn', this.getHatchNumber(hBrush) + 1);
            }
            if (brush.is(StiGlassBrush)) {
                let glass = brush;
                this.setNonStrokeColor(glass.getTopColor());
                this.pageStream.writeLine1('{0} {1} {2} {3} re f', this.convertToString(rect.x), this.convertToString(rect.y + rect.height / 2), this.convertToString(rect.width), this.convertToString(rect.height / 2));
                this.setNonStrokeColor(glass.getBottomColor());
                this.pageStream.writeLine1('{0} {1} {2} {3} re f', this.convertToString(rect.x), this.convertToString(rect.y), this.convertToString(rect.width), this.convertToString(rect.height / 2));
                tempColor = Color.transparent;
            }
            if (tempColor.a != 0) {
                this.pageStream.writeLine1('{0} {1} {2} {3} re f', this.convertToString(rect.x), this.convertToString(rect.y), this.convertToString(rect.width), this.convertToString(rect.height));
            }
        }
        storeStringLine(noCryptString, cryptString, escaping = false) {
            let tempSt = noCryptString + this.convertToHexString(cryptString, escaping);
            this.storeString(tempSt);
            this.sw.writeLine();
        }
        storeString(st) {
            this.sw.writeString(st, false);
        }
        convertToHexString(inString, escaping, forceHex = false) {
            let outString = '';
            if (!StiString.isNullOrEmpty(inString)) {
                let needHex = forceHex;
                for (let tempIndex = 0; tempIndex < inString.length; tempIndex++) {
                    if (inString.charCodeAt(tempIndex) > 127) {
                        needHex = true;
                    }
                }
                if (!this.encrypted) {
                    if (needHex == true) {
                        outString += '<FEFF';
                        for (let index = 0; index < inString.length; index++) {
                            outString += StiString.format('{0:X4}', inString.charCodeAt(index));
                        }
                        outString += '>';
                    } else {
                        if (escaping) {
                            outString += '(' + StiPdfExportService.convertToEscapeSequencePlusTabs(inString) + ')';
                        } else {
                            outString += '(' + inString + ')';
                        }
                    }
                } else {
                    let forCrypt = null;
                    if (needHex == true) {
                        forCrypt = [];
                        for (let index = 0; index < inString.length; index++) {
                            let charValue = inString.charCodeAt(index);
                            forCrypt[2 + index * 2 + 0] = charValue >> 8 & 255;
                            forCrypt[2 + index * 2 + 1] = charValue & 255;
                        }
                        forCrypt[0] = 254;
                        forCrypt[1] = 255;
                    } else {
                        forCrypt = [];
                        for (let index = 0; index < inString.length; index++) {
                            forCrypt[index] = inString.charCodeAt(index);
                        }
                    }
                    let encryptedData = this.pdfSecurity.encryptData(forCrypt, this.currentObjectNumber, this.currentGenerationNumber);
                    let tempSB = '';
                    for (let index = 0; index < encryptedData.length; index++) {
                        tempSB += String.fromCharCode(encryptedData[index]);
                    }
                    outString += '(' + StiPdfExportService.convertToEscapeSequencePlusTabs(tempSB) + ')';
                }
            } else {
                if (this.encrypted) {
                    let encryptedData = this.pdfSecurity.encryptData([], this.currentObjectNumber, this.currentGenerationNumber);
                    let tempSB = '';
                    for (let index = 0; index < encryptedData.length; index++) {
                        tempSB += String.fromCharCode(encryptedData[index]);
                    }
                    outString += '(' + StiPdfExportService.convertToEscapeSequencePlusTabs(tempSB) + ')';
                } else {
                    outString += '()';
                }
            }
            return outString;
        }
        storeMemoryStream2(mem, dictionaryString) {
            if (this.encrypted) {
                let encryptedData = this.pdfSecurity.encryptData(mem.toArray(), this.currentObjectNumber, this.currentGenerationNumber);
                this.sw.writeLine1(StiString.format(dictionaryString, encryptedData.length));
                this.sw.writeLine('>>');
                this.sw.writeLine('stream');
                this.sw.write(encryptedData, 0, encryptedData.length);
            } else {
                this.sw.writeLine1(StiString.format(dictionaryString, mem.length));
                this.sw.writeLine('>>');
                this.sw.writeLine('stream');
                mem.writeTo(this.sw);
            }
            mem.close();
        }
        storeMemoryStream3(data, dictionaryString) {
            let memst = new MemoryStream();
            for (let tempIndex = 0; tempIndex < data.length; tempIndex++) {
                memst.writeByte(data[tempIndex]);
            }
            this.storeMemoryStream2(memst, dictionaryString);
            memst.close();
        }
        storeMemoryStream4(data, dictionaryString) {
            let memst = new MemoryStream();
            for (let tempIndex = 0; tempIndex < data.length; tempIndex++) {
                memst.writeByte(data[tempIndex]);
            }
            this.storeMemoryStream2(memst, dictionaryString);
            memst.close();
        }
        storeWysiwygSymbols(text, pageNumber = -1) {
            let outRunsList = [];
            let outFontsList = [];
            let textForOutput = text.text;
            StiHtmlTextRender.drawTextForOutput(text, outRunsList, outFontsList);
            this.pdfFont.storeUnicodeSymbolsInMap(textForOutput);
            if (Stimulsoft['StiOptions'].Export.Pdf.useProperCaseFontNamesFromHtml) {
                for (let fontState of outFontsList) {
                    let name = fontState.fontName;
                    let haveUpper = false;
                    for (let index = 0; index < name.length; index++) {
                        if (Char.isUpper(name, index)) {
                            haveUpper = true;
                            break;
                        }
                    }
                    if (!haveUpper) {
                        let fontName = Stimulsoft.System.Globalization.CultureInfo.InvariantCulture.textInfo.toTitleCase(name);
                        let stateFont = null;
                        if (fontName.indexOf(',') != -1) {
                            let fontNames = fontName.split(',');
                            for (let fontNamePart of fontNames) {
                                stateFont = new Font(fontNamePart, fontState.fontBase.size, fontState.fontBase.style);
                                if (stateFont.name.toLowerCase() == fontNamePart.toLowerCase())
                                    break;
                            }
                        } else {
                            stateFont = new Font(fontName, fontState.fontBase.size, fontState.fontBase.style);
                        }
                        fontState.fontBase = stateFont;
                        fontState.fontName = stateFont.name;
                    }
                }
            }
            for (let runInfo of outRunsList) {
                let tempFont = outFontsList[runInfo.fontIndex].fontBase;
                let fnt = this.pdfFont.getFontNumber(tempFont);
                this.pdfFont.currentFont = fnt;
                let sb = new StringBuilder();
                if (false) {
                    for (let indexGlyph = 0; indexGlyph < runInfo.glyphIndexList.length; indexGlyph++) {
                        sb.append(String.fromCharCode(runInfo.glyphIndexList[indexGlyph]));
                    }
                } else {
                    sb.append(String.fromCharCode(65535));
                }
                this.pdfFont.storeGlyphsInMap(sb.toString());
                this.pdfFont.storeUnicodeSymbolsInMap(runInfo.text);
                if (pageNumber != -1 && !StiString.isNullOrWhiteSpace(runInfo.href) && !runInfo.href.trim().startsWith('javascript:') && !this.usePdfA) {
                    let stl = new StiLinkObject();
                    stl.Link = runInfo.href;
                    stl.Page = pageNumber;
                    this.linksArray.push(stl);
                }
            }
        }
        renderStartDoc(report, pages) {
            this.sw.writeLine(this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r5 || this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r6 ? '%PDF-1.7' : '%PDF-1.4');
            this.sw.write([
                37,
                226,
                227,
                207,
                211
            ], 0, 5);
            this.sw.writeLine();
            this.addXref(1);
            this.sw.writeLine('1 0 obj');
            this.sw.writeLine('<<');
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r5)
                this.sw.writeLine('/Extensions<</ADBE<</BaseVersion/1.7/ExtensionLevel 3>>>>');
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r6)
                this.sw.writeLine('/Extensions<</ADBE<</BaseVersion/1.7/ExtensionLevel 8>>>>');
            this.sw.writeLine('/Type /Catalog');
            this.sw.writeLine1('/Pages {0} 0 R', this.info.pages.ref);
            this.sw.writeLine('/MarkInfo<</Marked true>>');
            this.sw.writeLine1('/Metadata {0} 0 R', this.info.metadata.ref);
            this.sw.writeLine1('/OutputIntents {0} 0 R', this.info.outputIntents.ref);
            this.sw.writeLine1('/StructTreeRoot {0} 0 R', this.info.structTreeRoot.ref);
            if (this.haveBookmarks) {
                this.sw.writeLine1('/Outlines {0} 0 R', this.info.outlines.ref);
                this.sw.writeLine('/PageMode /UseOutlines');
            } else {
                this.sw.writeLine('/PageMode /UseNone');
            }
            if (!this.printScaling) {
                this.sw.writeLine('/ViewerPreferences');
                this.sw.writeLine('<<');
                this.sw.writeLine('/PrintScaling /None');
                this.sw.writeLine('>>');
            }
            if (this.haveAnnots || this.haveDigitalSignature) {
                this.sw.writeLine1('/AcroForm {0} 0 R', this.info.acroForm.ref);
            }
            let needAutoPrint = this.autoPrint != __.b.StiPdfAutoPrintMode.None;
            let needEmbeddedFiles = this.info.embeddedFilesList.length > 0;
            if (needAutoPrint || needEmbeddedFiles) {
                this.sw.writeLine('/Names <<');
                if (needAutoPrint) {
                    this.sw.writeLine1('/JavaScript {0} 0 R', this.info.embeddedJS.ref);
                }
                if (needEmbeddedFiles) {
                    this.sw.writeLine('/EmbeddedFiles <<');
                    this.sw.writeString('/Names [ ');
                    for (let index = 0; index < this.info.embeddedFilesList.length; index++) {
                        let file = this.embeddedFiles[index];
                        let st = StiString.format('{0} {1} 0 R ', this.convertToHexString(file.name, true, true), this.info.embeddedFilesList[index].ref);
                        this.sw.writeString(st);
                    }
                    this.sw.writeLine(']');
                    this.sw.writeLine('>>');
                }
                this.sw.writeLine('>>');
            }
            if (this.zugferdComplianceMode != __.b.StiPdfZUGFeRDComplianceMode.None || this.pdfComplianceMode == __.b.StiPdfComplianceMode.A3) {
                this.sw.writeString('/AF [ ');
                for (let index = 0; index < this.info.embeddedFilesList.length; index++) {
                    this.sw.writeString(StiString.format('{0} 0 R ', this.info.embeddedFilesList[index].ref));
                }
                this.sw.writeLine(']');
            }
            if (!this.usePdfA) {
                this.sw.writeLine1('/OCProperties << /OCGs [{0} 0 R] /D << /ON [{0} 0 R] /AS [<</Event /Print /OCGs [{0} 0 R] /Category [/Print]>>] >> >>', this.info.optionalContentGroup.ref);
            }
            this.sw.writeLine('>>');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
            this.addXref(2);
            this.sw.writeLine('2 0 obj');
            this.sw.writeLine('<<');
            this.storeStringLine('/Producer ', this.producerName, true);
            this.storeStringLine('/Creator ', this.creatorName, true);
            if (!StiString.isNullOrEmpty(report.reportAuthor)) {
                this.storeStringLine('/Author ', report.reportAuthor, true);
            }
            if (!StiString.isNullOrEmpty(report.reportAlias)) {
                this.storeStringLine('/Subject ', report.reportAlias, true);
            }
            if (!StiString.isNullOrEmpty(report.reportName)) {
                this.storeStringLine('/Title ', report.reportName, true);
            }
            if (!StiString.isNullOrEmpty(this.keywords)) {
                this.storeStringLine('/Keywords ', this.keywords, true);
            }
            this.storeStringLine('/CreationDate ', 'D:' + this.currentDateTime);
            this.storeStringLine('/ModDate ', 'D:' + this.currentDateTime);
            for (let meta of report.metaTags.list) {
                if (meta.name.stimulsoft().startsWith('pdf:')) {
                    this.storeStringLine(StiString.format('/{0} ', __.a.StiNameValidator.correctName(meta.name.substr(4), false)), meta.tag);
                }
            }
            this.sw.writeLine('>>');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
            this.addXref(3);
            this.sw.writeLine('3 0 obj');
            this.sw.writeLine('<<');
            this.sw.writeLine('/Cs1 [/Pattern /DeviceRGB]');
            this.sw.writeLine('>>');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
            this.addXref(this.info.pages.ref);
            this.sw.writeLine1('{0} 0 obj', this.info.pages.ref);
            this.sw.writeLine('<<');
            this.sw.writeLine('/Type /Pages');
            this.sw.writeString('/Kids [ ');
            for (let index = 0; index < pages.count; index++) {
                this.sw.writeString(StiString.format('{0} 0 R ', this.info.pageList[index].ref));
            }
            this.sw.writeLine(']');
            this.sw.writeLine1('/Count {0}', pages.count);
            if (Stimulsoft['StiOptions'].Export.Pdf.allowInheritedPageResources) {
                let resourcesList = [];
                resourcesList.push('/Resources');
                resourcesList.push('<<');
                resourcesList.push('/ProcSet [/PDF /Text /ImageC]');
                resourcesList.push('/Font');
                resourcesList.push('<<');
                for (let index = 0; index < this.fontsCounter; index++) {
                    resourcesList.push(StiString.format('/F{0} {1} 0 R', index, this.info.fontList[index].ref));
                }
                resourcesList.push('>>');
                if (this.imageCache.imageStore.length > 0) {
                    resourcesList.push('/XObject');
                    resourcesList.push('<<');
                    for (let index = 0; index < this.imageCache.imageStore.length; index++) {
                        resourcesList.push(StiString.format('/Image{0} {1} 0 R', index, this.info.xObjectList[index].ref));
                    }
                    resourcesList.push('>>');
                }
                resourcesList.push('/Pattern');
                resourcesList.push('<<');
                resourcesList.push(StiString.format('/P1 {0} 0 R', this.info.patterns.first.ref));
                for (let indexPattern = 0; indexPattern < this.hatchArray.length; indexPattern++) {
                    resourcesList.push(StiString.format('/PH{0} {1} 0 R', 1 + indexPattern, this.info.patterns.hatchItems[indexPattern].ref));
                }
                for (let indexPattern = 0; indexPattern < this.shadingArray.length; indexPattern++) {
                    resourcesList.push(StiString.format('/P{0} {1} 0 R', 2 + indexPattern, this.info.patterns.shadingItems[indexPattern].ref));
                }
                resourcesList.push('>>');
                resourcesList.push('/ColorSpace 3 0 R');
                if (Stimulsoft['StiOptions'].Export.Pdf.allowExtGState && this.useTransparency) {
                    resourcesList.push(StiString.format('/ExtGState {0} 0 R', this.info.extGState.ref));
                }
                if (!this.usePdfA) {
                    resourcesList.push(StiString.format('/Properties << /oc1 {0} 0 R >>', this.info.optionalContentGroup.ref));
                }
                resourcesList.push('>>');
                for (let indexResourcesList = 0; indexResourcesList < resourcesList.length; indexResourcesList++) {
                    this.sw.writeLine(resourcesList[indexResourcesList]);
                }
            }
            this.sw.writeLine('>>');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
            this.addXref(5);
            this.sw.writeLine('5 0 obj');
            this.sw.writeLine('<<');
            this.sw.writeLine('/Type /StructTreeRoot');
            this.sw.writeLine('>>');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
            this.addXref(6);
            this.sw.writeLine('6 0 obj');
            this.sw.writeLine('<<');
            this.sw.writeLine('/Type /OCG');
            this.sw.writeLine('/Name (Printable off)');
            this.sw.writeLine('/Usage <<');
            this.sw.writeLine('/Print << /PrintState /OFF >>');
            this.sw.writeLine('/View << /ViewState /ON >>');
            this.sw.writeLine('>>');
            this.sw.writeLine('>>');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
            for (let indexPage = 0; indexPage < pages.count; indexPage++) {
                this.addXref(this.info.pageList[indexPage].ref);
                this.sw.writeLine1('{0} 0 obj', this.info.pageList[indexPage].ref);
                this.sw.writeLine('<<');
                this.sw.writeLine('/Type /Page');
                this.sw.writeLine('/Parent 4 0 R');
                let tPage = pages.getByIndex(indexPage);
                let pageHeight = this.hiToTwips * report.unit.convertToHInches(tPage.pageHeight * tPage.segmentPerHeight);
                let pageWidth = this.hiToTwips * report.unit.convertToHInches(tPage.pageWidth * tPage.segmentPerWidth);
                if (pageHeight > 14400) {
                    pageHeight = 14400;
                }
                if (pageWidth > 14400) {
                    pageWidth = 14400;
                }
                this.sw.writeLine1('/MediaBox [ 0 0 {0} {1} ]', this.convertToString(pageWidth), this.convertToString(pageHeight));
                if (!Stimulsoft['StiOptions'].Export.Pdf.allowInheritedPageResources) {
                    let resourcesList = [];
                    resourcesList.push('/Resources');
                    resourcesList.push('<<');
                    resourcesList.push('/ProcSet [/PDF /Text /ImageC]');
                    resourcesList.push('/Font');
                    resourcesList.push('<<');
                    for (let index = 0; index < this.fontsCounter; index++) {
                        resourcesList.push(StiString.format('/F{0} {1} 0 R', index, this.info.fontList[index].ref));
                    }
                    resourcesList.push('>>');
                    if (this.imageCache.imageStore.length > 0) {
                        resourcesList.push('/XObject');
                        resourcesList.push('<<');
                        for (let index = 0; index < this.imageCache.imageStore.length; index++) {
                            resourcesList.push(StiString.format('/Image{0} {1} 0 R', index, this.info.xObjectList[index].ref));
                        }
                        resourcesList.push('>>');
                    }
                    let sbb = new StringBuilder();
                    sbb.append(StiString.format('/P1 {0} 0 R', this.info.patterns.first.ref));
                    for (let indexPattern = 0; indexPattern < this.hatchArray.length; indexPattern++) {
                        sbb.append(StiString.format('/PH{0} {1} 0 R', 1 + indexPattern, this.info.patterns.hatchItems[indexPattern].ref));
                    }
                    for (let indexPattern = 0; indexPattern < this.shadingArray.length; indexPattern++) {
                        let ssd = this.shadingArray[indexPattern];
                        if (ssd.Page == indexPage)
                            sbb.append(StiString.format('/P{0} {1} 0 R', 2 + indexPattern, this.info.patterns.shadingItems[indexPattern].ref));
                    }
                    resourcesList.push('/Pattern << ' + sbb.toString() + ' >>');
                    resourcesList.push('/ColorSpace 3 0 R');
                    if (Stimulsoft['StiOptions'].Export.Pdf.allowExtGState && this.useTransparency) {
                        resourcesList.push(StiString.format('/ExtGState {0} 0 R', this.info.extGState.ref));
                    }
                    if (!this.usePdfA) {
                        resourcesList.push(StiString.format('/Properties << /oc1 {0} 0 R >>', this.info.optionalContentGroup.ref));
                    }
                    resourcesList.push('>>');
                    for (let indexResourcesList = 0; indexResourcesList < resourcesList.length; indexResourcesList++) {
                        this.sw.writeLine(resourcesList[indexResourcesList]);
                    }
                }
                this.sw.writeLine1('/Contents {0} 0 R', this.info.pageList[indexPage].content.ref);
                if (!this.usePdfA) {
                    this.sw.writeLine('/Group');
                    this.sw.writeLine('<<');
                    this.sw.writeLine('/Type /Group');
                    this.sw.writeLine('/S /Transparency');
                    this.sw.writeLine('/CS /DeviceRGB');
                    this.sw.writeLine('>>');
                }
                if (this.haveLinks || this.haveAnnots || this.haveDigitalSignature || this.haveTooltips) {
                    this.sw.writeLine('/Annots [');
                    if (this.haveLinks) {
                        for (let tempIndex = 0; tempIndex < this.linksCounter; tempIndex++) {
                            let stl = this.linksArray[tempIndex];
                            if (stl.Page == indexPage) {
                                this.sw.writeLine1('{0} 0 R ', this.info.linkList[tempIndex].ref);
                            }
                        }
                    }
                    if (this.haveAnnots) {
                        for (let tempIndex = 0; tempIndex < this.annotsCounter; tempIndex++) {
                            let seo = this.annotsArray[tempIndex];
                            if (seo.Page == indexPage) {
                                this.sw.writeLine1('{0} 0 R ', this.info.acroForm.annots[tempIndex].ref);
                            }
                        }
                        for (let tempIndex = 0; tempIndex < this.annots2Counter; tempIndex++) {
                            let seo = this.annots2Array[tempIndex];
                            if (seo.Page == indexPage) {
                                for (let indexState = 0; indexState < this.info.acroForm.checkBoxes[tempIndex].items.length; indexState++) {
                                    this.sw.writeLine1('{0} 0 R ', this.info.acroForm.checkBoxes[tempIndex].items[indexState].ref);
                                }
                            }
                        }
                    }
                    this.sw.writeLine(']');
                }
                this.sw.writeLine('>>');
                this.sw.writeLine('endobj');
                this.sw.writeLine('');
            }
        }
        renderEndDoc() {
            let offs = this.sw.position;
            this.sw.writeLine('xref');
            this.sw.writeLine1('0 {0}', this.xref.stimulsoft().countItems + 1);
            this.sw.writeLine('0000000000 65535 f');
            for (let index = 0; index < this.xref.stimulsoft().countItems; index++) {
                this.sw.writeLine(this.xref[index + 1]);
            }
            this.sw.writeLine('trailer');
            this.sw.writeLine('<<');
            this.sw.writeLine1('/Size {0}', this.xref.stimulsoft().countItems + 1);
            this.sw.writeLine('/Root 1 0 R');
            this.sw.writeLine('/Info 2 0 R');
            if (this.encrypted) {
                this.sw.writeLine1('/Encrypt {0} 0 R', this.info.encode.ref);
            }
            this.sw.writeLine1('/ID[<{0}><{0}>]', this.IDValueString);
            this.sw.writeLine('>>');
            this.sw.writeLine('%' + __.b.StiExportUtils.getReportVersion());
            this.sw.writeLine('%' + Stimulsoft.StiVersion.platform());
            this.sw.writeLine('startxref');
            this.sw.writeLine1('{0}', offs);
            this.sw.writeLine('%%EOF');
        }
        renderPageHeader(pageNumber) {
            this.addXref(this.info.pageList[pageNumber].content.ref);
            this.sw.writeLine1('{0} 0 obj', this.info.pageList[pageNumber].content.ref);
            this.sw.writeLine('<<');
            this.pageStream = new MemoryStream();
            this.pageStream.writeLine('2 J');
        }
        renderPageFooter(pageH, pageW) {
            if (!Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnJS() && !Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnDbsJS() && !((Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnBI() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyReports() || Stimulsoft.Base.Licenses.StiLicenseKeyValidator.isValidOnAnyDbs()) && Stimulsoft.System.NodeJs.isStandaloneVersion)) {
                let tempX = pageW / 596 * 1.4;
                let tempY = pageH / 840 * 1.4;
                if (tempX > tempY)
                    tempX = tempY;
                else
                    tempY = tempX;
                this.pageStream.writeLine('q');
                this.pushColorToStack();
                this.pageStream.writeLine('1 J 1 j 20 w');
                this.setStrokeColor(Color.fromArgb(64, 100, 100, 100));
                this.pageStream.writeLine1('{0} 0 0 {1} {2} {3} cm 0.707 0.707 -0.707 0.707 0 0 cm 1 0 0 1 -155 -50 cm', this.convertToString(tempX), this.convertToString(tempY), this.convertToString(pageW / 2), this.convertToString(pageH / 2));
                this.pageStream.writeLine('40 0 m 40 100 l 0 100 m 80 100 l S');
                this.pageStream.writeLine('100 0 m 100 70 l 100 45 m 120 65 l 130 72 l 140 68 l S');
                this.pageStream.writeLine('170 0 m 170 70 l 169 100 m 171 100 l S');
                this.pageStream.writeLine('215 60 m 222 69 l 232 71 l 255 70 l 265 60 l 265 5 l 270 0 l 265 44 m 220 31 l 212 20 l 212 10 l 225 0 l 235 0 l 250 5 l 265 18 l S');
                this.pageStream.writeLine('310 0 m 310 100 l S');
                this.pageStream.writeLine('Q');
                this.popColorFromStack();
            }
            if (this.pageStream.position < this.pageStream.length) {
                this.pageStream.setLength(this.pageStream.position);
            }
            if (this.compressed == true) {
                let bytedata = this.pageStream.toArray();
                let tmpStream = __.b.StiExportUtils.makePdfDeflateStream(bytedata);
                this.storeMemoryStream2(tmpStream, '/Filter [/FlateDecode] /Length {0}');
            } else {
                this.storeMemoryStream2(this.pageStream, '/Filter [] /Length {0}');
            }
            this.sw.writeLine();
            this.pageStream.close();
            this.sw.writeLine('endstream');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
        }
        renderFontTable() {
            for (let index = 0; index < this.fontsCounter; index++) {
                let tempSb = new StringBuilder();
                this.pdfFont.currentFont = index;
                let tempInfo = this.pdfFont.fontList[index];
                let fontName = tempInfo.Name;
                if (Stimulsoft['StiOptions'].Export.Pdf.useAlternativeFontNames && Stimulsoft['StiOptions'].Export.Pdf.alternativeFontNames.containsKey(fontName)) {
                    fontName = Stimulsoft['StiOptions'].Export.Pdf.alternativeFontNames.get(fontName);
                }
                let needEmbeddedFonts = this.embeddedFonts || __.b.PdfFonts.isFontStimulsoft(tempInfo.Name);
                if (this.pdfFont.UseUnicode) {
                    tempSb = new StringBuilder(fontName.stimulsoft().replaceAll(' ', '#20'));
                    if (tempInfo.Bold || tempInfo.Italic) {
                        tempSb.append(',');
                        if (tempInfo.Bold)
                            tempSb.append('Bold');
                        if (tempInfo.Italic)
                            tempSb.append('Italic');
                    }
                    if (needEmbeddedFonts) {
                        tempSb.insert(0, StiString.format('SR{0}{1}{2}{3}+', String.fromCharCode(Math.random() * 24 + 65), String.fromCharCode(Math.random() * 24 + 65), String.fromCharCode(Math.random() * 24 + 65), String.fromCharCode(Math.random() * 24 + 65)));
                    }
                    this.addXref(this.info.fontList[index].ref);
                    this.sw.writeLine1('{0} 0 obj', this.info.fontList[index].ref);
                    this.sw.writeLine('<<');
                    this.sw.writeLine('/Type /Font');
                    this.sw.writeLine('/Subtype /Type0');
                    this.sw.writeLine1('/BaseFont /{0}', tempSb);
                    this.sw.writeLine1('/DescendantFonts [{0} 0 R]', this.info.fontList[index].descendantFont.ref);
                    this.sw.writeLine('/Encoding /Identity-H');
                    this.sw.writeLine1('/ToUnicode {0} 0 R', this.info.fontList[index].toUnicode.ref);
                    this.sw.writeLine1('/Name /F{0}', index);
                    this.sw.writeLine('>>');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                    this.addXref(this.info.fontList[index].descendantFont.ref);
                    this.sw.writeLine1('{0} 0 obj', this.info.fontList[index].descendantFont.ref);
                    this.sw.writeLine('<<');
                    this.sw.writeLine('/Type /Font');
                    this.sw.writeLine('/Subtype /CIDFontType2');
                    this.sw.writeLine1('/BaseFont /{0}', tempSb);
                    this.sw.writeLine('/CIDSystemInfo');
                    this.sw.writeLine('<<');
                    this.storeStringLine('/Registry', 'Adobe');
                    this.storeStringLine('/Ordering', 'Identity');
                    this.sw.writeLine('/Supplement 0');
                    this.sw.writeLine('>>');
                    this.sw.writeLine1('/FontDescriptor {0} 0 R', this.info.fontList[index].fontDescriptor.ref);
                    if (this.usePdfA) {
                        this.sw.writeLine('/CIDToGIDMap /Identity');
                    }
                    this.sw.writeLine('/W [0 [1000]');
                    let pdfGlyphList = this.pdfFont.GlyphList;
                    let pdfGlyphListLength = pdfGlyphList.length;
                    let glyphList = StiArray.create(Number, pdfGlyphListLength);
                    let glyphListBack = StiArray.create(Number, pdfGlyphListLength);
                    for (let glyphIndex = 32; glyphIndex < pdfGlyphListLength; glyphIndex++) {
                        glyphList[glyphIndex] = pdfGlyphList[glyphIndex];
                        glyphListBack[glyphIndex] = glyphIndex;
                    }
                    for (let index1 = 32; index1 < glyphList.length - 1; index1++) {
                        for (let index2 = index1 + 1; index2 < glyphList.length; index2++) {
                            if (glyphList[index1] > glyphList[index2]) {
                                let tempGlyph = glyphList[index1];
                                glyphList[index1] = glyphList[index2];
                                glyphList[index2] = tempGlyph;
                                let tempGlyphBack = glyphListBack[index1];
                                glyphListBack[index1] = glyphListBack[index2];
                                glyphListBack[index2] = tempGlyphBack;
                            }
                        }
                    }
                    let sb = new StringBuilder();
                    let mapIndex = 32;
                    while (mapIndex < this.pdfFont.MappedSymbolsCount) {
                        sb.append(glyphList[mapIndex].toString() + ' [');
                        sb.append(this.pdfFont.Widths[glyphListBack[mapIndex] - 32].toString());
                        mapIndex++;
                        while (mapIndex < this.pdfFont.MappedSymbolsCount && glyphList[mapIndex] - 1 == glyphList[mapIndex - 1]) {
                            sb.append(' ' + this.pdfFont.Widths[glyphListBack[mapIndex] - 32].toString());
                            mapIndex++;
                        }
                        while (mapIndex < this.pdfFont.MappedSymbolsCount && glyphList[mapIndex] == glyphList[mapIndex - 1]) {
                            mapIndex++;
                        }
                        sb.append(']');
                        this.sw.writeLine1('{0}', sb);
                        sb = new StringBuilder();
                    }
                    if (this.pdfFont.GlyphWidths != null && this.pdfFont.GlyphWidths[65535] != 0) {
                    }
                    this.sw.writeLine(']');
                    this.sw.writeLine('>>');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                    this.addXref(this.info.fontList[index].toUnicode.ref);
                    let cmapFontName = 'SR+F' + index.toString();
                    this.sw.writeLine1('{0} 0 obj', this.info.fontList[index].toUnicode.ref);
                    this.sw.writeLine('<<');
                    let swmem = new MemoryStream();
                    swmem.writeLine('/CIDInit /ProcSet findresource begin');
                    swmem.writeLine('12 dict begin');
                    swmem.writeLine('begincmap');
                    swmem.writeLine('/CIDSystemInfo');
                    swmem.writeLine('<<');
                    swmem.writeLine('/Registry (Adobe)');
                    swmem.writeLine1('/Ordering ({0})', cmapFontName);
                    swmem.writeLine('/Supplement 0');
                    swmem.writeLine('>> def');
                    swmem.writeLine1('/CMapName /{0} def', cmapFontName);
                    swmem.writeLine('/CMapType 2 def');
                    swmem.writeLine('1 begincodespacerange');
                    swmem.writeLine('<0000> <FFFF>');
                    swmem.writeLine('endcodespacerange');
                    let countBfChar = this.pdfFont.MappedSymbolsCount - 32;
                    let offsetBfChar = 32;
                    while (countBfChar > 0) {
                        let count = countBfChar;
                        if (count > 100)
                            count = 100;
                        swmem.writeLine1('{0} beginbfchar', count);
                        for (let indexUni = 0; indexUni < count; indexUni++) {
                            swmem.writeLine1('<{0:X4}> <{1:X4}>', this.pdfFont.GlyphList[offsetBfChar], this.pdfFont.UnicodeMapBack[offsetBfChar]);
                            offsetBfChar++;
                        }
                        swmem.writeLine('endbfchar');
                        countBfChar -= count;
                    }
                    swmem.writeLine('endcmap');
                    swmem.writeLine('CMapName currentdict /CMap defineresource pop');
                    swmem.writeLine('end');
                    swmem.writeLine('end');
                    swmem.flush();
                    let buff = swmem.toArray();
                    swmem.close();
                    if (this.compressed == true) {
                        let tmpStream = __.b.StiExportUtils.makePdfDeflateStream(buff);
                        this.storeMemoryStream2(tmpStream, '/Length {0} /Filter [/FlateDecode] /Length1 ' + buff.length.toString());
                    } else {
                        this.storeMemoryStream4(buff, '/Length {0} /Filter [] /Length1 {0}');
                    }
                    this.sw.writeLine('');
                    this.sw.writeLine('endstream');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                    this.addXref(this.info.fontList[index].cIDSet.ref);
                    this.sw.writeLine1('{0} 0 obj', this.info.fontList[index].cIDSet.ref);
                    this.sw.writeLine('<<');
                    let bits = StiArray.create(Boolean, 65536 + 32);
                    let maxIndex = 0;
                    for (let indexGlyph = 0; indexGlyph < this.pdfFont.GlyphList.length; indexGlyph++) {
                        let glyph = this.pdfFont.GlyphList[indexGlyph];
                        if (glyph != 65535) {
                            bits[glyph] = true;
                            if (glyph > maxIndex)
                                maxIndex = glyph;
                        }
                    }
                    if (this.pdfFont.GlyphWidths != null && this.pdfFont.GlyphWidths[65535] != 0) {
                        for (let indexGlyph = 0; indexGlyph < 65535; indexGlyph++) {
                            if (this.pdfFont.GlyphWidths[indexGlyph] > 0 && this.pdfFont.GlyphBackList[indexGlyph] == 0) {
                                bits[indexGlyph] = true;
                                if (indexGlyph > maxIndex)
                                    maxIndex = indexGlyph;
                            }
                        }
                    }
                    let bytesCount = StiMath.trunc(maxIndex / 8) + 1;
                    let buff2 = StiArray.create(Number, bytesCount + 1);
                    let pos = 0;
                    while (pos < bytesCount) {
                        let offset = pos * 8;
                        let val = 0;
                        if (bits[offset])
                            val |= 128;
                        if (bits[offset + 1])
                            val |= 64;
                        if (bits[offset + 2])
                            val |= 32;
                        if (bits[offset + 3])
                            val |= 16;
                        if (bits[offset + 4])
                            val |= 8;
                        if (bits[offset + 5])
                            val |= 4;
                        if (bits[offset + 6])
                            val |= 2;
                        if (bits[offset + 7])
                            val |= 1;
                        buff2[pos] = val;
                        pos++;
                    }
                    if (this.compressed == true) {
                        let tmpStream = __.b.StiExportUtils.makePdfDeflateStream(buff2);
                        this.storeMemoryStream2(tmpStream, '/Length {0} /Filter [/FlateDecode] /Length1 ' + buff2.length.toString());
                    } else {
                        this.storeMemoryStream4(buff2, '/Length {0} /Filter [] /Length1 ' + buff2.length.toString());
                    }
                    this.sw.writeLine('');
                    this.sw.writeLine('endstream');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                } else {
                    this.addXref(this.info.fontList[index].ref);
                    this.sw.writeLine1('{0} 0 obj', this.info.fontList[index].ref);
                    this.sw.writeLine('<<');
                    this.sw.writeLine('/Type /Font');
                    if (this.standardPdfFonts == true) {
                        this.sw.writeLine('/Subtype /Type1');
                        this.sw.writeLine1('/BaseFont /{0}', tempInfo.PdfName);
                    } else {
                        this.sw.writeLine('/Subtype /TrueType');
                        tempSb = new StringBuilder(this.stringReplace(fontName, ' ', '#20'));
                        if (tempInfo.Bold == true || tempInfo.Italic == true) {
                            tempSb.append(',');
                            if (tempInfo.Bold == true)
                                tempSb.append('Bold');
                            if (tempInfo.Italic == true)
                                tempSb.append('Italic');
                        }
                        this.sw.writeLine1('/BaseFont /{0}', tempSb);
                        this.sw.writeLine1('/FontDescriptor {0} 0 R', this.info.fontList[index].fontDescriptor.ref);
                    }
                    this.sw.writeLine1('/Encoding {0} 0 R', this.info.fontList[index].encoding.ref);
                    let sbWidths = new StringBuilder(' ');
                    for (let indexUni = 32; indexUni < this.pdfFont.MappedSymbolsCount; indexUni++) {
                        sbWidths.append(this.pdfFont.Widths[indexUni - 32].toString() + ' ');
                    }
                    this.sw.writeLine1('/FirstChar {0}', 32);
                    this.sw.writeLine1('/LastChar {0}', this.pdfFont.MappedSymbolsCount - 1);
                    this.sw.writeLine1('/Widths [{0}]', sbWidths);
                    this.sw.writeLine1('/Name /F{0}', index);
                    this.sw.writeLine('>>');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                    this.addXref(this.info.fontList[index].encoding.ref);
                    this.sw.writeLine1('{0} 0 obj', this.info.fontList[index].encoding.ref);
                    this.sw.writeLine('<<');
                    this.sw.writeLine('/Type /Encoding');
                    this.sw.writeLine('/BaseEncoding /WinAnsiEncoding');
                    if (this.pdfFont.MappedSymbolsCount > this.pdfFont.firstMappedSymbol) {
                        let sbDifferences = new StringBuilder(this.pdfFont.firstMappedSymbol.toString() + ' ');
                        for (let indexUni = this.pdfFont.firstMappedSymbol; indexUni < this.pdfFont.MappedSymbolsCount; indexUni++) {
                            sbDifferences.append('/' + this.pdfFont.CharPdfNames[indexUni]);
                        }
                        this.sw.writeLine1('/Differences [{0}]', sbDifferences);
                    }
                    this.sw.writeLine('>>');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                }
                let buff = null;
                if (needEmbeddedFonts) {
                    buff = this.pdfFont.getFontDataBuf(tempInfo.Font, this.report);
                }
                if (this.standardPdfFonts == false) {
                    this.addXref(this.info.fontList[index].fontDescriptor.ref);
                    this.sw.writeLine1('{0} 0 obj', this.info.fontList[index].fontDescriptor.ref);
                    this.sw.writeLine('<<');
                    this.sw.writeLine('/Type /FontDescriptor');
                    this.sw.writeLine1('/FontName /{0}', tempSb);
                    this.sw.writeLine('/Flags 32');
                    this.sw.writeLine1('/Ascent {0}', this.pdfFont.tmASC);
                    this.sw.writeLine1('/CapHeight {0}', this.pdfFont.CH);
                    this.sw.writeLine1('/Descent {0}', this.pdfFont.tmDESC);
                    this.sw.writeLine1('/FontBBox [{0} {1} {2} {3}]', this.pdfFont.LLX, this.pdfFont.LLY, this.pdfFont.URX, this.pdfFont.URY);
                    this.sw.writeLine1('/ItalicAngle {0}', this.pdfFont.ItalicAngle);
                    this.sw.writeLine1('/StemV {0}', this.pdfFont.StemV);
                    if (needEmbeddedFonts && buff != null) {
                        this.sw.writeLine1('/FontFile2 {0} 0 R', this.info.fontList[tempInfo.ParentFontNumber == -1 ? index : tempInfo.ParentFontNumber].fontFile2.ref);
                    }
                    let needCIDSet = this.pdfFont.UseUnicode;
                    if (this.pdfComplianceMode == __.b.StiPdfComplianceMode.A2 || this.pdfComplianceMode == __.b.StiPdfComplianceMode.A3)
                        needCIDSet = false;
                    if (needCIDSet) {
                        this.sw.writeLine1('/CIDSet {0} 0 R', this.info.fontList[index].cIDSet.ref);
                    }
                    this.sw.writeLine('>>');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                }
                if (needEmbeddedFonts) {
                    if (buff != null && buff.length > 0 && tempInfo.ParentFontNumber == -1) {
                        if (this.reduceFontSize) {
                            let buff2 = this.pdfFont.reduceFontSize(buff, tempInfo.Name, !this.fontGlyphsReduceNotNeed[index]);
                            if (buff2 != null)
                                buff = buff2;
                        }
                        this.addXref(this.info.fontList[index].fontFile2.ref);
                        this.sw.writeLine1('{0} 0 obj', this.info.fontList[index].fontFile2.ref);
                        this.sw.writeLine('<<');
                        if (this.compressedFonts == true) {
                            if (buff instanceof Uint8Array) {
                                let tmpStream = __.b.StiExportUtils.makePdfDeflateStream(buff);
                                this.storeMemoryStream2(tmpStream, '/Length {0} /Filter [/FlateDecode] /Length1 ' + buff.length.toString());
                            }
                            if (buff instanceof MemoryStream) {
                                let tempBuf = buff.toArray();
                                let tmpStream = __.b.StiExportUtils.makePdfDeflateStream(tempBuf);
                                this.storeMemoryStream2(tmpStream, '/Length {0} /Filter [/FlateDecode] /Length1 ' + buff.length.toString());
                            }
                        } else {
                            if (buff instanceof Uint8Array)
                                this.storeMemoryStream3(buff, '/Length {0} /Filter [] /Length1 ' + buff.length.toString());
                            if (buff instanceof MemoryStream)
                                this.storeMemoryStream2(buff, '/Length {0} /Filter [] /Length1 ' + buff.length.toString());
                        }
                        this.sw.writeLine('');
                        this.sw.writeLine('endstream');
                        this.sw.writeLine('endobj');
                        this.sw.writeLine('');
                    } else {
                        this.addXref(this.info.fontList[index].fontFile2.ref);
                        this.sw.writeLine1('{0} 0 obj', this.info.fontList[index].fontFile2.ref);
                        this.sw.writeLine('<< >>');
                        this.sw.writeLine('endobj');
                        this.sw.writeLine('');
                    }
                }
            }
        }
        renderImageTable() {
            if (this.imageCache.imageStore.length > 0) {
                for (let index = 0; index < this.imageCache.imageStore.length; index++) {
                    let pd = this.imageCacheIndexToList.get(index);
                    let bytes = this.imageCache.imagePackedStore[index];
                    let mask = this.imageCache.imageMaskStore[index];
                    let imageFormatCurrent = pd.ImageFormat;
                    this.addXref(this.info.xObjectList[index].ref);
                    this.sw.writeLine1('{0} 0 obj', this.info.xObjectList[index].ref);
                    this.sw.writeLine('<<');
                    this.sw.writeLine('/Type /XObject');
                    this.sw.writeLine('/Subtype /Image');
                    this.sw.writeLine1('/ColorSpace /{0}', imageFormatCurrent == __.b.StiImageFormat.Monochrome ? 'DeviceGray' : 'DeviceRGB');
                    this.sw.writeLine1('/Width {0}', pd.Width);
                    this.sw.writeLine1('/Height {0}', pd.Height);
                    this.sw.writeLine1('/BitsPerComponent {0}', imageFormatCurrent == __.b.StiImageFormat.Monochrome ? '1' : '8');
                    if (!this.usePdfA && this.imageInterpolationTable.containsKey(index)) {
                        this.sw.writeLine('/Interpolate true');
                    }
                    if (mask != null) {
                        this.sw.writeLine1('/SMask {0} 0 R', this.info.xObjectList[index].mask.ref);
                    }
                    this.sw.writeLine1('/Name /{0}', pd.Name);
                    let compressionType = 'DCTDecode';
                    if (this.imageCompressionMethod == __.b.StiPdfImageCompressionMethod.Flate)
                        compressionType = 'FlateDecode';
                    if (bytes == null) {
                        bytes = [
                            56,
                            48,
                            56,
                            48,
                            56,
                            48
                        ];
                        compressionType = 'ASCIIHexDecode';
                    }
                    let stImage = '/Length {0} ' + StiString.format('/Filter [/{0}]', compressionType);
                    let TmpStream = new MemoryStream();
                    TmpStream.write(bytes, 0, bytes.length);
                    this.storeMemoryStream2(TmpStream, stImage);
                    this.sw.writeLine('');
                    this.sw.writeLine('endstream');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                    if (mask != null) {
                        this.addXref(this.info.xObjectList[index].mask.ref);
                        this.sw.writeLine1('{0} 0 obj', this.info.xObjectList[index].mask.ref);
                        this.sw.writeLine('<<');
                        this.sw.writeLine('/Type /XObject');
                        this.sw.writeLine('/Subtype /Image');
                        this.sw.writeLine('/ColorSpace /DeviceGray');
                        this.sw.writeLine('/Matte [ 0 0 0 ]');
                        this.sw.writeLine1('/Width {0}', pd.Width);
                        this.sw.writeLine1('/Height {0}', pd.Height);
                        this.sw.writeLine('/BitsPerComponent 8');
                        if (!this.usePdfA && this.imageInterpolationTable.containsKey(index)) {
                            this.sw.writeLine('/Interpolate true');
                        }
                        let stMask = '/Length {0} /Filter /FlateDecode';
                        let TmpStream2 = new MemoryStream();
                        TmpStream2.write(mask, 0, mask.length);
                        this.storeMemoryStream2(TmpStream2, stMask);
                        this.sw.writeLine('');
                        this.sw.writeLine('endstream');
                        this.sw.writeLine('endobj');
                        this.sw.writeLine('');
                    }
                }
            }
        }
        renderBookmarksTable() {
            if (this.haveBookmarks) {
                this.addXref(this.info.outlines.ref);
                this.sw.writeLine1('{0} 0 obj', this.info.outlines.ref);
                this.sw.writeLine('<<');
                this.sw.writeLine('/Type /Outlines');
                this.sw.writeLine1('/First {0} 0 R', this.info.outlines.items[0].ref);
                this.sw.writeLine1('/Last {0} 0 R', this.info.outlines.items[0].ref);
                this.sw.writeLine1('/Count {0}', 1);
                this.sw.writeLine('>>');
                this.sw.writeLine('endobj');
                this.sw.writeLine('');
                for (let index = 0; index < this.bookmarksCounter; index++) {
                    this.addXref(this.info.outlines.items[index].ref);
                    let tn = this.bookmarksTree[index];
                    this.sw.writeLine1('{0} 0 obj', this.info.outlines.items[index].ref);
                    this.sw.writeLine('<<');
                    this.storeStringLine('/Title ', tn.Title, true);
                    if (tn.Parent != -1)
                        this.sw.writeLine1('/Parent {0} 0 R', this.info.outlines.items[tn.Parent].ref);
                    if (tn.Prev != -1)
                        this.sw.writeLine1('/Prev {0} 0 R', this.info.outlines.items[tn.Prev].ref);
                    if (tn.Next != -1)
                        this.sw.writeLine1('/Next {0} 0 R', this.info.outlines.items[tn.Next].ref);
                    if (tn.First != -1)
                        this.sw.writeLine1('/First {0} 0 R', this.info.outlines.items[tn.First].ref);
                    if (tn.Last != -1)
                        this.sw.writeLine1('/Last {0} 0 R', this.info.outlines.items[tn.Last].ref);
                    if (tn.Count > 0) {
                        if (index == 0) {
                            this.sw.writeLine1('/Count {0}', tn.Count);
                        } else {
                            this.sw.writeLine1('/Count {0}', -tn.Count);
                        }
                    }
                    if (tn.Y > -1)
                        this.sw.writeLine1('/Dest [{0} 0 R /XYZ null {1} null]', this.info.pageList[tn.Page].ref, this.convertToString(tn.Y));
                    this.sw.writeLine('>>');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                }
            }
        }
        renderPatternTable() {
            this.addXref(this.info.patterns.resources.ref);
            this.sw.writeLine1('{0} 0 obj', this.info.patterns.resources.ref);
            this.sw.writeLine('<< /ProcSet [/PDF] >>');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
            this.addXref(this.info.patterns.first.ref);
            this.sw.writeLine1('{0} 0 obj', this.info.patterns.first.ref);
            this.sw.writeLine('<<');
            this.sw.writeLine('/Type /Pattern');
            this.sw.writeLine('/PatternType 1');
            this.sw.writeLine('/PaintType 1');
            this.sw.writeLine('/TilingType 1');
            this.sw.writeLine('/BBox [0 0 2 2]');
            this.sw.writeLine('/XStep 3');
            this.sw.writeLine('/YStep 3');
            this.sw.writeLine1('/Resources {0} 0 R', this.info.patterns.resources.ref);
            this.pageStream = new MemoryStream();
            this.pageStream.writeLine('1 J 1 j 1 w');
            this.pageStream.writeLine('1 0 0 RG');
            this.pageStream.writeString('1 1 m 1.1 1.1 l S');
            this.storeMemoryStream2(this.pageStream, '/Length {0}');
            this.sw.writeLine('');
            this.sw.writeLine('endstream');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
            if (this.hatchArray.length > 0) {
                for (let indexHatch = 0; indexHatch < this.hatchArray.length; indexHatch++) {
                    this.writeHatchPattern(indexHatch);
                }
            }
            if (this.shadingArray.length > 0) {
                for (let indexShading = 0; indexShading < this.shadingArray.length; indexShading++) {
                    this.writeShadingPattern(indexShading);
                }
            }
            if (this.shadingFunctionArray.length > 0) {
                for (let indexShadingFunction = 0; indexShadingFunction < this.shadingFunctionArray.length; indexShadingFunction++) {
                    this.writeShadingFunction(indexShadingFunction);
                }
                this.sw.writeLine('');
            }
            this.pageStream.close();
        }
        writeHatchPattern(indexHatch) {
            let hatch = this.hatchArray[indexHatch];
            let hatchNumber = hatch.style;
            if (hatchNumber > 53)
                hatchNumber = 53;
            this.addXref(this.info.patterns.hatchItems[indexHatch].ref);
            this.sw.writeLine1('{0} 0 obj', this.info.patterns.hatchItems[indexHatch].ref);
            this.sw.writeLine('<<');
            this.sw.writeLine('/Type /Pattern');
            this.sw.writeLine('/PatternType 1');
            this.sw.writeLine('/PaintType 1');
            this.sw.writeLine('/TilingType 1');
            this.sw.writeLine('/BBox [0 0 1 1]');
            this.sw.writeLine('/XStep 1');
            this.sw.writeLine('/YStep 1');
            this.sw.writeLine1('/Resources {0} 0 R', this.info.patterns.resources.ref);
            this.sw.writeLine('/Matrix [5.5 0 0 5.5 0 0]');
            let memsw = new MemoryStream();
            if (hatch.backColor.a != 0) {
                memsw.writeLine1('{0} {1} {2} rg', this.colorTable[hatch.backColor.r], this.colorTable[hatch.backColor.g], this.colorTable[hatch.backColor.b]);
                memsw.writeLine('0 0 1 1 re f');
            }
            memsw.writeLine1('{0} {1} {2} rg', this.colorTable[hatch.foreColor.r], this.colorTable[hatch.foreColor.g], this.colorTable[hatch.foreColor.b]);
            memsw.writeLine('BI');
            memsw.writeLine('/W 8');
            memsw.writeLine('/H 8');
            memsw.writeLine('/BPC 1');
            memsw.writeLine('/IM true');
            memsw.writeLine('/D [1 0]');
            memsw.writeLine('/F [/AHx]');
            memsw.writeLine('ID');
            memsw.writeLine(__.b.StiPdfResources.hatchData[hatchNumber] + '>');
            memsw.writeLine('EI');
            memsw.flush();
            this.storeMemoryStream2(memsw, '/Length {0}');
            this.sw.writeLine('endstream');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
        }
        writeShadingPattern(indexShading) {
            let ssd = this.shadingArray[indexShading];
            let xs = 1;
            let ys = 1;
            let angle = ssd.Angle;
            if (angle < 0)
                angle += 360;
            if (angle >= 270 && angle < 360) {
                angle = 360 - angle;
                ys = -1;
            }
            if (angle >= 180 && angle < 270) {
                angle = angle - 180;
                ys = -1;
                xs = -1;
            }
            if (angle >= 90 && angle < 180) {
                angle = 180 - angle;
                xs = -1;
            }
            angle = angle * Math.PI / 180;
            let x0 = ssd.X + ssd.Width / 2;
            let y0 = ssd.Y + ssd.Height / 2;
            let r = Math.sqrt(ssd.Width * ssd.Width + ssd.Height * ssd.Height) / 2;
            let a2 = Math.atan2(ssd.Height, ssd.Width);
            let st = Math.PI / 2 - angle + a2;
            let b = r * Math.sin(st);
            let xr = b * Math.cos(angle) * xs;
            let yr = b * Math.sin(angle) * ys;
            let x1 = x0 - xr;
            let x2 = x0 + xr;
            let y1 = y0 + yr;
            let y2 = y0 - yr;
            this.addXref(this.info.patterns.shadingItems[indexShading].ref);
            this.sw.writeLine1('{0} 0 obj', this.info.patterns.shadingItems[indexShading].ref);
            this.sw.writeString('<<');
            this.sw.writeString('/PatternType 2');
            this.sw.writeString('/Shading <<');
            this.sw.writeString('/ColorSpace /DeviceRGB');
            this.sw.writeString('/ShadingType 2');
            this.sw.writeString(StiString.format('/Coords [{0} {1} {2} {3}]', this.convertToString(x1), this.convertToString(y1), this.convertToString(x2), this.convertToString(y2)));
            this.sw.writeString('/Extend [true true]');
            this.sw.writeString(StiString.format('/Function {0} 0 R', this.info.patterns.shadingFunctionItems[ssd.FunctionIndex].ref));
            this.sw.writeString('>> ');
            this.sw.writeLine('>>');
            this.sw.writeLine('endobj');
        }
        writeShadingFunction(indexShadingFunction) {
            let sf = this.shadingFunctionArray[indexShadingFunction];
            this.addXref(this.info.patterns.shadingFunctionItems[indexShadingFunction].ref);
            this.sw.writeLine1('{0} 0 obj', this.info.patterns.shadingFunctionItems[indexShadingFunction].ref);
            this.sw.writeString('<<');
            this.sw.writeString('/FunctionType 0');
            this.sw.writeString('/Size [3]');
            this.sw.writeString('/Decode [0 1 0 1 0 1]');
            this.sw.writeString('/Range [0 1 0 1 0 1]');
            this.sw.writeString('/BitsPerSample 8');
            this.sw.writeString('/Domain [0 1]');
            this.sw.writeString(StiString.format('/Encode [0 {0}]', sf.IsGlare ? 2 : 1));
            this.sw.writeString('/Order 1');
            let memsw = new MemoryStream();
            memsw.writeByte(sf.Color1.r);
            memsw.writeByte(sf.Color1.g);
            memsw.writeByte(sf.Color1.b);
            memsw.writeByte(sf.Color2.r);
            memsw.writeByte(sf.Color2.g);
            memsw.writeByte(sf.Color2.b);
            memsw.writeByte(sf.Color1.r);
            memsw.writeByte(sf.Color1.g);
            memsw.writeByte(sf.Color1.b);
            this.storeMemoryStream2(memsw, '/Length {0}');
            this.sw.writeLine('');
            this.sw.writeLine('endstream');
            this.sw.writeLine('endobj');
        }
        renderLinkTable() {
            if (this.haveLinks) {
                for (let index = 0; index < this.linksCounter; index++) {
                    let stl = this.linksArray[index];
                    if (stl.Link.stimulsoft().startsWith('##') && this.tagsArray.stimulsoft().countItems > 0) {
                        let st = stl.Link.substr(2);
                        for (let indexTag = 0; indexTag < this.tagsArray.stimulsoft().countItems; indexTag++) {
                            let tag = this.tagsArray[indexTag];
                            if (tag.Link == st) {
                                stl.DestPage = tag.Page;
                                stl.DestY = tag.Y + tag.Height;
                                break;
                            }
                        }
                    } else {
                        if (stl.Link.charAt(0) == '#' && this.haveBookmarks) {
                            let st = stl.Link.substr(1);
                            if (st.charAt(0) == '%' && st.length > 2) {
                                let pos = st.lastIndexOf(st.charAt(1));
                                if (pos < st.length - 1) {
                                    st = st.substr(pos + 1);
                                }
                            }
                            for (let indexBookmark = 0; indexBookmark < this.bookmarksCounter; indexBookmark++) {
                                let tn = this.bookmarksTree[indexBookmark];
                                if (tn.Title == st) {
                                    stl.DestPage = tn.Page;
                                    stl.DestY = tn.Y;
                                    break;
                                }
                            }
                        }
                    }
                    this.linksArray[index] = stl;
                    this.addXref(this.info.linkList[index].ref);
                    this.sw.writeLine1('{0} 0 obj', this.info.linkList[index].ref);
                    this.sw.writeLine('<<');
                    this.sw.writeLine('/Type /Annot');
                    this.sw.writeLine('/Subtype /Link');
                    this.sw.writeLine1('/Rect [{0} {1} {2} {3}]', this.convertToString(stl.X), this.convertToString(stl.Y), this.convertToString(stl.X + stl.Width), this.convertToString(stl.Y + stl.Height));
                    this.sw.writeLine('/Border [0 0 0]');
                    if (stl.Link.charAt(0) == '#') {
                        if (stl.DestY > -1)
                            this.sw.writeLine1('/Dest [{0} 0 R /XYZ null {1} null]', this.info.pageList[stl.DestPage].ref, this.convertToString(stl.DestY));
                        else
                            this.sw.writeLine1('/Dest [{0} 0 R /XYZ null null null]', this.info.pageList[0].ref);
                    } else {
                        let link = this.stringReplace(stl.Link, '\\', '/');
                        let flag = link.length > 6 && (Char.isLetter(link, 0) && link.charAt(1) == ':' && link.charAt(2) == '/') || link.charAt(0) == '/' && Char.isLetter(link, 1) && link.charAt(2) == '/';
                        if (flag && link.charAt(1) == ':')
                            link = '/' + link.charAt(0) + link.substr(2);
                        this.sw.writeLine('/A <<');
                        this.sw.writeLine('/Type /Action');
                        if (flag) {
                            this.sw.writeLine('/S /Launch');
                            this.sw.writeLine('/F <<');
                            this.sw.writeLine('/Type /Filespec');
                            this.storeStringLine('/F ', link);
                            this.storeStringLine('/UF ', link);
                            this.sw.writeLine('>>');
                        } else {
                            this.sw.writeLine('/S /URI');
                            this.storeStringLine('/URI ', __.b.StiExportUtils.stringToUrl(link));
                        }
                        this.sw.writeLine('>>');
                    }
                    this.sw.writeLine('>>');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                }
            }
        }
        renderAnnotTable() {
            if (this.haveAnnots || this.haveDigitalSignature || this.haveTooltips) {
                this.addXref(this.info.acroForm.ref);
                this.sw.writeLine1('{0} 0 obj', this.info.acroForm.ref);
                this.sw.writeLine('<<');
                this.sw.writeLine('/Fields [');
                for (let index = 0; index < this.annotsCounter; index++) {
                    this.sw.writeLine1('{0} 0 R', this.info.acroForm.annots[index].ref);
                }
                for (let index = 0; index < this.annots2Counter; index++) {
                    for (let indexState = 0; indexState < this.info.acroForm.checkBoxes[index].items.length; indexState++) {
                        this.sw.writeLine1('{0} 0 R', this.info.acroForm.checkBoxes[index].items[indexState].ref);
                    }
                }
                for (let index = 0; index < this.unsignedSignaturesCounter; index++) {
                    this.sw.writeLine1('{0} 0 R', this.info.acroForm.unsignedSignatures[index].ref);
                }
                if (this.haveDigitalSignature) {
                    this.sw.writeLine1('{0} 0 R', this.info.acroForm.signatures[0].ref);
                }
                for (let index = 0; index < this.tooltipsCounter; index++) {
                    this.sw.writeLine1('{0} 0 R', this.info.acroForm.tooltips[index].ref);
                }
                this.sw.writeLine(']');
                this.sw.writeLine('/DR <<');
                if (this.annotsCounter > 0 || this.annots2Counter > 0) {
                    this.sw.writeLine('/Font <<');
                    for (let index = 0; index < this.fontsCounter; index++) {
                        this.sw.writeLine1('/FA{0} {1} 0 R', index, this.info.acroForm.annotFontItems[index].ref);
                    }
                    this.sw.writeLine('>>');
                }
                this.sw.writeLine('>>');
                if (this.haveAnnots && this.fontsCounter > 0) {
                    this.storeStringLine('/DA ', '/FA0 0 Tf 0 g');
                }
                if (this.haveDigitalSignature) {
                    this.sw.writeLine('/SigFlags 3');
                }
                this.sw.writeLine('>>');
                this.sw.writeLine('endobj');
                this.sw.writeLine('');
                if (this.haveAnnots) {
                    let fieldsNames = new Hashtable();
                    for (let index = 0; index < this.annotsCounter; index++) {
                        let seo = this.annotsArray[index];
                        let fieldName = '';
                        if (Stimulsoft['StiOptions'].Export.Pdf.useEditableFieldName)
                            fieldName = seo.Component.name;
                        if (Stimulsoft['StiOptions'].Export.Pdf.useEditableFieldAlias)
                            fieldName = seo.Component.alias;
                        if (Stimulsoft['StiOptions'].Export.Pdf.useEditableFieldTag)
                            fieldName = seo.Component.tagValue;
                        if (StiString.isNullOrEmpty(fieldName))
                            fieldName = StiString.format('Field{0}', index);
                        if (fieldsNames.containsKey(fieldName)) {
                            let indexName = 2;
                            let nameAdd = '';
                            while (fieldsNames.containsKey(fieldName + nameAdd)) {
                                nameAdd = '_' + indexName.toString();
                                indexName++;
                            }
                            fieldName = fieldName + nameAdd;
                        }
                        fieldsNames.add(fieldName, fieldName);
                        this.addXref(this.info.acroForm.annots[index].ref);
                        this.sw.writeLine1('{0} 0 obj', this.info.acroForm.annots[index].ref);
                        this.sw.writeLine('<<');
                        this.sw.writeLine('/Type /Annot');
                        this.sw.writeLine('/Subtype /Widget');
                        this.sw.writeLine1('/Rect [{0} {1} {2} {3}]', this.convertToString(seo.X), this.convertToString(seo.Y), this.convertToString(seo.X + seo.Width), this.convertToString(seo.Y + seo.Height));
                        this.sw.writeLine('/F 4');
                        this.sw.writeLine1('/P {0} 0 R', this.info.pageList[seo.Page].ref);
                        this.sw.writeLine('/FT /Tx');
                        this.sw.writeLine('/BS << /W 0 >>');
                        this.storeStringLine('/T ', fieldName);
                        this.sw.writeLine('/MK << /TP 2 >>');
                        this.sw.writeLine('/H /P');
                        this.sw.writeLine1('/AP << /N {0} 0 R >>', this.info.acroForm.annots[index].aP.ref);
                        let flagFf = seo.Multiline ? 4096 : 0;
                        if (seo.Component.as(StiText) != null && seo.Component.as(StiText).textOptions != null) {
                            if (seo.Component.as(StiText).textOptions.lineLimit)
                                flagFf |= 8388608;
                        }
                        this.sw.writeLine1('/Ff {0}', flagFf);
                        this.storeStringLine('/DA ', StiString.format('/FA{0} {1} Tf {2} {3} {4} rg', seo.FontNumber, this.convertToString(seo.FontSize, this.precision_digits_font), this.colorTable[seo.FontColor.r], this.colorTable[seo.FontColor.g], this.colorTable[seo.FontColor.b]));
                        this.storeStringLine('/V ', seo.Text, true);
                        this.storeStringLine('/DV ', seo.Text, true);
                        this.sw.writeLine1('/Q {0}', (seo.Alignment == Stimulsoft.Base.Drawing.StiTextHorAlignment.Center ? 1 : 0) + (seo.Alignment == Stimulsoft.Base.Drawing.StiTextHorAlignment.Right ? 2 : 0));
                        this.sw.writeLine('>>');
                        this.sw.writeLine('endobj');
                        this.sw.writeLine('');
                        this.addXref(this.info.acroForm.annots[index].aP.ref);
                        this.sw.writeLine1('{0} 0 obj', this.info.acroForm.annots[index].aP.ref);
                        this.sw.writeLine('<<');
                        this.sw.writeLine('/Subtype /Form');
                        this.sw.writeLine1('/BBox [{0} {1} {2} {3}]', this.convertToString(0), this.convertToString(0), this.convertToString(seo.Width), this.convertToString(seo.Height));
                        this.sw.writeLine('/Resources <<');
                        this.sw.writeLine('/ProcSet [ /PDF /Text ]');
                        this.sw.writeString('/Font << ');
                        for (let indexf = 0; indexf < this.fontsCounter; indexf++) {
                            this.sw.writeString(StiString.format('/F{0} {1} 0 R ', indexf, this.info.fontList[indexf].ref));
                        }
                        this.sw.writeLine('>> >>');
                        let annotSw = new MemoryStream();
                        annotSw.writeLine('/Tx BMC');
                        annotSw.writeLine('q');
                        let borderOffset = 1;
                        annotSw.writeLine1('{0} {1} {2} {3} re W n', this.convertToString(borderOffset), this.convertToString(borderOffset), this.convertToString(seo.Width - borderOffset), this.convertToString(seo.Height - borderOffset));
                        annotSw.flush();
                        annotSw.write(seo.Content, 0, seo.Content.length);
                        annotSw.writeLine('Q');
                        annotSw.writeLine('EMC');
                        annotSw.flush();
                        this.storeMemoryStream2(annotSw, '/Filter [] /Length {0}');
                        this.sw.writeLine('');
                        annotSw.close();
                        this.sw.writeLine('endstream');
                        this.sw.writeLine('endobj');
                        this.sw.writeLine('');
                    }
                    for (let indexFont = 0; indexFont < this.fontsCounter; indexFont++) {
                        this.pdfFont.currentFont = indexFont;
                        let tempInfo = this.pdfFont.fontList[indexFont];
                        let fontName = tempInfo.Name;
                        if (Stimulsoft['StiOptions'].Export.Pdf.useAlternativeFontNames && Stimulsoft['StiOptions'].Export.Pdf.alternativeFontNames.containsKey(fontName)) {
                            fontName = Stimulsoft['StiOptions'].Export.Pdf.alternativeFontNames.get(fontName);
                        }
                        let tempSb = new StringBuilder(this.stringReplace(fontName, ' ', '#20'));
                        if (tempInfo.Bold || tempInfo.Italic) {
                            tempSb.append(',');
                            if (tempInfo.Bold)
                                tempSb.append('Bold');
                            if (tempInfo.Italic)
                                tempSb.append('Italic');
                        }
                        this.addXref(this.info.acroForm.annotFontItems[indexFont].ref);
                        this.sw.writeLine1('{0} 0 obj', this.info.acroForm.annotFontItems[indexFont].ref);
                        this.sw.writeLine('<<');
                        this.sw.writeLine('/Type /Font');
                        this.sw.writeLine('/Subtype /TrueType');
                        this.sw.writeLine1('/Name /FA{0}', indexFont);
                        this.sw.writeLine1('/BaseFont /{0}', tempSb);
                        this.sw.writeLine('/Encoding /WinAnsiEncoding');
                        this.sw.writeLine1('/FontDescriptor {0} 0 R', this.info.acroForm.annotFontItems[indexFont].fontDescriptor.ref);
                        if (this.fontGlyphsReduceNotNeed[indexFont]) {
                            let sbWidths = new StringBuilder(' ');
                            for (let indexUni = 32; indexUni < 256; indexUni++) {
                                sbWidths.append(this.pdfFont.Widths[this.pdfFont.UnicodeMap[this.CodePage1252[indexUni]] - 32].toString() + ' ');
                            }
                            this.sw.writeLine('/FirstChar 32');
                            this.sw.writeLine('/LastChar 255');
                            this.sw.writeLine1('/Widths [{0}]', sbWidths);
                        }
                        this.sw.writeLine('>>');
                        this.sw.writeLine('endobj');
                        this.sw.writeLine('');
                        let buff = null;
                        let needEmbeddedFonts = this.embeddedFonts || __.b.PdfFonts.isFontStimulsoft(tempInfo.Name);
                        if (needEmbeddedFonts) {
                            buff = this.pdfFont.getFontDataBuf(tempInfo.Font, this.report);
                        }
                        this.addXref(this.info.acroForm.annotFontItems[indexFont].fontDescriptor.ref);
                        this.sw.writeLine1('{0} 0 obj', this.info.acroForm.annotFontItems[indexFont].fontDescriptor.ref);
                        this.sw.writeLine('<<');
                        this.sw.writeLine('/Type /FontDescriptor');
                        this.sw.writeLine1('/FontName /{0}', tempSb);
                        this.sw.writeLine('/Flags 32');
                        this.sw.writeLine1('/Ascent {0}', this.pdfFont.tmASC);
                        this.sw.writeLine1('/CapHeight {0}', this.pdfFont.CH);
                        this.sw.writeLine1('/Descent {0}', -this.pdfFont.tmDESC);
                        this.sw.writeLine1('/FontBBox [{0} {1} {2} {3}]', -500, -200, 1500, 1000);
                        this.sw.writeLine1('/ItalicAngle {0}', this.pdfFont.ItalicAngle);
                        this.sw.writeLine1('/StemV {0}', this.pdfFont.StemV);
                        if (needEmbeddedFonts && buff != null) {
                            this.sw.writeLine1('/FontFile2 {0} 0 R', this.info.fontList[indexFont].fontFile2.ref);
                        }
                        this.sw.writeLine('>>');
                        this.sw.writeLine('endobj');
                        this.sw.writeLine('');
                    }
                    for (let index = 0; index < this.annots2Counter; index++) {
                        let seo = this.annots2Array[index];
                        let fieldName = '';
                        if (Stimulsoft['StiOptions'].Export.Pdf.useEditableFieldName)
                            fieldName = seo.Component.name;
                        if (Stimulsoft['StiOptions'].Export.Pdf.useEditableFieldAlias)
                            fieldName = seo.Component.alias;
                        if (Stimulsoft['StiOptions'].Export.Pdf.useEditableFieldTag)
                            fieldName = seo.Component.tagValue;
                        if (StiString.isNullOrEmpty(fieldName))
                            fieldName = StiString.format('Checkbox{0}', index + 1);
                        if (fieldsNames.containsKey(fieldName)) {
                            let indexName = 2;
                            let nameAdd = '';
                            while (fieldsNames.containsKey(fieldName + nameAdd)) {
                                nameAdd = '_' + indexName.toString();
                                indexName++;
                            }
                            fieldName = fieldName + nameAdd;
                        }
                        fieldsNames.add(fieldName, fieldName);
                        const checkboxSizeCorrection = 0.01;
                        let checkbox = seo.Component.as(StiCheckBox);
                        let checkBoxValue = __.b.StiPdfRenderPrimitives.getCheckBoxValue(checkbox);
                        if (checkBoxValue == null)
                            checkBoxValue = false;
                        if (this.info.acroForm.checkBoxes[index].items.length > 1) {
                            let annot = this.info.acroForm.checkBoxes[index].items[0];
                            this.addXref(annot.ref);
                            this.sw.writeLine1('{0} 0 obj', annot.ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine('/Type /Annot');
                            this.sw.writeLine('/Subtype /Widget');
                            this.sw.writeLine('/FT /Btn');
                            this.sw.writeLine1('/Rect [{0} {1} {2} {3}]', this.convertToString(seo.X), this.convertToString(seo.Y), this.convertToString(seo.X + seo.Width - checkboxSizeCorrection), this.convertToString(seo.Y + seo.Height - checkboxSizeCorrection));
                            this.sw.writeLine1('/F {0}', 4 + (this.info.acroForm.checkBoxes[index].items.length == 3 || checkBoxValue == false ? 2 : 0));
                            this.sw.writeLine1('/P {0} 0 R', this.info.pageList[seo.Page].ref);
                            this.storeStringLine('/T ', fieldName + 'Yes');
                            this.sw.writeLine('/MK << >>');
                            this.sw.writeLine('/Ff 65536');
                            this.sw.writeLine1('/A {0} 0 R', annot.aA[0].ref);
                            this.sw.writeLine1('/AP << /N {0} 0 R >>', annot.aP.ref);
                            this.sw.writeLine('/H /O');
                            this.sw.writeLine('>>');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                            this.addXref(annot.aP.ref);
                            this.sw.writeLine1('{0} 0 obj', annot.aP.ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine('/Type /XObject');
                            this.sw.writeLine('/Subtype /Form');
                            this.sw.writeLine('/FormType 1');
                            this.sw.writeLine1('/BBox [{0} {1} {2} {3}]', this.convertToString(0), this.convertToString(0), this.convertToString(seo.Width), this.convertToString(seo.Height));
                            this.sw.writeLine('/Matrix [ 1 0 0 1 0 0 ]');
                            this.sw.writeLine('/Resources <<');
                            this.sw.writeLine('/ProcSet [ /PDF ]');
                            this.sw.writeLine('/Pattern');
                            this.sw.writeLine('<<');
                            for (let indexPattern = 0; indexPattern < this.hatchArray.length; indexPattern++) {
                                this.sw.writeLine1(StiString.format('/PH{0} {1} 0 R', 1 + indexPattern, this.info.patterns.hatchItems[indexPattern].ref));
                            }
                            for (let indexPattern = 0; indexPattern < this.shadingArray.length; indexPattern++) {
                                this.sw.writeLine1(StiString.format('/P{0} {1} 0 R', 2 + indexPattern, this.info.patterns.shadingItems[indexPattern].ref));
                            }
                            this.sw.writeLine('>>');
                            this.sw.writeLine('/ColorSpace 3 0 R');
                            this.sw.writeLine('>>');
                            let annotSw = new MemoryStream();
                            annotSw.writeLine('/Tx BMC');
                            annotSw.writeLine('q');
                            let borderOffset = 1;
                            annotSw.writeLine1('{0} {1} {2} {3} re W n', this.convertToString(borderOffset), this.convertToString(borderOffset), this.convertToString(seo.Width - borderOffset), this.convertToString(seo.Height - borderOffset));
                            annotSw.flush();
                            annotSw.write(seo.Content, 0, seo.Content.length);
                            annotSw.writeLine('Q');
                            annotSw.writeLine('EMC');
                            annotSw.flush();
                            this.storeMemoryStream2(annotSw, '/Filter [] /Length {0}');
                            this.sw.writeLine('');
                            annotSw.close();
                            this.sw.writeLine('endstream');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                            this.addXref(annot.aA[0].ref);
                            this.sw.writeLine1('{0} 0 obj', annot.aA[0].ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine1('/Next {0} 0 R', annot.aA[1].ref);
                            this.sw.writeLine('/S /Hide');
                            this.sw.writeLine1('/T ({0})', fieldName + 'Yes');
                            this.sw.writeLine('>>');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                            this.addXref(annot.aA[1].ref);
                            this.sw.writeLine1('{0} 0 obj', annot.aA[1].ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine('/H false');
                            this.sw.writeLine('/S /Hide');
                            this.sw.writeLine1('/T ({0})', fieldName + 'No');
                            this.sw.writeLine('>>');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                            annot = this.info.acroForm.checkBoxes[index].items[1];
                            this.addXref(annot.ref);
                            this.sw.writeLine1('{0} 0 obj', annot.ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine('/Type /Annot');
                            this.sw.writeLine('/Subtype /Widget');
                            this.sw.writeLine('/FT /Btn');
                            this.sw.writeLine1('/Rect [{0} {1} {2} {3}]', this.convertToString(seo.X), this.convertToString(seo.Y), this.convertToString(seo.X + seo.Width - checkboxSizeCorrection), this.convertToString(seo.Y + seo.Height - checkboxSizeCorrection));
                            this.sw.writeLine1('/F {0}', 4 + (this.info.acroForm.checkBoxes[index].items.length == 3 || checkBoxValue == true ? 2 : 0));
                            this.sw.writeLine1('/P {0} 0 R', this.info.pageList[seo.Page].ref);
                            this.storeStringLine('/T ', fieldName + 'No');
                            this.sw.writeLine('/MK << >>');
                            this.sw.writeLine('/Ff 65536');
                            this.sw.writeLine1('/A {0} 0 R', annot.aA[0].ref);
                            this.sw.writeLine1('/AP << /N {0} 0 R >>', annot.aP.ref);
                            this.sw.writeLine('/H /O');
                            this.sw.writeLine('>>');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                            this.addXref(annot.aP.ref);
                            this.sw.writeLine1('{0} 0 obj', annot.aP.ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine('/Type /XObject');
                            this.sw.writeLine('/Subtype /Form');
                            this.sw.writeLine('/FormType 1');
                            this.sw.writeLine1('/BBox [{0} {1} {2} {3}]', this.convertToString(0), this.convertToString(0), this.convertToString(seo.Width), this.convertToString(seo.Height));
                            this.sw.writeLine('/Matrix [ 1 0 0 1 0 0 ]');
                            this.sw.writeLine('/Resources <<');
                            this.sw.writeLine('/ProcSet [ /PDF ]');
                            this.sw.writeLine('/Pattern');
                            this.sw.writeLine('<<');
                            for (let indexPattern = 0; indexPattern < this.hatchArray.length; indexPattern++) {
                                this.sw.writeLine1(StiString.format('/PH{0} {1} 0 R', 1 + indexPattern, this.info.patterns.hatchItems[indexPattern].ref));
                            }
                            for (let indexPattern = 0; indexPattern < this.shadingArray.length; indexPattern++) {
                                this.sw.writeLine1(StiString.format('/P{0} {1} 0 R', 2 + indexPattern, this.info.patterns.shadingItems[indexPattern].ref));
                            }
                            this.sw.writeLine('>>');
                            this.sw.writeLine('/ColorSpace 3 0 R');
                            this.sw.writeLine('>>');
                            annotSw = new MemoryStream();
                            annotSw.writeLine('/Tx BMC');
                            annotSw.writeLine('q');
                            borderOffset = 1;
                            annotSw.writeLine1('{0} {1} {2} {3} re W n', this.convertToString(borderOffset), this.convertToString(borderOffset), this.convertToString(seo.Width - borderOffset), this.convertToString(seo.Height - borderOffset));
                            annotSw.flush();
                            annotSw.write(seo.Content2, 0, seo.Content2.length);
                            annotSw.writeLine('Q');
                            annotSw.writeLine('EMC');
                            annotSw.flush();
                            this.storeMemoryStream2(annotSw, '/Filter [] /Length {0}');
                            this.sw.writeLine('');
                            annotSw.close();
                            this.sw.writeLine('endstream');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                            this.addXref(annot.aA[0].ref);
                            this.sw.writeLine1('{0} 0 obj', annot.aA[0].ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine('/H false');
                            this.sw.writeLine1('/Next {0} 0 R', annot.aA[1].ref);
                            this.sw.writeLine('/S /Hide');
                            this.sw.writeLine1('/T ({0})', fieldName + 'Yes');
                            this.sw.writeLine('>>');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                            this.addXref(annot.aA[1].ref);
                            this.sw.writeLine1('{0} 0 obj', annot.aA[1].ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine('/S /Hide');
                            this.sw.writeLine1('/T ({0})', fieldName + 'No');
                            this.sw.writeLine('>>');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                        }
                        if (this.info.acroForm.checkBoxes[index].items.length == 3) {
                            let annot = this.info.acroForm.checkBoxes[index].items[2];
                            this.addXref(annot.ref);
                            this.sw.writeLine1('{0} 0 obj', annot.ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine('/Type /Annot');
                            this.sw.writeLine('/Subtype /Widget');
                            this.sw.writeLine('/FT /Btn');
                            this.sw.writeLine1('/Rect [{0} {1} {2} {3}]', this.convertToString(seo.X), this.convertToString(seo.Y), this.convertToString(seo.X + seo.Width - checkboxSizeCorrection), this.convertToString(seo.Y + seo.Height - checkboxSizeCorrection));
                            this.sw.writeLine('/F 4');
                            this.sw.writeLine1('/P {0} 0 R', this.info.pageList[seo.Page].ref);
                            this.storeStringLine('/T ', fieldName + 'None');
                            this.sw.writeLine('/MK << >>');
                            this.sw.writeLine('/Ff 65536');
                            this.sw.writeLine1('/A {0} 0 R', annot.aA[0].ref);
                            this.sw.writeLine('/H /O');
                            this.sw.writeLine('>>');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                            this.addXref(annot.aA[0].ref);
                            this.sw.writeLine1('{0} 0 obj', annot.aA[0].ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine1('/Next {0} 0 R', annot.aA[1].ref);
                            this.sw.writeLine('/S /Hide');
                            this.sw.writeLine1('/T ({0})', fieldName + 'None');
                            this.sw.writeLine('>>');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                            this.addXref(annot.aA[1].ref);
                            this.sw.writeLine1('{0} 0 obj', annot.aA[1].ref);
                            this.sw.writeLine('<<');
                            this.sw.writeLine('/H false');
                            this.sw.writeLine('/S /Hide');
                            this.sw.writeLine1('/T ({0})', fieldName + (checkbox.checkStyleForTrue == __.a.Components.StiCheckStyle.None ? 'No' : 'Yes'));
                            this.sw.writeLine('>>');
                            this.sw.writeLine('endobj');
                            this.sw.writeLine('');
                        }
                    }
                    for (let index = 0; index < this.unsignedSignaturesCounter; index++) {
                        let seo = this.unsignedSignaturesArray[index];
                        let fieldName = '';
                        if (Stimulsoft['StiOptions'].Export.Pdf.useEditableFieldName)
                            fieldName = seo.Component.name;
                        if (Stimulsoft['StiOptions'].Export.Pdf.useEditableFieldAlias)
                            fieldName = seo.Component.alias;
                        if (Stimulsoft['StiOptions'].Export.Pdf.useEditableFieldTag)
                            fieldName = seo.Component.tagValue;
                        if (StiString.isNullOrEmpty(fieldName))
                            fieldName = StiString.format('UnsignedSignature{0}', index);
                        if (fieldsNames.containsKey(fieldName)) {
                            let indexName = 2;
                            let nameAdd = '';
                            while (fieldsNames.containsKey(fieldName + nameAdd)) {
                                nameAdd = '_' + indexName.toString();
                                indexName++;
                            }
                            fieldName = fieldName + nameAdd;
                        }
                        fieldsNames.add(fieldName, fieldName);
                        let indexOffset3 = this.info.acroForm.unsignedSignatures[index].ref;
                        this.addXref(indexOffset3);
                        this.sw.writeLine1('{0} 0 obj', indexOffset3);
                        this.sw.writeLine('<<');
                        this.sw.writeLine('/Type /Annot');
                        this.sw.writeLine('/Subtype /Widget');
                        this.sw.writeLine1('/Rect [{0} {1} {2} {3}]', this.convertToString(seo.X), this.convertToString(seo.Y), this.convertToString(seo.X + seo.Width), this.convertToString(seo.Y + seo.Height));
                        this.sw.writeLine('/F 4');
                        this.sw.writeLine1('/P {0} 0 R', this.info.pageList[seo.Page].ref);
                        this.sw.writeLine('/FT /Sig');
                        this.storeStringLine('/T ', fieldName);
                        this.sw.writeLine('/MK << >>');
                        this.sw.writeLine('>>');
                        this.sw.writeLine('endobj');
                        this.sw.writeLine('');
                    }
                }
            }
        }
        renderTooltipTable() {
            if (this.haveTooltips) {
                for (let index = 0; index < this.tooltipsCounter; index++) {
                    let stl = this.tooltipsArray[index];
                    let needHyperlink = false;
                    let stlink = new StiLinkObject();
                    for (let indexLink = 0; indexLink < this.linksCounter; indexLink++) {
                        stlink = this.linksArray[indexLink];
                        if (stlink.X == stl.X && stlink.Y == stl.Y && stlink.Width == stl.Width && stlink.Height == stl.Height && stlink.Page - 1 == stl.Page) {
                            needHyperlink = true;
                            break;
                        }
                    }
                    this.addXref(this.info.acroForm.tooltips[index].ref);
                    this.sw.writeLine1('{0} 0 obj', this.info.acroForm.tooltips[index].ref);
                    this.sw.writeLine('<<');
                    this.sw.writeLine('/Type /Annot');
                    this.sw.writeLine('/Subtype /Widget');
                    this.sw.writeLine1('/Rect [{0} {1} {2} {3}]', this.convertToString(stl.X), this.convertToString(stl.Y), this.convertToString(stl.X + stl.Width), this.convertToString(stl.Y + stl.Height));
                    this.storeStringLine('/TU ', stl.Link, true);
                    this.sw.writeLine('/F 0');
                    this.sw.writeLine1('/P {0} 0 R', this.info.pageList[stl.Page].ref);
                    this.storeStringLine('/T ', StiString.format('Tooltip{0}', index));
                    this.sw.writeLine('/FT /Btn');
                    this.sw.writeLine('/Ff 65536');
                    this.sw.writeLine('/H /N');
                    this.sw.writeLine('/AP <<');
                    this.sw.writeLine('>>');
                    if (needHyperlink) {
                        if (stlink.Link.charAt(0) == '#') {
                            if (stlink.DestY > -1)
                                this.sw.writeLine1('/Dest [{0} 0 R /XYZ null {1} null]', this.info.pageList[stlink.DestPage].ref, this.convertToString(stlink.DestY));
                            else
                                this.sw.writeLine1('/Dest [{0} 0 R /XYZ null null null]', this.info.pageList[0].ref);
                        } else {
                            this.sw.writeLine('/A <<');
                            this.sw.writeLine('/Type /Action');
                            this.sw.writeLine('/S /URI');
                            this.storeStringLine('/URI ', __.b.StiExportUtils.stringToUrl(this.stringReplace(stlink.Link, '\\', '/')));
                            this.sw.writeLine('>>');
                        }
                    }
                    this.sw.writeLine('>>');
                    this.sw.writeLine('endobj');
                    this.sw.writeLine('');
                }
            }
        }
        renderEncodeRecord() {
            if (this.encrypted) {
                this.addXref(this.info.encode.ref);
                this.sw.writeLine1('{0} 0 obj', this.info.encode.ref);
                this.sw.writeLine('<<');
                this.pdfSecurity.renderEncodeRecord(this.sw);
                this.sw.writeLine('>>');
                this.sw.writeLine('endobj');
                this.sw.writeLine('');
            }
        }
        renderExtGStateRecord() {
            this.addXref(this.info.extGState.ref);
            this.sw.writeLine1('{0} 0 obj', this.info.extGState.ref);
            this.sw.writeLine('<<');
            for (let index = 0; index < 256; index++) {
                if (this.alphaTable[index]) {
                    let stNum = StiString.format('{0:X2}', index).toUpperCase();
                    this.sw.writeLine1('/GS{0}S <</Type /ExtGState /BM /Normal /CA {1}>>', stNum, this.colorTable[index]);
                    this.sw.writeLine1('/GS{0}N <</Type /ExtGState /BM /Normal /ca {1}>>', stNum, this.colorTable[index]);
                }
            }
            this.sw.writeLine('>>');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
        }
        storeImageData(image, imageResolution, isImageComponent, needSmoothing, maxQuality = false) {
            if (image != null)
                image.tryConvertSync(Stimulsoft.System.Drawing.Imaging.ImageFormat.Jpeg);
            let imageIndex = this.imageCache.addImageInt(image);
            let pd = new StiImageData();
            if (image != null && image.bytes != null) {
                pd.Width = image.width;
                pd.Height = image.height;
            } else {
                pd.Width = 1;
                pd.Height = 1;
            }
            pd.Name = StiString.format('Image{0}', imageIndex);
            pd.ImageFormat = this.imageFormat;
            this.imageList.push(pd);
            this.imageCacheIndexToList.set(imageIndex, pd);
            if (needSmoothing) {
                this.imageInterpolationTable.set(imageIndex, true);
            }
            return imageResolution;
        }
        storeImageDataForGeom(image) {
            let rsImageResolution = image.imageToDraw.horizontalResolution / 100;
            if (this.imageResolutionMode == __.b.StiImageResolutionMode.NoMoreThan) {
                if (image.stretch) {
                    rsImageResolution = image.imageToDraw.width / this.report.unit.convertToHInches(image.width);
                } else {
                    rsImageResolution = 1 / image.multipleFactor;
                }
            }
            rsImageResolution = this.storeImageData(image.imageToDraw, rsImageResolution, true, image.smoothing);
            this.imageInfoList.set(this.imageInfoCounter, rsImageResolution);
        }
        writeImageInfo(pp, imageResolution) {
            let pd = this.imageList[this.imagesCurrent];
            this.imagesCurrent++;
            let view = pp.Component.as(StiImage);
            if (this.imageResolutionMode != __.b.StiImageResolutionMode.Exactly && view != null && !view.margins.isEmpty) {
                let marginsLeft = this.hiToTwips * view.margins.left;
                let marginsRight = this.hiToTwips * view.margins.right;
                let marginsTop = this.hiToTwips * view.margins.top;
                let marginsBottom = this.hiToTwips * view.margins.bottom;
                if (marginsLeft != 0) {
                    pp.X += marginsLeft;
                    pp.Width -= marginsLeft;
                }
                if (marginsBottom != 0) {
                    pp.Y += marginsBottom;
                    pp.Height -= marginsBottom;
                }
                if (marginsRight != 0)
                    pp.Width -= marginsRight;
                if (marginsTop != 0)
                    pp.Height -= marginsTop;
            }
            let imageRotation = StiImageRotation.None;
            if (view != null) {
                imageRotation = view.imageRotation;
            }
            let pdWidth = pd.Width;
            let pdHeight = pd.Height;
            if (imageRotation == StiImageRotation.Rotate90CCW || imageRotation == StiImageRotation.Rotate90CW) {
                pdWidth = pd.Height;
                pdHeight = pd.Width;
            }
            let cx = pp.X;
            let cy = pp.Y;
            let cw = this.hiToTwips * (pdWidth - 1) / imageResolution;
            let ch = this.hiToTwips * (pdHeight - 1) / imageResolution;
            let needClip = false;
            if (this.imageResolutionMode != __.b.StiImageResolutionMode.Exactly && view != null && view.imageToDraw != null) {
                let imageForPaint = view.imageToDraw;
                let rect = view.getPaintRectangle(true, false);
                rect = view.convertImageMargins(rect, false);
                let destRect = new RectangleD(0, 0, rect.width, rect.height);
                if (!view.stretch) {
                    let imageWidth = pdWidth * view.multipleFactor;
                    let imageHeight = pdHeight * view.multipleFactor;
                    if (imageForPaint == null || imageForPaint.bytes == null) {
                        imageWidth = 1;
                        imageHeight = 1;
                    }
                    destRect.width = imageWidth;
                    destRect.height = imageHeight;
                    switch (view.horAlignment) {
                    case StiHorAlignment.Center:
                        destRect.x = (rect.width - imageWidth) / 2;
                        break;
                    case StiHorAlignment.Right:
                        destRect.x = rect.width - imageWidth;
                        break;
                    }
                    switch (view.vertAlignment) {
                    case StiVertAlignment.Center:
                        destRect.y = (rect.height - imageHeight) / 2;
                        break;
                    case StiVertAlignment.Top:
                        destRect.y = rect.height - imageHeight;
                        break;
                    }
                    cx += destRect.x * this.hiToTwips;
                    cy += destRect.y * this.hiToTwips;
                    cw = destRect.width * this.hiToTwips;
                    ch = destRect.height * this.hiToTwips;
                    needClip = true;
                } else {
                    let imageWidth = pdWidth;
                    let imageHeight = pdHeight;
                    if (imageForPaint == null) {
                        imageWidth = 1;
                        imageHeight = 1;
                    }
                    if (view.aspectRatio) {
                        let xRatio = destRect.width / imageWidth;
                        let yRatio = destRect.height / imageHeight;
                        if (xRatio > yRatio)
                            destRect.width = imageWidth * yRatio;
                        else
                            destRect.height = imageHeight * xRatio;
                        switch (view.vertAlignment) {
                        case StiVertAlignment.Center:
                            destRect.y = (rect.height - destRect.height) / 2;
                            break;
                        case StiVertAlignment.Top:
                            destRect.y = rect.height - destRect.height;
                            break;
                        }
                        switch (view.horAlignment) {
                        case StiHorAlignment.Center:
                            destRect.x = (rect.width - destRect.width) / 2;
                            break;
                        case StiHorAlignment.Right:
                            destRect.x = rect.width - destRect.width;
                            break;
                        }
                        cx += destRect.x * this.hiToTwips;
                        cy += destRect.y * this.hiToTwips;
                        cw = destRect.width * this.hiToTwips;
                        ch = destRect.height * this.hiToTwips;
                    } else {
                        cw = pp.Width;
                        ch = pp.Height;
                    }
                }
            }
            this.pageStream.writeLine('q');
            this.pushColorToStack();
            this.setNonStrokeColor(Color.black);
            if (needClip) {
                this.pageStream.writeLine1('{0} {1} {2} {3} re W n', this.convertToString(pp.X), this.convertToString(pp.Y), this.convertToString(pp.Width), this.convertToString(pp.Height));
            }
            if (imageRotation == StiImageRotation.None) {
                this.pageStream.writeLine1('{0} 0 0 {1} {2} {3} cm', this.convertToString(cw), this.convertToString(ch), this.convertToString(cx), this.convertToString(cy));
            } else {
                this.pageStream.writeLine1('1 0 0 1 {0} {1} cm', this.convertToString(cx + cw / 2), this.convertToString(cy + ch / 2));
                if (imageRotation == StiImageRotation.Rotate90CCW) {
                    this.pageStream.writeLine('0 1 -1 0 0 0 cm');
                }
                if (imageRotation == StiImageRotation.Rotate90CW) {
                    this.pageStream.writeLine('0 -1 1 0 0 0 cm');
                }
                if (imageRotation == StiImageRotation.Rotate180) {
                    this.pageStream.writeLine('-1 0 0 -1 0 0 cm');
                }
                if (imageRotation == StiImageRotation.FlipHorizontal) {
                    this.pageStream.writeLine('-1 0 0 1 0 0 cm');
                }
                if (imageRotation == StiImageRotation.FlipVertical) {
                    this.pageStream.writeLine('1 0 0 -1 0 0 cm');
                }
                if (imageRotation == StiImageRotation.Rotate90CCW || imageRotation == StiImageRotation.Rotate90CW) {
                    this.pageStream.writeLine1('{0} 0 0 {1} {2} {3} cm', this.convertToString(ch), this.convertToString(cw), this.convertToString(-ch / 2), this.convertToString(-cw / 2));
                } else {
                    this.pageStream.writeLine1('{0} 0 0 {1} {2} {3} cm', this.convertToString(cw), this.convertToString(ch), this.convertToString(-cw / 2), this.convertToString(-ch / 2));
                }
            }
            this.pageStream.writeLine1('/{0} Do', pd.Name);
            this.pageStream.writeLine('Q');
            this.popColorFromStack();
        }
        writeImageInfo2(pp, imageResolutionX, imageResolutionY) {
            let pd = this.imageList[this.imagesCurrent];
            this.imagesCurrent++;
            this.pageStream.writeLine('q');
            this.pushColorToStack();
            this.setNonStrokeColor(Color.black);
            this.pageStream.writeLine1('{0} 0 0 {1} {2} {3} cm', this.convertToString(this.hiToTwips * pd.Width / imageResolutionX), this.convertToString(this.hiToTwips * pd.Height / imageResolutionY), this.convertToString(pp.X), this.convertToString(pp.Y));
            this.pageStream.writeLine1('/{0} Do', pd.Name);
            this.pageStream.writeLine('Q');
            this.popColorFromStack();
        }
        renderImage(pp, imageResolution) {
            if (this.imageInfoList.containsKey(this.imageInfoCounter)) {
                let rsImageResolution = this.imageInfoList.get(this.imageInfoCounter);
                this.writeImageInfo(pp, rsImageResolution);
            } else {
                let exportImage = pp.Component.as(IStiExportImageExtended);
                if (exportImage != null && pp.Component.isExportAsImage(__.a.StiExportFormat.Pdf)) {
                    let rsImageResolution = imageResolution;
                    let REFrsImageResolution = { ref: rsImageResolution };
                    let image = exportImage.getImage(REFrsImageResolution, __.a.StiExportFormat.Pdf);
                    rsImageResolution = REFrsImageResolution.ref;
                    if (image != null && image.bytes != null) {
                        this.writeImageInfo(pp, rsImageResolution);
                    }
                }
            }
        }
        renderWatermark(page, behind, pageWidth, pageHeight, imageResolution) {
            let watermark = page.watermark;
            if (watermark != null && watermark.enabled) {
                if (watermark.image != null && watermark.showImageBehind == behind) {
                    let pd = this.imageList[this.imagesCurrent];
                    let imageWidth = pd.Width * this.hiToTwips * watermark.imageMultipleFactor;
                    let imageHeight = pd.Height * this.hiToTwips * watermark.imageMultipleFactor;
                    let imageX = 0;
                    let imageY = 0;
                    let dupX = 1;
                    let dupY = 1;
                    let align = watermark.imageAlignment;
                    let isImageTiling = watermark.imageTiling;
                    if (watermark.imageStretch) {
                        let aspectRatio = imageHeight / imageWidth;
                        imageWidth = pageWidth;
                        imageHeight = pageHeight;
                        isImageTiling = false;
                        if (watermark.aspectRatio) {
                            if (pageHeight / pageWidth > aspectRatio) {
                                imageHeight = imageWidth * aspectRatio;
                            } else {
                                imageWidth = imageHeight / aspectRatio;
                            }
                        }
                    }
                    if (watermark.imageStretch || watermark.imageMultipleFactor > 1) {
                        this.imageInterpolationTable.set(this.imageCache.imageIndex[this.imagesCurrent], true);
                    }
                    if (isImageTiling) {
                        align = Stimulsoft.System.Drawing.ContentAlignment.TopLeft;
                        dupX = StiMath.round2(pageWidth / imageWidth) + 1;
                        dupY = StiMath.round2(pageHeight / imageHeight) + 1;
                    }
                    switch (align) {
                    case Stimulsoft.System.Drawing.ContentAlignment.TopCenter:
                    case Stimulsoft.System.Drawing.ContentAlignment.MiddleCenter:
                    case Stimulsoft.System.Drawing.ContentAlignment.BottomCenter:
                        imageX = (pageWidth - imageWidth) / 2;
                        break;
                    case Stimulsoft.System.Drawing.ContentAlignment.TopRight:
                    case Stimulsoft.System.Drawing.ContentAlignment.MiddleRight:
                    case Stimulsoft.System.Drawing.ContentAlignment.BottomRight:
                        imageX = pageWidth - imageWidth;
                        break;
                    }
                    switch (align) {
                    case Stimulsoft.System.Drawing.ContentAlignment.TopLeft:
                    case Stimulsoft.System.Drawing.ContentAlignment.TopCenter:
                    case Stimulsoft.System.Drawing.ContentAlignment.TopRight:
                        imageY = pageHeight - imageHeight;
                        break;
                    case Stimulsoft.System.Drawing.ContentAlignment.MiddleLeft:
                    case Stimulsoft.System.Drawing.ContentAlignment.MiddleCenter:
                    case Stimulsoft.System.Drawing.ContentAlignment.MiddleRight:
                        imageY = (pageHeight - imageHeight) / 2;
                        break;
                    }
                    this.setNonStrokeColor(Color.fromArgb(255 - watermark.imageTransparency, Color.black));
                    for (let indexY = 0; indexY < dupY; indexY++) {
                        for (let indexX = 0; indexX < dupX; indexX++) {
                            this.pageStream.writeLine('q');
                            this.pushColorToStack();
                            this.pageStream.writeLine1('{0} 0 0 {1} {2} {3} cm', this.convertToString(imageWidth), this.convertToString(imageHeight), this.convertToString(imageX + imageWidth * indexX), this.convertToString(imageY - imageHeight * indexY));
                            this.pageStream.writeLine1('/{0} Do', pd.Name);
                            this.pageStream.writeLine('Q');
                            this.popColorFromStack();
                        }
                    }
                    this.imagesCurrent++;
                }
                if (!StiString.isNullOrEmpty(watermark.text) && watermark.showBehind == behind) {
                    let pp = new StiPdfData(this);
                    pp.X = 0;
                    pp.Y = 0;
                    pp.Width = pageWidth;
                    pp.Height = pageHeight;
                    let stt = new StiText(new RectangleD(pp.X, pp.Y, pp.Width, pp.Height));
                    stt.text = watermark.text;
                    stt.textBrush = watermark.textBrush;
                    stt.font = watermark.font;
                    stt.textOptions = new Stimulsoft.Base.Drawing.StiTextOptions();
                    stt.textOptions.angle = watermark.angle;
                    stt.horAlignment = Stimulsoft.Base.Drawing.StiTextHorAlignment.Center;
                    stt.vertAlignment = StiVertAlignment.Center;
                    stt.page = page;
                    stt.textQuality = __.a.Components.StiTextQuality.Standard;
                    pp.Component = stt;
                    __.b.StiPdfRenderText.renderTextFont(pp);
                    __.b.StiPdfRenderText.renderText(pp);
                }
            }
        }
        storeShadingData1(brush, pageNumber) {
            if (brush != null) {
                if (brush.is(StiGradientBrush)) {
                    let gbr = brush;
                    let ssd = new StiShadingData();
                    ssd.Angle = gbr.angle;
                    ssd.Page = pageNumber;
                    ssd.FunctionIndex = this.getShadingFunctionNumber(gbr.startColor, gbr.endColor, false);
                    this.shadingArray.push(ssd);
                }
                if (brush.is(StiGlareBrush)) {
                    let gbr = brush;
                    let ssd = new StiShadingData();
                    ssd.Angle = gbr.angle;
                    ssd.FunctionIndex = this.getShadingFunctionNumber(gbr.startColor, gbr.endColor, true);
                    ssd.Page = pageNumber;
                    this.shadingArray.push(ssd);
                }
            }
        }
        storeShadingData2(x, y, width, height, brush) {
            if (brush != null && (brush.is(StiGradientBrush) || brush.is(StiGlareBrush))) {
                let ssd = this.shadingArray[this.shadingCurrent];
                ssd.X = x;
                ssd.Y = y;
                ssd.Width = width;
                ssd.Height = height;
                this.shadingArray[this.shadingCurrent] = ssd;
                this.shadingCurrent++;
            }
            return this.shadingCurrent;
        }
        storeHatchData(brush) {
            if (brush != null) {
                if (brush.is(StiHatchBrush)) {
                    this.getHatchNumber(brush);
                }
                if (brush.is(StiGlassBrush)) {
                    let glass = brush.as(StiGlassBrush);
                    if (glass.drawHatch) {
                    }
                }
            }
        }
        renderMetadata(report) {
            let mainStream = new MemoryStream();
            let stXpacket = '<?xpacket begin="ï»¿" id="W5M0MpCehiHzreSzNTczkc9d"?>\r\n';
            mainStream.writeString(stXpacket);
            let ms = new MemoryStream();
            let writer = new XmlTextWriter(Stimulsoft.System.Text.Encoding.UTF8, ms);
            writer.formatting = Stimulsoft.System.Xml.Formatting.Indented;
            writer.writeStartElement('x:xmpmeta');
            writer.writeAttributeString('xmlns:x', 'adobe:ns:meta/');
            writer.writeAttributeString('x:xmptk', 'Adobe XMP Core 4.0-c316 44.253921, Sun Oct 01 2006 17:14:39');
            writer.writeStartElement('rdf:RDF');
            writer.writeAttributeString('xmlns:rdf', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');
            writer.writeStartElement('rdf:Description');
            writer.writeAttributeString('rdf:about', '');
            writer.writeAttributeString('xmlns:xap', 'http://ns.adobe.com/xap/1.0/');
            writer.writeElementString('xap:ModifyDate', this.currentDateTimeMeta);
            writer.writeElementString('xap:CreateDate', this.currentDateTimeMeta);
            writer.writeElementString('xap:MetadataDate', this.currentDateTimeMeta);
            writer.writeElementString('xap:CreatorTool', Stimulsoft['StiOptions'].Export.Pdf.creatorString);
            writer.writeFullEndElement();
            writer.writeStartElement('rdf:Description');
            writer.writeAttributeString('rdf:about', '');
            writer.writeAttributeString('xmlns:dc', 'http://purl.org/dc/elements/1.1/');
            writer.writeElementString('dc:format', 'application/pdf');
            writer.writeStartElement('dc:title');
            writer.writeStartElement('rdf:Alt');
            if (!StiString.isNullOrEmpty(report.reportName)) {
                writer.writeStartElement('rdf:li');
                writer.writeAttributeString('xml:lang', 'x-default');
                writer.writeString(report.reportName);
                writer.writeFullEndElement();
            }
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('dc:description');
            writer.writeStartElement('rdf:Alt');
            if (!StiString.isNullOrEmpty(report.reportAlias)) {
                writer.writeStartElement('rdf:li');
                writer.writeAttributeString('xml:lang', 'x-default');
                writer.writeString(report.reportAlias);
                writer.writeFullEndElement();
            }
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('dc:creator');
            writer.writeStartElement('rdf:Seq');
            if (!StiString.isNullOrEmpty(report.reportAuthor)) {
                writer.writeStartElement('rdf:li');
                writer.writeAttributeString('xml:lang', 'x-default');
                writer.writeString(report.reportAuthor);
                writer.writeFullEndElement();
            }
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('dc:subject');
            writer.writeStartElement('rdf:Bag');
            if (!StiString.isNullOrEmpty(this.keywords)) {
                let words = this.keywords.split(';');
                for (let word of words) {
                    writer.writeStartElement('rdf:li');
                    writer.writeString(word.trim());
                    writer.writeFullEndElement();
                }
            }
            writer.writeEndElement();
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeStartElement('rdf:Description');
            writer.writeAttributeString('rdf:about', '');
            writer.writeAttributeString('xmlns:xapMM', 'http://ns.adobe.com/xap/1.0/mm/');
            writer.writeElementString('xapMM:DocumentID', this.IDValueStringMeta);
            writer.writeElementString('xapMM:InstanceID', this.IDValueStringMeta);
            writer.writeFullEndElement();
            writer.writeStartElement('rdf:Description');
            writer.writeAttributeString('rdf:about', '');
            writer.writeAttributeString('xmlns:pdf', 'http://ns.adobe.com/pdf/1.3/');
            writer.writeAttributeString('xmlns:pdfx', 'http://ns.adobe.com/pdf/1.3/');
            writer.writeElementString('pdf:Producer', this.producerName);
            writer.writeElementString('pdf:Keywords', this.keywords);
            for (let meta of report.metaTags.list) {
                if (meta.name.stimulsoft().startsWith('pdf:')) {
                    writer.writeElementString('pdfx:' + meta.name.substr(4), meta.tag);
                }
            }
            writer.writeFullEndElement();
            if (this.zugferdComplianceMode != __.b.StiPdfZUGFeRDComplianceMode.None) {
                writer.writeStartElement('rdf:Description');
                writer.writeAttributeString('xmlns:pdfaExtension', 'http://www.aiim.org/pdfa/ns/extension/');
                writer.writeAttributeString('xmlns:pdfaField', 'http://www.aiim.org/pdfa/ns/field#');
                writer.writeAttributeString('xmlns:pdfaProperty', 'http://www.aiim.org/pdfa/ns/property#');
                writer.writeAttributeString('xmlns:pdfaSchema', 'http://www.aiim.org/pdfa/ns/schema#');
                writer.writeAttributeString('xmlns:pdfaType', 'http://www.aiim.org/pdfa/ns/type#');
                writer.writeAttributeString('rdf:about', '');
                writer.writeStartElement('pdfaExtension:schemas');
                writer.writeStartElement('rdf:Bag');
                writer.writeStartElement('rdf:li');
                writer.writeAttributeString('rdf:parseType', 'Resource');
                if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V1) {
                    writer.writeElementString('pdfaSchema:schema', 'ZUGFeRD PDFA Extension Schema');
                    writer.writeElementString('pdfaSchema:namespaceURI', 'urn:ferd:pdfa:CrossIndustryDocument:invoice:1p0#');
                    writer.writeElementString('pdfaSchema:prefix', 'zf');
                }
                if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V2) {
                    writer.writeElementString('pdfaSchema:schema', 'ZUGFeRD PDFA Extension Schema');
                    writer.writeElementString('pdfaSchema:namespaceURI', 'urn:zugferd:pdfa:CrossIndustryDocument:invoice:2p0#');
                    writer.writeElementString('pdfaSchema:prefix', 'zf');
                }
                if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V2_1) {
                    writer.writeElementString('pdfaSchema:schema', 'Factur-X/ZUGFeRD PDF/A Extension Schema');
                    writer.writeElementString('pdfaSchema:namespaceURI', 'urn:factur-x:pdfa:CrossIndustryDocument:invoice:1p0#');
                    writer.writeElementString('pdfaSchema:prefix', 'fx');
                }
                writer.writeStartElement('pdfaSchema:property');
                writer.writeStartElement('rdf:Seq');
                writer.writeStartElement('rdf:li');
                writer.writeAttributeString('rdf:parseType', 'Resource');
                writer.writeElementString('pdfaProperty:name', 'DocumentFileName');
                writer.writeElementString('pdfaProperty:valueType', 'Text');
                writer.writeElementString('pdfaProperty:category', 'external');
                writer.writeElementString('pdfaProperty:description', 'Name of the embedded XML invoice file');
                writer.writeFullEndElement();
                writer.writeStartElement('rdf:li');
                writer.writeAttributeString('rdf:parseType', 'Resource');
                writer.writeElementString('pdfaProperty:name', 'DocumentType');
                writer.writeElementString('pdfaProperty:valueType', 'Text');
                writer.writeElementString('pdfaProperty:category', 'external');
                writer.writeElementString('pdfaProperty:description', 'INVOICE');
                writer.writeFullEndElement();
                writer.writeStartElement('rdf:li');
                writer.writeAttributeString('rdf:parseType', 'Resource');
                writer.writeElementString('pdfaProperty:name', 'Version');
                writer.writeElementString('pdfaProperty:valueType', 'Text');
                writer.writeElementString('pdfaProperty:category', 'external');
                if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V2_1)
                    writer.writeElementString('pdfaProperty:description', 'Version of the Factur-X/ZUGFeRD XML schema');
                else
                    writer.writeElementString('pdfaProperty:description', 'The actual version of the ZUGFeRD data');
                writer.writeFullEndElement();
                writer.writeStartElement('rdf:li');
                writer.writeAttributeString('rdf:parseType', 'Resource');
                writer.writeElementString('pdfaProperty:name', 'ConformanceLevel');
                writer.writeElementString('pdfaProperty:valueType', 'Text');
                writer.writeElementString('pdfaProperty:category', 'external');
                if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V2_1)
                    writer.writeElementString('pdfaProperty:description', 'Conformance level of the embedded Factur-X/ZUGFeRD XML invoice data');
                else
                    writer.writeElementString('pdfaProperty:description', 'The conformance level of the ZUGFeRD data');
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeFullEndElement();
                writer.writeStartElement('rdf:Description');
                if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V1) {
                    writer.writeAttributeString('xmlns:zf', 'urn:ferd:pdfa:CrossIndustryDocument:invoice:1p0#');
                    writer.writeAttributeString('zf:DocumentFileName', 'ZUGFeRD-invoice.xml');
                    writer.writeAttributeString('zf:ConformanceLevel', this.zugferdConformanceLevel);
                    writer.writeAttributeString('zf:DocumentType', 'INVOICE');
                    writer.writeAttributeString('zf:Version', '1.0');
                }
                if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V2) {
                    writer.writeAttributeString('xmlns:zf', 'urn:zugferd:pdfa:CrossIndustryDocument:invoice:2p0#');
                    writer.writeAttributeString('zf:DocumentFileName', 'zugferd-invoice.xml');
                    writer.writeAttributeString('zf:ConformanceLevel', this.zugferdConformanceLevel);
                    writer.writeAttributeString('zf:DocumentType', 'INVOICE');
                    writer.writeAttributeString('zf:Version', '1.0');
                }
                if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V2_1) {
                    writer.writeAttributeString('xmlns:fx', 'urn:factur-x:pdfa:CrossIndustryDocument:invoice:1p0#');
                    writer.writeAttributeString('fx:DocumentFileName', 'factur-x.xml');
                    writer.writeAttributeString('fx:ConformanceLevel', this.zugferdConformanceLevel);
                    writer.writeAttributeString('fx:DocumentType', 'INVOICE');
                    writer.writeAttributeString('fx:Version', '1.0');
                }
                writer.writeAttributeString('rdf:about', '');
                writer.writeFullEndElement();
            }
            if (this.usePdfA) {
                writer.writeStartElement('rdf:Description');
                writer.writeAttributeString('rdf:about', '');
                writer.writeAttributeString('xmlns:pdfaid', 'http://www.aiim.org/pdfa/ns/id/');
                let pdfaidPart = '1';
                switch (this.pdfComplianceMode) {
                case __.b.StiPdfComplianceMode.A1:
                    pdfaidPart = '1';
                    break;
                case __.b.StiPdfComplianceMode.A2:
                    pdfaidPart = '2';
                    break;
                case __.b.StiPdfComplianceMode.A3:
                    pdfaidPart = '3';
                    break;
                }
                let pdfaidConformance = 'A';
                switch (this.zugferdComplianceMode) {
                case __.b.StiPdfZUGFeRDComplianceMode.V1:
                    pdfaidConformance = 'A';
                    break;
                case __.b.StiPdfZUGFeRDComplianceMode.V2:
                    pdfaidConformance = 'B';
                    break;
                case __.b.StiPdfZUGFeRDComplianceMode.V2_1:
                    pdfaidConformance = 'B';
                    break;
                }
                writer.writeElementString('pdfaid:part', pdfaidPart);
                writer.writeElementString('pdfaid:conformance', pdfaidConformance);
                writer.writeFullEndElement();
            }
            writer.writeFullEndElement();
            writer.writeFullEndElement();
            writer.writeString('                              \r\n');
            writer.writeString('                              \r\n');
            writer.writeString('                              \r\n');
            writer.writeString('                              \r\n');
            writer.writeString('                              \r\n');
            let tempBuffer = ms.toArray();
            writer.close();
            ms.close();
            mainStream.write(tempBuffer, 0, tempBuffer.length);
            mainStream.writeString('<?xpacket end="w"?>');
            this.addXref(this.info.metadata.ref);
            this.sw.writeLine1('{0} 0 obj', this.info.metadata.ref);
            this.sw.writeLine('<<');
            this.sw.writeLine('/Type /Metadata');
            this.sw.writeLine('/Subtype /XML');
            this.storeMemoryStream2(mainStream, '/Length {0}');
            this.sw.writeLine('');
            this.sw.writeLine('endstream');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
        }
        renderColorSpace() {
            this.addXref(this.info.destOutputProfile.ref);
            this.sw.writeLine1('{0} 0 obj', this.info.destOutputProfile.ref);
            this.sw.writeLine('<<');
            this.sw.writeLine('/N 3');
            let tmpStream = null;
            let stColorSpace = null;
            if (this.compressed == true) {
                tmpStream = __.b.StiExportUtils.makePdfDeflateStream(__.b.StiPdfResources.sRGBprofile);
                stColorSpace = '/Length {0} /Filter [/FlateDecode] /Length1 ' + __.b.StiPdfResources.sRGBprofile.length.toString();
                this.storeMemoryStream2(tmpStream, stColorSpace);
            } else {
                tmpStream = new MemoryStream();
                tmpStream.write(__.b.StiPdfResources.sRGBprofile, 0, __.b.StiPdfResources.sRGBprofile.length);
                stColorSpace = '/Length {0}';
                this.storeMemoryStream2(tmpStream, stColorSpace);
            }
            this.sw.writeLine('');
            this.sw.writeLine('endstream');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
            this.addXref(this.info.outputIntents.ref);
            this.sw.writeLine1('{0} 0 obj', this.info.outputIntents.ref);
            this.sw.writeLine('[<<');
            this.storeStringLine('/Info', 'sRGB IEC61966-2.1');
            this.storeStringLine('/OutputConditionIdentifier', 'Custom');
            this.storeStringLine('/OutputCondition', '');
            this.storeStringLine('/RegistryName', '');
            this.sw.writeLine('/S /GTS_PDFA1');
            this.sw.writeLine1('/DestOutputProfile {0} 0 R', this.info.destOutputProfile.ref);
            this.sw.writeLine('/Type /OutputIntent');
            this.sw.writeLine('>>]');
            this.sw.writeLine('endobj');
            this.sw.writeLine('');
        }
        renderAutoPrint() {
            if (this.autoPrint != __.b.StiPdfAutoPrintMode.None) {
                this.addXref(this.info.embeddedJS.ref);
                this.sw.writeLine1('{0} 0 obj', this.info.embeddedJS.ref);
                this.sw.writeLine('<<');
                this.sw.writeLine1('/Names [(EmbeddedJS) {0} 0 R]', this.info.embeddedJS.content.ref);
                this.sw.writeLine('>>');
                this.sw.writeLine('endobj');
                this.sw.writeLine('');
                this.addXref(this.info.embeddedJS.content.ref);
                this.sw.writeLine1('{0} 0 obj', this.info.embeddedJS.content.ref);
                this.sw.writeLine('<<');
                this.sw.writeLine('/S /JavaScript');
                this.sw.writeLine1('/JS (print\\({0}\\);)', this.autoPrint == __.b.StiPdfAutoPrintMode.Dialog ? 'true' : 'false');
                this.sw.writeLine('>>');
                this.sw.writeLine('endobj');
                this.sw.writeLine('');
            }
        }
        renderEmbeddedFiles() {
            for (let index = 0; index < this.info.embeddedFilesList.length; index++) {
                let file = this.embeddedFiles[index];
                this.addXref(this.info.embeddedFilesList[index].ref);
                this.sw.writeLine1('{0} 0 obj', this.info.embeddedFilesList[index].ref);
                this.sw.writeLine('<<');
                this.storeStringLine('/F', file.name, true);
                this.sw.writeLine('/Type /Filespec');
                this.sw.writeLine('/EF <<');
                this.sw.writeLine1('/F {0} 0 R', this.info.embeddedFilesList[index].content.ref);
                this.sw.writeLine('>>');
                if (this.zugferdComplianceMode != __.b.StiPdfZUGFeRDComplianceMode.None || this.pdfComplianceMode == __.b.StiPdfComplianceMode.A3) {
                    this.sw.writeLine('/AFRelationship /Alternative');
                }
                this.storeStringLine('/UF', file.name, true);
                this.storeStringLine('/Desc', file.description, true);
                this.sw.writeLine('>>');
                this.sw.writeLine('endobj');
                this.sw.writeLine('');
                this.addXref(this.info.embeddedFilesList[index].content.ref);
                this.sw.writeLine1('{0} 0 obj', this.info.embeddedFilesList[index].content.ref);
                this.sw.writeLine('<<');
                this.sw.writeLine1('/Subtype /{0}', file.MIMEType.stimulsoft().replaceAll('/', '#2F'));
                this.sw.writeLine('/Type /EmbeddedFile');
                this.sw.writeLine('/Params <<');
                this.storeStringLine('/ModDate ', 'D:' + this.currentDateTime);
                this.sw.writeLine1('/Size {0}', file.data.length);
                this.sw.writeLine('>>');
                if (this.compressed) {
                    let TmpStream = __.b.StiExportUtils.makePdfDeflateStream(file.data);
                    this.storeMemoryStream2(TmpStream, '/Filter [/FlateDecode] /Length {0}');
                } else {
                    if (file.data instanceof Uint8Array) {
                        this.storeMemoryStream3(file.data, '/Length {0}');
                    } else {
                        if (file.data instanceof Array) {
                            this.storeMemoryStream4(file.data, '/Length {0}');
                        } else {
                            let data = Stimulsoft.System.Text.Encoding.UTF8.getBytes(file.data);
                            this.storeMemoryStream4(data, '/Length {0}');
                        }
                    }
                }
                this.sw.writeLine('');
                this.sw.writeLine('endstream');
                this.sw.writeLine('endobj');
                this.sw.writeLine('');
            }
        }
        addBookmarkNode(bkm, parentNode) {
            let tn = new StiPdfBookmarkTreeNode();
            tn.Parent = -1;
            tn.First = -1;
            tn.Last = -1;
            tn.Prev = -1;
            tn.Next = -1;
            tn.Count = -1;
            tn.Page = -1;
            tn.Y = -1;
            tn.Title = '';
            tn.Guid = '';
            tn.Used = parentNode == -1 ? true : false;
            this.bookmarksTree.push(tn);
            let currentNode = this.bookmarksTree.stimulsoft().countItems - 1;
            tn.Parent = parentNode;
            tn.Title = bkm.text;
            tn.Guid = bkm.componentGuid;
            if (bkm.bookmarks.count == 0) {
                tn.Count = 0;
            } else {
                let prevNode = -1;
                for (let tempCount = 0; tempCount <= bkm.bookmarks.count - 1; tempCount++) {
                    let memNode = this.bookmarksTree.stimulsoft().countItems;
                    let sbm = bkm.bookmarks.list[tempCount];
                    this.addBookmarkNode(sbm, currentNode);
                    let tempBM = this.bookmarksTree[memNode];
                    if (tempCount < bkm.bookmarks.count - 1) {
                        tempBM.Next = this.bookmarksTree.stimulsoft().countItems;
                    }
                    if (tempCount > 0) {
                        tempBM.Prev = prevNode;
                    }
                    this.bookmarksTree[memNode] = tempBM;
                    prevNode = memNode;
                }
                tn.First = currentNode + 1;
                tn.Last = this.bookmarksTree.stimulsoft().countItems - 1;
                tn.Count = this.bookmarksTree.stimulsoft().countItems - currentNode - 1;
            }
            this.bookmarksTree[currentNode] = tn;
        }
        makeBookmarkFromTree(bookmark, treeNode) {
            bookmark.text = treeNode.Title;
            bookmark.bookmarks = new StiBookmarksCollection();
            if (treeNode.Count > 0) {
                let nodePos = treeNode.First;
                while (nodePos != -1) {
                    let tnChild = this.bookmarksTree[nodePos];
                    if (tnChild.Used) {
                        let childBookmark = new StiBookmark();
                        bookmark.bookmarks.add(childBookmark);
                        this.makeBookmarkFromTree(childBookmark, tnChild);
                    }
                    nodePos = tnChild.Next;
                }
            }
        }
        exportPdf(report, stream, settings) {
            try {
                this.exportPdf1(report, stream, settings);
            } finally {
            }
        }
        exportPdf1(report, stream, settings) {
            if (settings == null)
                throw new Error("The 'settings' argument cannot be equal in null.");
            this.report = report;
            let pageRange = settings.pageRange;
            let imageResolution = settings.imageResolution;
            this.imageResolutionMode = settings.imageResolutionMode;
            this.imageQuality = settings.imageQuality;
            this.embeddedFonts = settings.embeddedFonts;
            this.standardPdfFonts = !!settings.standardPdfFonts;
            this.compressed = !!settings.compressed;
            this.useUnicodeMode = settings.useUnicode;
            let passwordInputUser = settings.passwordInputUser;
            let passwordInputOwner = settings.passwordInputOwner;
            let userAccessPrivileges = settings.userAccessPrivileges;
            this.keyLength = settings.keyLength;
            this.pdfComplianceMode = settings.pdfComplianceMode;
            this.autoPrint = settings.autoPrintMode;
            this.allowEditable = settings.allowEditable;
            this.embeddedFiles = settings.embeddedFiles;
            this.zugferdComplianceMode = settings.ZUGFeRDComplianceMode;
            this.zugferdConformanceLevel = settings.ZUGFeRDConformanceLevel;
            let zugferdInvoiceData = settings.ZUGFeRDInvoiceData;
            this.creatorName = Stimulsoft['StiOptions'].Export.Pdf.creatorString;
            this.keywords = Stimulsoft['StiOptions'].Export.Pdf.keywordsString;
            if (!StiString.isNullOrEmpty(settings.creatorString)) {
                this.creatorName = settings.creatorString;
            }
            if (!StiString.isNullOrEmpty(settings.keywordsString)) {
                this.keywords = settings.keywordsString;
            }
            if (StiString.isNullOrEmpty(this.creatorName)) {
                this.creatorName = this.producerName;
            }
            if (this.embeddedFiles == null)
                this.embeddedFiles = new List();
            if (report.dictionary.resources != null) {
                for (let resource of report.dictionary.resources.list) {
                    if (resource.availableInTheViewer) {
                        let description = resource.alias != resource.name ? resource.alias : '';
                        let embeddedFile = new StiPdfEmbeddedFileData(resource.name + resource.getFileExt(), description, resource.content, resource.getContentType());
                        this.embeddedFiles.add(embeddedFile);
                    }
                }
            }
            if (this.zugferdComplianceMode != __.b.StiPdfZUGFeRDComplianceMode.None) {
                this.pdfComplianceMode = __.b.StiPdfComplianceMode.A3;
                if (zugferdInvoiceData != null) {
                    let founded = false;
                    for (let file of this.embeddedFiles) {
                        let fileName = file.name.toLowerCase();
                        if (fileName == 'zugferd-invoice.xml' || fileName == 'factur-x.xml')
                            founded = true;
                    }
                    if (!founded) {
                        if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V1) {
                            this.embeddedFiles.add(new StiPdfEmbeddedFileData('ZUGFeRD-invoice.xml', 'ZUGFeRD Rechnung', zugferdInvoiceData));
                        }
                        if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V2) {
                            this.embeddedFiles.add(new StiPdfEmbeddedFileData('zugferd-invoice.xml', 'ZUGFeRD Rechnung', zugferdInvoiceData));
                        }
                        if (this.zugferdComplianceMode == __.b.StiPdfZUGFeRDComplianceMode.V2_1) {
                            this.embeddedFiles.add(new StiPdfEmbeddedFileData('factur-x.xml', 'Factur-X/ZUGFeRD', zugferdInvoiceData));
                        }
                    }
                }
            }
            if (this.embeddedFiles.countItems > 1) {
                this.embeddedFiles = this.embeddedFiles.orderBy(ef => ef.name).toList();
            }
            this.usePdfA = this.pdfComplianceMode != __.b.StiPdfComplianceMode.None;
            this.useTransparency = this.pdfComplianceMode != __.b.StiPdfComplianceMode.A1;
            if (!this.embeddedFonts)
                this.useUnicodeMode = false;
            this.compressedFonts = true;
            if (this.usePdfA) {
                this.standardPdfFonts = false;
                this.embeddedFonts = true;
                this.useUnicodeMode = true;
            }
            let deleteEmptyBookmarks = pageRange.rangeType != __.a.StiRangeType.All;
            let useImageTransparency = !this.usePdfA;
            if (this.embeddedFonts)
                this.standardPdfFonts = false;
            if (this.imageQuality < 0)
                this.imageQuality = 0;
            if (this.imageQuality > 1)
                this.imageQuality = 1;
            if (this.useUnicodeMode)
                this.standardPdfFonts = false;
            if (imageResolution < 10)
                imageResolution = 10;
            imageResolution = imageResolution / 100;
            this.imageResolutionMain = imageResolution;
            this.bidi = new __.b.StiBidirectionalConvert(true);
            this.pdfFont = new __.b.PdfFonts();
            this.pdfFont.standardPdfFonts = this.standardPdfFonts;
            this.pdfFont.forceUseUnicode = this.useUnicodeMode;
            this.fontGlyphsReduceNotNeed = null;
            for (let indexColor = 0; indexColor <= 255; indexColor++) {
                let doubleColor = StiMath.round2(indexColor / 255, 3);
                let stringColor = doubleColor.toString().split(',').join(Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                this.colorTable[indexColor] = stringColor;
                this.alphaTable[indexColor] = false;
            }
            this.lastColorStrokeA = 255;
            this.lastColorNonStrokeA = 255;
            this.colorStack = new Array();
            this.imageList = new Array();
            switch (this.imageCompressionMethod) {
            case __.b.StiPdfImageCompressionMethod.Flate:
                this.imageCache = new __.a.StiImageCache(true, true, __.a.ImageFormat.MemoryBmp, this.imageQuality, useImageTransparency);
                break;
            default:
                this.imageCache = new __.a.StiImageCache(true, true, __.a.ImageFormat.Jpeg, this.imageQuality, useImageTransparency);
                break;
            }
            this.imageInterpolationTable = new Hashtable();
            this.imageCacheIndexToList = new Hashtable();
            this.imageInfoList = new Hashtable();
            this.imageInfoCounter = 0;
            this.pdfFont.fontList = new Array();
            this.xref = new Array();
            this.bookmarksTree = new Array();
            this.haveBookmarks = false;
            this.linksArray = new Array();
            this.annotsArray = new Array();
            this.annots2Array = new Array();
            this.unsignedSignaturesArray = new Array();
            this.shadingArray = new Array();
            this.shadingFunctionArray = new Array();
            this.hatchArray = new Array();
            this.tooltipsArray = new Array();
            this.sw = stream;
            this.fontsCounter = 0;
            this.bookmarksCounter = 0;
            this.linksCounter = 0;
            this.annotsCounter = 0;
            this.annots2Counter = 0;
            this.tooltipsCounter = 0;
            for (let index = 0; index < 256; index++) {
                this.CodePage1252[index] = index;
            }
            for (let index = 0; index < 32; index++) {
                this.CodePage1252[128 + index] = this.CodePage1252part80AF[index];
            }
            this.fontGlyphsReduceNotNeed = StiArray.create(Boolean, 256);
            let dt = DateTime.now;
            let tempDT = dt.toString('yyyyMMddHHmmsszzz');
            this.currentDateTime = tempDT.substr(0, 17) + "'" + tempDT.substr(18, 2) + "'";
            this.currentDateTimeMeta = dt.toString('yyyy-MM-ddTHH:mm:sszzz');
            let IDString = dt.toString('yyyyMMddHHmmssffff');
            IDString += this.producerName;
            IDString += this.creatorName;
            IDString += report.reportAuthor;
            IDString += report.reportAlias;
            IDString += report.reportName;
            let forHash = '';
            for (let index = 0; index < IDString.length; index++) {
                forHash += String.fromCharCode(IDString.charCodeAt(index) & 255);
            }
            this.IDValue = Stimulsoft.Base.StiMD5Helper.MD5(forHash, false);
            let tempSB = '';
            for (let index = 0; index < this.IDValue.length; index++) {
                tempSB += __.b.StiExportUtils.toHex(this.IDValue[index]);
            }
            this.IDValueString = tempSB;
            this.IDValueStringMeta = StiString.format('uuid:{0}-{1}-{2}-{3}-{4}', this.IDValueString.substring(0, 8), this.IDValueString.substring(8, 4), this.IDValueString.substring(12, 4), this.IDValueString.substring(16, 4), this.IDValueString.substring(20, 12)).toLowerCase();
            this.pdfSecurity = new __.b.StiPdfSecurity(this);
            if (!this.usePdfA) {
                this.encrypted = this.pdfSecurity.computingCryptoValues(userAccessPrivileges, passwordInputOwner, passwordInputUser, this.keyLength, this.IDValue);
            }
            if (this.encrypted && this.useUnicodeMode) {
                this.embeddedFonts = true;
            }
            this.currentPassNumber = 0;
            this.maximumPassNumber = Stimulsoft['StiOptions'].Export.Pdf.divideSegmentPages ? 3 : 2;
            let pages = pageRange.getSelectedPages(report.renderedPages);
            if (Stimulsoft['StiOptions'].Export.Pdf.divideSegmentPages) {
                pages = __.b.StiSegmentPagesDivider.divide(pages, this);
                this.currentPassNumber++;
            }
            if (report.bookmark != null && report.bookmark.bookmarks.count != 0) {
                this.addBookmarkNode(report.bookmark, -1);
                this.haveBookmarks = true;
                this.bookmarksCounter = this.bookmarksTree.stimulsoft().countItems;
            }
            let tempPageNumber = 0;
            for (let page of pages.list) {
                pages.getPage(page);
                this.storeShadingData1(page.brush, tempPageNumber);
                this.storeHatchData(page.brush);
                if (page.hyperlinkValue != null && page.hyperlinkValue.toString().trim().length > 0 && !page.hyperlinkValue.toString().trim().stimulsoft().startsWith('javascript:') && !this.usePdfA) {
                    let stl = new StiLinkObject();
                    stl.Link = page.hyperlinkValue.ToString();
                    stl.Page = tempPageNumber;
                    this.linksArray.push(stl);
                }
                if (page.watermark != null && page.watermark.enabled) {
                    if (!StiString.isNullOrEmpty(page.watermark.text)) {
                        if (page.watermark.font != null) {
                            this.pdfFont.getFontNumber(page.watermark.font);
                        }
                        let sb = new StringBuilder(page.watermark.text);
                        sb = this.bidi.convert(sb, false);
                        this.pdfFont.storeUnicodeSymbolsInMap(sb.toString());
                        this.storeShadingData1(page.watermark.textBrush, tempPageNumber);
                        this.storeHatchData(page.watermark.textBrush);
                    }
                    if (page.watermark.showImageBehind == true) {
                        if (page.watermark.image != null) {
                            this.storeImageData(page.watermark.image, imageResolution, false, false);
                        }
                    }
                }
                for (let component of page.components.list) {
                    if (component.enabled && !(report.isPrinting && !component.printable)) {
                        this.imageInfoCounter++;
                        let needPaint = component.width > 0 && component.height > 0;
                        if (needPaint) {
                            let mBrush = component.as(IStiBrush);
                            if (mBrush != null) {
                                this.storeShadingData1(mBrush.brush, tempPageNumber);
                                this.storeHatchData(mBrush.brush);
                            }
                            let shape = component.as(StiShape);
                            if (shape != null && __.b.StiPdfRenderPrimitives.checkShape(shape))
                                continue;
                            if (component.is(StiCheckBox)) {
                                let checkBox = component;
                                this.storeShadingData1(checkBox.textBrush, tempPageNumber);
                                this.storeHatchData(checkBox.textBrush);
                                if (this.allowEditable == __.b.StiPdfAllowEditable.Yes && checkBox.editable) {
                                    let seo = new StiEditableObject();
                                    seo.Page = tempPageNumber;
                                    seo.Component = component;
                                    this.annots2Array.push(seo);
                                }
                                continue;
                            }
                            let isExportAsImage = component.isExportAsImage(__.a.StiExportFormat.Pdf);
                            if (isExportAsImage) {
                                let flagIsImage = false;
                                let imageTemp = component;
                                if (this.imageResolutionMode != __.b.StiImageResolutionMode.Exactly && imageTemp != null) {
                                    if (imageTemp.imageToDraw != null && imageTemp.imageToDraw.bytes != null) {
                                        flagIsImage = true;
                                        let rsImageResolution = imageTemp.imageToDraw.horizontalResolution / 100;
                                        if (this.imageResolutionMode == __.b.StiImageResolutionMode.NoMoreThan) {
                                            if (imageTemp.stretch) {
                                                rsImageResolution = imageTemp.imageToDraw.width / report.unit.convertToHInches(component.width);
                                            } else {
                                                rsImageResolution = 1 / imageTemp.multipleFactor;
                                            }
                                        }
                                        rsImageResolution = this.storeImageData(imageTemp.imageToDraw, rsImageResolution, true, imageTemp.smoothing);
                                        this.imageInfoList.set(this.imageInfoCounter, rsImageResolution);
                                    }
                                }
                                if (!flagIsImage) {
                                    let exportImage = component.as(IStiExportImageExtended);
                                    if (exportImage != null) {
                                        let rsImageResolution = imageResolution;
                                        let REFrsImageResolution = { ref: rsImageResolution };
                                        let image = exportImage.getImage(REFrsImageResolution, __.a.StiExportFormat.Pdf);
                                        rsImageResolution = REFrsImageResolution.ref;
                                        if (image != null) {
                                            this.storeImageData(image, rsImageResolution, false, false);
                                            this.imageInfoList.set(this.imageInfoCounter, rsImageResolution);
                                        }
                                    }
                                }
                            }
                            let mFont = component.as(IStiFont);
                            if (mFont != null) {
                                this.pdfFont.getFontNumber(mFont.font);
                            }
                            let textOpt = component.stimulsoft().as(IStiTextOptions);
                            if (component.is(StiText) && !isExportAsImage) {
                                let text = component;
                                let useRightToLeft = textOpt != null && textOpt.textOptions != null && textOpt.textOptions.rightToLeft;
                                let sb = new StringBuilder(text.text);
                                if (text.allowHtmlTags) {
                                    if (Stimulsoft['StiOptions'].Engine.useNewHtmlEngine) {
                                        this.storeWysiwygSymbols(text, tempPageNumber);
                                    } else {
                                        let baseTagsState = new Stimulsoft.Base.Drawing.StiHtmlTagsState(text.font.bold, text.font.italic, text.font.underline, text.font.strikeout, text.font.size, text.font.name, StiBrush.toColor(text.textBrush), StiBrush.toColor(text.brush), false, false, 0, 0, 1, text.horAlignment);
                                        let baseState = new Stimulsoft.Base.Drawing.StiHtmlState(baseTagsState, 0);
                                        let states = Stimulsoft.Base.Drawing.StiTextRenderer.parseHtmlToStates(text.text, baseState);
                                        sb = new StringBuilder();
                                        for (let index1 = 0; index1 < states.length; index1++) {
                                            let state = states[index1];
                                            sb.append(Stimulsoft.Base.Drawing.StiTextRenderer.prepareStateText(state.text));
                                        }
                                    }
                                }
                                sb = this.bidi.convert(sb, useRightToLeft);
                                this.pdfFont.storeUnicodeSymbolsInMap(sb.toString());
                                let mTextBrush = component.as(IStiTextBrush);
                                if (text != null && mTextBrush != null) {
                                    this.storeShadingData1(mTextBrush.textBrush, tempPageNumber);
                                    this.storeHatchData(mTextBrush.textBrush);
                                }
                                if (this.allowEditable == __.b.StiPdfAllowEditable.Yes && text.editable) {
                                    let seo = new StiEditableObject();
                                    seo.Page = tempPageNumber;
                                    this.annotsArray.push(seo);
                                    this.fontGlyphsReduceNotNeed[this.pdfFont.currentFont] = true;
                                }
                                if (text.indicator != null) {
                                    let indicator = text.indicator.stimulsoft().as(StiIconSetIndicator);
                                    if (indicator != null && (indicator.icon != StiIcon.None || indicator.customIcon != null)) {
                                        let image = StiIconSetHelper.getIcon(indicator);
                                        let rsImageResolution = 1;
                                        rsImageResolution = this.storeImageData(image, rsImageResolution, false, true, true);
                                        this.imageInfoList[this.imageInfoCounter] = rsImageResolution;
                                    }
                                    let barIndicator = text.indicator.stimulsoft().as(StiDataBarIndicator);
                                    if (barIndicator != null && barIndicator.value != 0 && barIndicator.brushType == __.a.Components.StiBrushType.Gradient) {
                                        let startColor = barIndicator.value < 0 ? barIndicator.negativeColor : barIndicator.positiveColor;
                                        let endColor = StiColorUtils.light(startColor, 200);
                                        let ssd = new StiShadingData();
                                        ssd.Page = tempPageNumber;
                                        ssd.FunctionIndex = this.getShadingFunctionNumber(startColor, endColor, false);
                                        this.shadingArray.push(ssd);
                                    }
                                }
                            }
                            if (component.is(StiBarCode) && !isExportAsImage) {
                                let pdfGeomWriter = new __.b.StiPdfGeomWriter(this.pageStream, this, true);
                                let barCodePainter = __.b.StiBarCodeExportPainter.createNew(pdfGeomWriter);
                                let barCode = component;
                                if (!StiString.isNullOrEmpty(barCode.codeValue) && barCode.page != null) {
                                    let rectf = report.unit.convertRectangleToHInches(barCode.clientRectangle);
                                    barCode.barCodeType.draw(barCodePainter, barCode, rectf, 1);
                                }
                            } else if (component.is(IStiChart) && !isExportAsImage) {
                                let pp = new StiPdfData(this);
                                pp.Component = component;
                                __.b.StiPdfRenderChart.renderChart(pp, true, tempPageNumber);
                            } else if (component.is(StiSparkline) && !isExportAsImage) {
                                let pp = new StiPdfData(this);
                                pp.Component = component;
                                __.b.StiPdfRenderChart.renderSparkline(pp, true, tempPageNumber);
                            }
                        }
                        if (component.hyperlinkValue != null && component.hyperlinkValue.toString().trim().length > 0 && !component.hyperlinkValue.toString().trim().stimulsoft().startsWith('javascript:')) {
                            let stl = new StiLinkObject();
                            stl.Link = component.hyperlinkValue.toString();
                            stl.Page = tempPageNumber;
                            this.linksArray.push(stl);
                        }
                        if (component.toolTipValue != null && component.toolTipValue.toString().trim().length > 0 && !this.usePdfA) {
                            let stl = new StiLinkObject();
                            stl.Page = tempPageNumber;
                            this.tooltipsArray.push(stl);
                        }
                        if (component.tagValue != null && component.tagValue.toString().toLowerCase() == 'pdfunsignedsignaturefield' && !this.usePdfA) {
                            let stl = new StiEditableObject();
                            stl.Page = tempPageNumber;
                            this.unsignedSignaturesArray.push(stl);
                        }
                    }
                }
                tempPageNumber++;
                if (page.watermark != null && page.watermark.enabled) {
                    if (page.watermark.showImageBehind == false) {
                        if (page.watermark.image != null) {
                            this.storeImageData(page.watermark.image, imageResolution, false, false);
                        }
                    }
                }
            }
            for (let indexFont = 0; indexFont < this.pdfFont.fontList.length; indexFont++) {
                this.pdfFont.currentFont = indexFont;
                this.pdfFont.storeUnicodeSymbolsInMap('…');
            }
            if (this.unsignedSignaturesArray.stimulsoft().countItems > 0 && (this.annotsArray.stimulsoft().countItems > 0 || this.annots2Array.stimulsoft().countItems > 0)) {
                for (let indexFont = 0; indexFont < this.pdfFont.fontList.stimulsoft().countItems; indexFont++) {
                    let font = this.pdfFont.fontList[indexFont];
                    if (font.Name == 'Arial') {
                        this.fontGlyphsReduceNotNeed[indexFont] = true;
                    }
                }
            }
            let sbb = '';
            for (let indexs = 32; indexs < 256; indexs++) {
                sbb += String.fromCharCode(this.CodePage1252[indexs]);
            }
            for (let indexf = 0; indexf < this.pdfFont.fontList.length; indexf++) {
                if (this.fontGlyphsReduceNotNeed[indexf]) {
                    this.pdfFont.currentFont = indexf;
                    this.pdfFont.storeUnicodeSymbolsInMap(sbb);
                }
            }
            this.imagesCurrent = 0;
            this.annotsCurrent = 0;
            this.annots2Current = 0;
            this.shadingCurrent = 0;
            this.linksCounter = this.linksArray.stimulsoft().countItems;
            this.haveLinks = this.linksCounter > 0;
            this.annotsCounter = this.annotsArray.length;
            this.annots2Counter = this.annots2Array.length;
            this.unsignedSignaturesCounter = this.unsignedSignaturesArray.length;
            this.haveAnnots = this.annotsCounter > 0 || this.annots2Counter > 0 || this.unsignedSignaturesCounter > 0;
            this.tooltipsCounter = this.tooltipsArray.stimulsoft().countItems;
            this.haveTooltips = this.tooltipsCounter > 0;
            this.pdfFont.InitFontsData(report);
            this.fontsCounter = this.pdfFont.fontList.length;
            this.info = new __.b.StiPdfStructure();
            for (let index = 0; index < pages.count; index++) {
                this.info.pageList.push(this.info.createContentObject(true));
            }
            for (let index = 0; index < this.imageCache.imagePackedStore.length; index++) {
                this.info.xObjectList.push(this.info.createXObject(true, this.imageCache.imageMaskStore[index] != null));
            }
            for (let index = 0; index < this.pdfFont.fontList.length; index++) {
                let tempFontInfo = this.pdfFont.fontList[index];
                this.info.fontList.push(this.info.createFontObject(true, tempFontInfo.UseUnicode, this.standardPdfFonts, this.embeddedFonts || __.b.PdfFonts.isFontStimulsoft(tempFontInfo.Name)));
            }
            this.info.outlines = this.info.createOutlinesObject(this.haveBookmarks);
            if (this.haveBookmarks) {
                for (let index = 0; index < this.bookmarksCounter; index++) {
                    this.info.outlines.items.push(this.info.createObject(true));
                }
            }
            this.info.patterns = this.info.createPatternsObject(true);
            for (let index = 0; index < this.hatchArray.length; index++) {
                this.info.patterns.hatchItems.push(this.info.createObject(true));
            }
            for (let index = 0; index < this.shadingArray.length; index++) {
                this.info.patterns.shadingItems.push(this.info.createObject(true));
            }
            for (let index = 0; index < this.shadingFunctionArray.length; index++) {
                this.info.patterns.shadingFunctionItems.push(this.info.createObject(true));
            }
            for (let index = 0; index < this.linksCounter; index++) {
                this.info.linkList.push(this.info.createObject(true));
            }
            this.info.encode = this.info.createObject(this.encrypted);
            this.info.extGState = this.info.createObject(true);
            this.info.acroForm = this.info.createAcroFormObject(this.haveAnnots || this.haveTooltips);
            if (this.haveAnnots) {
                for (let index = 0; index < this.annotsCounter; index++) {
                    this.info.acroForm.annots.push(this.info.createAnnotObject(true, true, 0));
                }
                for (let index = 0; index < this.fontsCounter; index++) {
                    this.info.acroForm.annotFontItems.push(this.info.createFontObject(true, false, false, false, true));
                }
                for (let index = 0; index < this.annots2Counter; index++) {
                    this.info.acroForm.checkBoxes.push(new __.b.StiPdfCheckBoxObjInfo());
                    this.info.acroForm.checkBoxes[index].items = [];
                    this.info.acroForm.checkBoxes[index].items.push(this.info.createAnnotObject(true, true, 2));
                    this.info.acroForm.checkBoxes[index].items.push(this.info.createAnnotObject(true, true, 2));
                    if (this.annots2Array[index].Component.as(StiCheckBox).checkedValue == null) {
                        this.info.acroForm.checkBoxes[index].items.push(this.info.createAnnotObject(true, false, 2));
                    }
                }
                for (let index = 0; index < this.unsignedSignaturesCounter; index++) {
                    this.info.acroForm.unsignedSignatures.push(this.info.createAnnotObject(true, false, 0));
                }
            }
            for (let index = 0; index < this.tooltipsCounter; index++) {
                this.info.acroForm.tooltips.push(this.info.createAnnotObject(true, false, 0));
            }
            this.info.metadata = this.info.createObject(true);
            this.info.destOutputProfile = this.info.createObject(true);
            this.info.outputIntents = this.info.createObject(true);
            this.info.embeddedJS = this.info.createContentObject(this.autoPrint != __.b.StiPdfAutoPrintMode.None);
            if (this.embeddedFiles != null && this.embeddedFiles.countItems > 0) {
                this.embeddedFiles.forEach(element => this.info.embeddedFilesList.push(this.info.createContentObject(true)));
            }
            this.renderStartDoc(report, pages);
            let pageNumber = 0;
            this.linksArray.stimulsoft().clear();
            this.tagsArray = new Array();
            this.tooltipsArray.stimulsoft().clear();
            this.unsignedSignaturesArray.stimulsoft().clear();
            this.imageInfoCounter = 0;
            this.currentPassNumber++;
            for (let page of pages.list) {
                pages.getPage(page);
                if (this.isStopped)
                    return;
                this.renderPageHeader(pageNumber++);
                let pageHeight = this.hiToTwips * report.unit.convertToHInches(page.pageHeight * page.segmentPerHeight);
                let pageWidth = this.hiToTwips * report.unit.convertToHInches(page.pageWidth * page.segmentPerWidth);
                let mgLeft = this.hiToTwips * report.unit.convertToHInches(page.margins.left);
                let mgRight = this.hiToTwips * report.unit.convertToHInches(page.margins.right);
                let mgTop = this.hiToTwips * report.unit.convertToHInches(page.margins.top);
                let mgBottom = this.hiToTwips * report.unit.convertToHInches(page.margins.bottom);
                if (pageHeight > 14400) {
                    pageHeight = 14400;
                }
                if (this.haveBookmarks && (!StiString.isNullOrEmpty(page.guid) || page.bookmarkValue != null && page.bookmarkValue.toString() != '')) {
                    let tempIndex = 0;
                    while (tempIndex < this.bookmarksCounter) {
                        let tn = this.bookmarksTree[tempIndex];
                        if (tn.Used == false && tn.Page == -1) {
                            let finded = false;
                            if (!StiString.isNullOrEmpty(tn.Guid)) {
                                if (!StiString.isNullOrEmpty(page.guid) && tn.Guid == page.guid)
                                    finded = true;
                            } else if (!StiString.isNullOrEmpty(tn.Title)) {
                                if (page.bookmarkValue != null && page.bookmarkValue.length > 0 && tn.Title == page.bookmarkValue)
                                    finded = true;
                            }
                            if (finded) {
                                tn.Page = pageNumber - 1;
                                tn.Y = pageHeight;
                                tn.Used = true;
                                this.bookmarksTree[tempIndex] = tn;
                                break;
                            }
                        }
                        tempIndex++;
                    }
                }
                if (page.hyperlinkValue != null && page.hyperlinkValue.toString().trim().length > 0 && !page.hyperlinkValue.toString().trim().stimulsoft().startsWith('javascript:') && !this.usePdfA) {
                    let stl = new StiLinkObject();
                    stl.Link = page.hyperlinkValue.toString();
                    stl.X = 0;
                    stl.Y = 0;
                    stl.Width = pageWidth;
                    stl.Height = pageHeight;
                    stl.Page = pageNumber;
                    stl.DestPage = -1;
                    stl.DestY = -1;
                    this.linksArray.push(stl);
                }
                if (page.brush != null) {
                    let pp = new StiPdfData(this);
                    pp.X = 0;
                    pp.Y = 0;
                    pp.Width = pageWidth;
                    pp.Height = pageHeight;
                    let cont = new StiContainer();
                    cont.brush = page.brush;
                    cont.border = null;
                    pp.Component = cont;
                    __.b.StiPdfRenderPrimitives.renderBorder1(pp);
                }
                this.renderWatermark(page, true, pageWidth, pageHeight, imageResolution);
                let storedBorders = new Array();
                for (let component of page.components.list) {
                    if (component.enabled && !(report.isPrinting && !component.printable)) {
                        this.imageInfoCounter++;
                        let x1 = this.hiToTwips * report.unit.convertToHInches(component.left);
                        let y1 = this.hiToTwips * report.unit.convertToHInches(component.top);
                        let x2 = this.hiToTwips * report.unit.convertToHInches(component.right);
                        let y2 = this.hiToTwips * report.unit.convertToHInches(component.bottom);
                        let pp = new StiPdfData(this);
                        pp.X = x1 + mgLeft;
                        pp.Y = y1 + mgTop;
                        pp.Width = x2 - x1;
                        pp.Height = y2 - y1;
                        pp.Y = pageHeight - (pp.Y + pp.Height);
                        pp.Component = component;
                        let needPaint = component.width > 0 && component.height > 0;
                        if (needPaint) {
                            let isExportAsImage = component.isExportAsImage(__.a.StiExportFormat.Pdf);
                            if (!this.usePdfA && !component.printable) {
                                this.pageStream.writeLine('/OC /oc1 BDC');
                            }
                            if (!component.is(StiShape)) {
                                __.b.StiPdfRenderPrimitives.renderBorder1(pp);
                            }
                            if (component.is(StiText) && !isExportAsImage) {
                                let stiText = component;
                                let memPos = 0;
                                if (this.haveAnnots && stiText.editable) {
                                    memPos = this.pageStream.position;
                                    this.pushColorToStack();
                                    this.lastColorStrokeA = 255;
                                    this.lastColorNonStrokeA = 255;
                                }
                                let pp2 = __.b.StiPdfRenderIndicators.renderIndicators(pp);
                                if (stiText.allowHtmlTags) {
                                    __.b.StiPdfRenderText.renderTextFont(pp2);
                                    if (Stimulsoft['StiOptions'].Engine.useNewHtmlEngine) {
                                        __.b.StiPdfRenderText.renderText2(pp, pageNumber);
                                    } else {
                                        let baseTagsState = new Stimulsoft.Base.Drawing.StiHtmlTagsState(stiText.font.bold, stiText.font.italic, stiText.font.underline, stiText.font.strikeout, stiText.font.size, stiText.font.name, StiBrush.toColor(stiText.textBrush), StiBrush.toColor(stiText.brush), false, false, 0, 0, 1, stiText.horAlignment);
                                        let baseState = new Stimulsoft.Base.Drawing.StiHtmlState(baseTagsState, 0);
                                        let states = Stimulsoft.Base.Drawing.StiTextRenderer.parseHtmlToStates(stiText.text, baseState);
                                        let sb = '';
                                        for (let index1 = 0; index1 < states.length; index1++) {
                                            let state = states[index1];
                                            if (state.ts.tag.tag == StiHtmlTag.P && state.text.toString() == '\n')
                                                continue;
                                            sb += Stimulsoft.Base.Drawing.StiTextRenderer.prepareStateText(state.text);
                                        }
                                        let text2 = stiText.clone(true);
                                        text2.text = sb;
                                        pp.Component = text2;
                                        __.b.StiPdfRenderText.renderTextFont(pp2);
                                        __.b.StiPdfRenderText.renderText(pp2);
                                    }
                                    if (this.haveAnnots && stiText.editable) {
                                        let seo = this.annotsArray[this.annotsCurrent];
                                        seo.Multiline = stiText.wordWrap;
                                        seo.X = pp.X;
                                        seo.Y = pp.Y;
                                        seo.Width = pp.Width;
                                        seo.Height = pp.Height;
                                        seo.Component = pp.Component;
                                        seo.Alignment = Stimulsoft.Base.Drawing.StiTextHorAlignment.Left;
                                        let mTextHorAlign = pp.Component.as(IStiTextHorAlignment);
                                        if (mTextHorAlign != null) {
                                            let horAlign = mTextHorAlign.horAlignment;
                                            let textOpt = pp.Component.as(IStiTextOptions);
                                            if (textOpt != null && textOpt.textOptions != null && textOpt.textOptions.rightToLeft) {
                                                if (horAlign == Stimulsoft.Base.Drawing.StiTextHorAlignment.Left)
                                                    horAlign = Stimulsoft.Base.Drawing.StiTextHorAlignment.Right;
                                                else if (horAlign == Stimulsoft.Base.Drawing.StiTextHorAlignment.Right)
                                                    horAlign = Stimulsoft.Base.Drawing.StiTextHorAlignment.Left;
                                            }
                                            seo.Alignment = horAlign;
                                        }
                                        seo.Text = pp.Component.as(StiText).text.toString().split('\n').join('');
                                    }
                                } else {
                                    __.b.StiPdfRenderText.renderTextFont(pp2);
                                    __.b.StiPdfRenderText.renderText(pp2);
                                }
                                if (this.haveAnnots && stiText.editable) {
                                    this.pageStream.flush();
                                    let memPos2 = this.pageStream.position;
                                    this.pageStream.seek(memPos, Stimulsoft.System.IO.SeekOrigin.Begin);
                                    let bufAnnot = [];
                                    this.pageStream.read(bufAnnot, 0, memPos2 - memPos);
                                    this.pageStream.seek(memPos, Stimulsoft.System.IO.SeekOrigin.Begin);
                                    this.pageStream.setLength(memPos);
                                    let seo = this.annotsArray[this.annotsCurrent];
                                    seo.Content = bufAnnot;
                                    this.annotsCurrent++;
                                    this.popColorFromStack();
                                }
                            }
                            if (component.is(StiShape))
                                __.b.StiPdfRenderPrimitives.renderShape(pp, imageResolution);
                            else if (component.is(StiBarCode) && !isExportAsImage) {
                                let pdfGeomWriter = new __.b.StiPdfGeomWriter(this.pageStream, this);
                                let barCodePainter = __.b.StiBarCodeExportPainter.createNew(pdfGeomWriter);
                                let barCode = component;
                                if (!StiString.isNullOrEmpty(barCode.codeValue) && barCode.page != null) {
                                    this.pageStream.writeLine('q');
                                    this.pushColorToStack();
                                    this.pageStream.writeLine1('{0} {1} {2} {3} re W n', this.convertToString(pp.X), this.convertToString(pp.Y), this.convertToString(pp.Width), this.convertToString(pp.Height));
                                    this.pageStream.writeLine1('1 0 0 1 {0} {1} cm', this.convertToString(mgLeft), this.convertToString(pageHeight - mgTop));
                                    this.pageStream.writeLine('1 0 0 -1 0 0 cm');
                                    this.pageStream.writeLine1('{0} 0 0 {0} 0 0 cm', this.convertToString(this.hiToTwips));
                                    let rectf = report.unit.convertRectangleToHInches(barCode.clientRectangle);
                                    barCode.barCodeType.draw(barCodePainter, barCode, rectf, 1);
                                    this.pageStream.writeLine('Q');
                                    this.popColorFromStack();
                                }
                            } else if (component.is(IStiChart) && !isExportAsImage) {
                                this.pageStream.writeLine('q');
                                this.pushColorToStack();
                                this.pageStream.writeLine1('1 0 0 1 {0} {1} cm', this.convertToString(pp.X), this.convertToString(pp.Y + pp.Height));
                                this.pageStream.writeLine('1 0 0 -1 0 0 cm');
                                this.pageStream.writeLine1('{0} 0 0 {0} 0 0 cm', this.convertToString(this.hiToTwips / 0.96));
                                __.b.StiPdfRenderChart.renderChart(pp, false, pageNumber - 1);
                                this.pageStream.writeLine('Q');
                                this.popColorFromStack();
                            } else if (component.is(StiSparkline) && !isExportAsImage) {
                                this.pageStream.writeLine('q');
                                this.pushColorToStack();
                                this.pageStream.writeLine1('1 0 0 1 {0} {1} cm', this.convertToString(pp.X), this.convertToString(pp.Y + pp.Height));
                                this.pageStream.writeLine('1 0 0 -1 0 0 cm');
                                this.pageStream.writeLine1('{0} 0 0 {0} 0 0 cm', this.convertToString(this.hiToTwips / 0.96));
                                __.b.StiPdfRenderChart.renderSparkline(pp, false, pageNumber - 1);
                                this.pageStream.writeLine('Q');
                                this.popColorFromStack();
                            } else {
                                if (component.is(StiCheckBox)) {
                                    let checkbox = component;
                                    if (this.haveAnnots && checkbox.editable) {
                                        let seo = this.annots2Array[this.annots2Current];
                                        seo.Multiline = false;
                                        seo.X = pp.X;
                                        seo.Y = pp.Y;
                                        seo.Width = pp.Width;
                                        seo.Height = pp.Height;
                                        seo.Component = pp.Component;
                                        seo.Alignment = Stimulsoft.Base.Drawing.StiTextHorAlignment.Center;
                                        seo.Text = '';
                                        let storeX = pp.X;
                                        let storeY = pp.Y;
                                        pp.X = 0;
                                        pp.Y = 0;
                                        this.pageStream.flush();
                                        let memPos = this.pageStream.position;
                                        this.pushColorToStack();
                                        this.lastColorStrokeA = 255;
                                        this.lastColorNonStrokeA = 255;
                                        __.b.StiPdfRenderPrimitives.renderCheckbox(pp, true);
                                        this.pageStream.flush();
                                        let memPos2 = this.pageStream.position;
                                        this.pageStream.seek(memPos, Stimulsoft.System.IO.SeekOrigin.Begin);
                                        let bufAnnot = [];
                                        this.pageStream.read(bufAnnot, 0, memPos2 - memPos);
                                        this.pageStream.seek(memPos, Stimulsoft.System.IO.SeekOrigin.Begin);
                                        seo.Content = bufAnnot;
                                        this.popColorFromStack();
                                        this.pageStream.flush();
                                        memPos = this.pageStream.position;
                                        this.pushColorToStack();
                                        this.lastColorStrokeA = 255;
                                        this.lastColorNonStrokeA = 255;
                                        __.b.StiPdfRenderPrimitives.renderCheckbox(pp, false, false);
                                        this.pageStream.flush();
                                        memPos2 = this.pageStream.position;
                                        this.pageStream.seek(memPos, Stimulsoft.System.IO.SeekOrigin.Begin);
                                        bufAnnot = [];
                                        this.pageStream.read(bufAnnot, 0, memPos2 - memPos);
                                        this.pageStream.seek(memPos, Stimulsoft.System.IO.SeekOrigin.Begin);
                                        seo.Content2 = bufAnnot;
                                        this.popColorFromStack();
                                        this.annots2Current++;
                                        pp.X = storeX;
                                        pp.Y = storeY;
                                    } else {
                                        let checkboxValue = __.b.StiPdfRenderPrimitives.getCheckBoxValue(checkbox);
                                        if (checkboxValue != null) {
                                            __.b.StiPdfRenderPrimitives.renderCheckbox(pp, checkboxValue);
                                        }
                                    }
                                } else if (isExportAsImage) {
                                    this.renderImage(pp, imageResolution);
                                }
                            }
                            if (component.is(StiRectanglePrimitive)) {
                                __.b.StiPdfRenderPrimitives.renderRoundedRectanglePrimitive(pp);
                            } else {
                                let mBorder = pp.Component.as(IStiBorder);
                                if (mBorder != null && mBorder.border != null && mBorder.border.topmost) {
                                    storedBorders.push(pp);
                                } else {
                                    __.b.StiPdfRenderPrimitives.renderBorder2(pp);
                                }
                            }
                            if (!this.usePdfA && !component.printable) {
                                this.pageStream.writeLine('EMC');
                            }
                        }
                        if (this.haveBookmarks && (!StiString.isNullOrEmpty(component.guid) || component.bookmarkValue != null && component.bookmarkValue != '')) {
                            let tempIndex = 0;
                            while (tempIndex < this.bookmarksCounter) {
                                let tn = this.bookmarksTree[tempIndex];
                                if (tn.Used == false && tn.Page == -1) {
                                    let finded = false;
                                    if (!StiString.isNullOrEmpty(tn.Guid)) {
                                        if (!StiString.isNullOrEmpty(component.guid) && tn.Guid == component.guid)
                                            finded = true;
                                    } else if (!StiString.isNullOrEmpty(tn.Title)) {
                                        if (component.bookmarkValue != null && component.bookmarkValue.length > 0 && tn.Title == component.bookmarkValue)
                                            finded = true;
                                    }
                                    if (finded) {
                                        tn.Page = pageNumber - 1;
                                        tn.Y = pp.Y + pp.Height;
                                        tn.Used = true;
                                        this.bookmarksTree[tempIndex] = tn;
                                        break;
                                    }
                                }
                                tempIndex++;
                            }
                        }
                        if (component.hyperlinkValue != null && component.hyperlinkValue.toString().trim().length > 0 && !component.hyperlinkValue.toString().trim().stimulsoft().startsWith('javascript:')) {
                            let stl = new StiLinkObject();
                            stl.Link = component.hyperlinkValue.toString();
                            stl.X = pp.X;
                            stl.Y = pp.Y;
                            stl.Width = pp.Width;
                            stl.Height = pp.Height;
                            stl.Page = pageNumber;
                            stl.DestPage = -1;
                            stl.DestY = -1;
                            this.linksArray.push(stl);
                        }
                        if (component.tagValue != null && component.tagValue.toString().trim().length > 0) {
                            let stl = new StiLinkObject();
                            stl.Link = component.tagValue.toString();
                            stl.X = pp.X;
                            stl.Y = pp.Y;
                            stl.Width = pp.Width;
                            stl.Height = pp.Height;
                            stl.Page = pageNumber - 1;
                            stl.DestPage = -1;
                            stl.DestY = -1;
                            this.tagsArray.push(stl);
                            if (stl.Link.trim().toLowerCase() == 'pdfunsignedsignaturefield' && !this.usePdfA) {
                                let ste = new StiEditableObject();
                                ste.X = stl.X;
                                ste.Y = stl.Y;
                                ste.Width = stl.Width;
                                ste.Height = stl.Height;
                                ste.Page = stl.Page;
                                ste.Component = component;
                                this.unsignedSignaturesArray.push(ste);
                            }
                        }
                        if (component.pointerValue != null && !StiString.isNullOrWhiteSpace(component.pointerValue) && !StiString.isNullOrWhiteSpace(component.guid)) {
                            let pointerValue = '#' + component.pointerValue + '#GUID#' + component.guid;
                            let stl = new StiLinkObject();
                            stl.Link = pointerValue;
                            stl.X = pp.X;
                            stl.Y = pp.Y;
                            stl.Width = pp.Width;
                            stl.Height = pp.Height;
                            stl.Page = pageNumber - 1;
                            stl.DestPage = -1;
                            stl.DestY = -1;
                            this.tagsArray.push(stl);
                        }
                        if (component.toolTipValue != null && component.toolTipValue.toString().trim().length > 0 && !this.usePdfA) {
                            let stl = new StiLinkObject();
                            stl.Link = component.toolTipValue.toString().trim();
                            stl.X = pp.X;
                            stl.Y = pp.Y;
                            stl.Width = pp.Width;
                            stl.Height = pp.Height;
                            stl.Page = pageNumber - 1;
                            stl.DestPage = -1;
                            stl.DestY = -1;
                            this.tooltipsArray.push(stl);
                        }
                    }
                }
                for (let ppd of storedBorders) {
                    __.b.StiPdfRenderPrimitives.renderBorder2(ppd);
                }
                storedBorders.stimulsoft().clear();
                if (page.border != null) {
                    let pp = new StiPdfData(this);
                    pp.X = mgLeft;
                    pp.Y = mgBottom;
                    pp.Width = pageWidth - mgLeft - mgRight;
                    pp.Height = pageHeight - mgTop - mgBottom;
                    let cont = new StiContainer();
                    cont.border = page.border;
                    pp.Component = cont;
                    __.b.StiPdfRenderPrimitives.renderBorder2(pp);
                }
                this.renderWatermark(page, false, pageWidth, pageHeight, imageResolution);
                this.renderPageFooter(pageHeight, pageWidth);
            }
            this.bookmarksTreeTemp = null;
            if (this.haveBookmarks && deleteEmptyBookmarks) {
                for (let indexNode = 0; indexNode < this.bookmarksTree.stimulsoft().countItems; indexNode++) {
                    let tn = this.bookmarksTree[indexNode];
                    if (tn.Used) {
                        while (tn.Parent != -1) {
                            tn = this.bookmarksTree[tn.Parent];
                            tn.Used = true;
                        }
                    }
                }
                let rootBookmark = new StiBookmark();
                this.makeBookmarkFromTree(rootBookmark, this.bookmarksTree[0]);
                this.bookmarksTreeTemp = this.bookmarksTree;
                this.bookmarksTree = new Array();
                this.addBookmarkNode(rootBookmark, -1);
                let numberNodesToAdd = this.bookmarksCounter - this.bookmarksTree.stimulsoft().countItems;
                if (numberNodesToAdd > 0) {
                    let tn = new StiPdfBookmarkTreeNode();
                    tn.Parent = -1;
                    tn.First = -1;
                    tn.Last = -1;
                    tn.Prev = -1;
                    tn.Next = -1;
                    tn.Count = -1;
                    tn.Page = -1;
                    tn.Y = -1;
                    tn.Title = '';
                    for (let indexNode = 0; indexNode < numberNodesToAdd; indexNode++) {
                        this.bookmarksTree.push(tn);
                    }
                }
                let htNameToNode = new Hashtable();
                for (let indexBookmark = 0; indexBookmark < this.bookmarksTreeTemp.stimulsoft().countItems; indexBookmark++) {
                    let tn = this.bookmarksTreeTemp[indexBookmark];
                    htNameToNode.set(tn.Title, tn);
                }
                for (let indexBookmark = 0; indexBookmark < this.bookmarksTree.stimulsoft().countItems; indexBookmark++) {
                    let tn = this.bookmarksTree[indexBookmark];
                    if (!StiString.isNullOrEmpty(tn.Title)) {
                        let tnOld = htNameToNode.get(tn.Title);
                        tn.Page = tnOld.Page;
                        tn.Y = tnOld.Y;
                    }
                }
                this.bookmarksTreeTemp = null;
            }
            this.renderImageTable();
            this.renderFontTable();
            this.renderBookmarksTable();
            this.renderPatternTable();
            this.renderLinkTable();
            this.renderEncodeRecord();
            this.renderExtGStateRecord();
            this.renderAnnotTable();
            this.renderTooltipTable();
            this.renderMetadata(report);
            this.renderColorSpace();
            this.renderAutoPrint();
            this.renderEmbeddedFiles();
            this.renderEndDoc();
            this.xref = null;
            this.bookmarksTree = null;
            this.linksArray = null;
            this.tagsArray = null;
            this.tooltipsArray = null;
            this.annotsArray = null;
            this.annots2Array = null;
            this.unsignedSignaturesArray = null;
            this.shadingArray = null;
            this.hatchArray = null;
            this.colorStack = null;
            this.pdfFont.clear();
            this.pdfFont = null;
            this.bidi.clear();
            this.bidi = null;
        }
    };
    StiPdfExportService.regexEscape = new RegExp('([{}()^$&.*?/+|[\\\\]|]|-)', 'g');
    __.b.StiPdfExportService = StiPdfExportService;
}
let FontStyle = Stimulsoft.System.Drawing.FontStyle;
{
    let PdfFontInfo = class {
    };
    __.b.PdfFontInfo = PdfFontInfo;
    let pfontInfo = class {
    };
    __.b.pfontInfo = pfontInfo;
    let TableDirectoryItem = class {
        constructor() {
            this.TagString = null;
            this.Tag = 0;
            this.CheckSum = 0;
            this.Offset = 0;
            this.Length = 0;
            this.NewOffset = 0;
            this.NewLength = 0;
            this.Required = false;
            this.NewTable = null;
        }
    };
    let TtfInfo = class {
        constructor() {
            this.HeaderOffset = 0;
            this.NumTables = 0;
            this.NumTablesRequired = 0;
            this.SfntVersion = 0;
            this.Tables = null;
            this.HeadCheckSumOffset = 0;
            this.NumGlyphs = 0;
            this.IndexToLocFormat = 0;
            this.IndexLocaTable = 0;
            this.IndexGlyfTable = 0;
            this.IndexCmapTable = 0;
            this.IndexCFFTable = -1;
            this.FontName = null;
            this.HeaderOffset = 0;
            this.NumTables = 0;
            this.NumTablesRequired = 0;
            this.SfntVersion = 0;
            this.Tables = null;
            this.HeadCheckSumOffset = 0;
            this.NumGlyphs = 0;
            this.IndexToLocFormat = 0;
            this.IndexLocaTable = 0;
            this.IndexGlyfTable = 0;
            this.FontName = new Hashtable();
        }
    };
    let PdfFonts = class extends PdfFontInfo {
        constructor() {
            super();
            this.standardFontQuantity = 12;
            this.standardFontNumWidths = 310;
            this.standardFontNumChars = 3680 + 189;
            this.firstMappedSymbol = 64;
            this.factor = 1;
            this.maxSymbols = 32767;
            this.forceUseUnicode = true;
            this.WIDTHS = null;
            this.fonts = null;
            this.UnicodeMapsList = null;
            this.GlyphMapsList = null;
            this.standardPdfFonts = true;
            this.fontsInfoStore = null;
            this.family_Helvetica = [
                'Arial',
                'Arial Black',
                'Arial Narrow',
                'Century Gothic',
                'Comic Sans MS',
                'Impact',
                'Microsoft Sans Serif',
                'Tahoma',
                'Verdana'
            ];
            this.family_Courier = [
                'Courier New',
                'Lucida Console'
            ];
            this.family_Times_Roman = [
                'Book Antiqua',
                'Bookman Old Style',
                'Garamond',
                'Georgia',
                'Times New Roman'
            ];
            this.family_Symbol = ['Symbol'];
            this.family_ZapfDingbats = ['Wingdings 2'];
            this.PdfFontName = [
                'Helvetica',
                'Helvetica-Bold',
                'Helvetica-Oblique',
                'Helvetica-BoldOblique',
                'Times-Roman',
                'Times-Bold',
                'Times-Italic',
                'Times-BoldItalic',
                'Courier',
                'Courier-Bold',
                'Courier-Oblique',
                'Courier-BoldOblique',
                'Symbol',
                'ZapfDingbats'
            ];
            this._currentFont = -1;
            this.TtfHeaderSize = 12;
            this.ARG_1_AND_2_ARE_WORDS = 1;
            this.ARGS_ARE_XY_VALUES = 2;
            this.ROUND_XY_TO_GRID = 4;
            this.WE_HAVE_A_SCALE = 8;
            this.MORE_COMPONENTS = 32;
            this.WE_HAVE_AN_X_AND_Y_SCALE = 64;
            this.WE_HAVE_A_TWO_BY_TWO = 128;
            this.WE_HAVE_INSTRUCTIONS = 256;
            this.USE_MY_METRICS = 512;
            this.OVERLAP_COMPOUND = 1024;
            this.SCALED_COMPONENT_OFFSET = 2048;
            this.UNSCALED_COMPONENT_OFFSET = 4096;
            this.TablesNames = [
                'head',
                'hhea',
                'hmtx',
                'maxp',
                'cmap',
                'OS/2',
                'post',
                'cvt ',
                'fpgm',
                'glyf',
                'loca',
                'prep',
                'name'
            ];
            this.fontList = new Array();
            this.UnicodeMapsList = new Array();
            this.GlyphMapsList = new Array();
            this.fontsInfoStore = new FontsInfoStore();
        }
        getFontMetrics(font, currentFontInfo, glyphMap, report) {
            this.WIDTHS = StiArray.create(Number, this.maxSymbols + 1);
            if (font == null)
                return;
            let tempFont = new Font(font.name, 1024, font.style, Stimulsoft.System.Drawing.GraphicsUnit.Pixel);
            StiArray.copy(currentFontInfo.UnicodeMapBack, 0, this.WIDTHS, currentFontInfo.MappedSymbolsCount);
            let size = Stimulsoft.System.Drawing.Graphics.measureChars(this.WIDTHS, currentFontInfo.MappedSymbolsCount, tempFont);
            let symHeight = size.height;
            let lineHeight = size.width;
            currentFontInfo.CH = 0;
            currentFontInfo.tmASC = StiMath.round2(symHeight * 0.8 * this.factor);
            currentFontInfo.tmDESC = StiMath.round2(symHeight * 0.2 * this.factor);
            currentFontInfo.tmExternal = StiMath.round2((lineHeight - symHeight) * this.factor);
            currentFontInfo.LLX = 0;
            currentFontInfo.LLY = 0;
            currentFontInfo.URX = 0;
            currentFontInfo.URY = 0;
            currentFontInfo.StemV = 0;
            currentFontInfo.ItalicAngle = 0;
            currentFontInfo.UnderscoreSize = StiMath.round2(symHeight * (font.bold ? 0.08 : 0.06) * this.factor);
            currentFontInfo.UnderscorePosition = StiMath.round2(-symHeight * 0.1 * this.factor);
            currentFontInfo.StrikeoutSize = StiMath.round2(symHeight * 0.045 * this.factor);
            currentFontInfo.StrikeoutPosition = StiMath.round2(symHeight * 0.25 * this.factor);
            for (let index = 0; index < currentFontInfo.MappedSymbolsCount; index++) {
                this.WIDTHS[index] = StiMath.round2(this.WIDTHS[index] * this.factor, 0);
            }
            let buff = this.getFontDataBuf(font, report);
            if (buff instanceof Uint8Array && buff.byteLength > 0) {
                let cmap = this.getCharToGlyphTable(buff, font.name);
                if (cmap != null) {
                    let offset = 0;
                    if (font.name == 'Wingdings' || font.name == 'Wingdings 2' || font.name == 'Wingdings 3')
                        offset = 61440;
                    for (let index = 0; index < currentFontInfo.MappedSymbolsCount; index++) {
                        let charCode = currentFontInfo.UnicodeMapBack[index];
                        if (charCode >= 128 && charCode <= 255) {
                            charCode += offset;
                        }
                        currentFontInfo.GlyphList[index] = cmap[charCode];
                    }
                }
            }
            currentFontInfo.NeedSyntBold = this.NeedSyntBold;
            currentFontInfo.NeedSyntItalic = this.NeedSyntItalic;
        }
        static isFontStimulsoft(name) {
            return name == 'Stimulsoft';
        }
        get currentFont() {
            return this._currentFont;
        }
        set currentFont(value) {
            if (this._currentFont != value) {
                this._currentFont = value;
                if (this.fonts != null && this.fonts.length > 0) {
                    this.Widths = this.fonts[this._currentFont].Widths;
                    this.CH = this.fonts[this._currentFont].CH;
                    this.XH = this.fonts[this._currentFont].XH;
                    this.ASC = this.fonts[this._currentFont].ASC;
                    this.DESC = this.fonts[this._currentFont].DESC;
                    this.tmASC = this.fonts[this._currentFont].tmASC;
                    this.tmDESC = this.fonts[this._currentFont].tmDESC;
                    this.tmExternal = this.fonts[this._currentFont].tmExternal;
                    this.MacAscend = this.fonts[this._currentFont].MacAscend;
                    this.MacDescend = this.fonts[this._currentFont].MacDescend;
                    this.MacLineGap = this.fonts[this._currentFont].MacLineGap;
                    this.LLX = this.fonts[this._currentFont].LLX;
                    this.LLY = this.fonts[this._currentFont].LLY;
                    this.URX = this.fonts[this._currentFont].URX;
                    this.URY = this.fonts[this._currentFont].URY;
                    this.StemV = this.fonts[this._currentFont].StemV;
                    this.ItalicAngle = this.fonts[this._currentFont].ItalicAngle;
                    this.LineGap = this.fonts[this._currentFont].LineGap;
                    this.NtmFlags = this.fonts[this._currentFont].NtmFlags;
                    this.UnderscoreSize = this.fonts[this._currentFont].UnderscoreSize;
                    this.UnderscorePosition = this.fonts[this._currentFont].UnderscorePosition;
                    this.StrikeoutSize = this.fonts[this._currentFont].StrikeoutSize;
                    this.StrikeoutPosition = this.fonts[this._currentFont].StrikeoutPosition;
                    this.UnicodeMap = this.fonts[this._currentFont].UnicodeMap;
                    this.UnicodeMapBack = this.fonts[this._currentFont].UnicodeMapBack;
                    this.GlyphList = this.fonts[this._currentFont].GlyphList;
                    this.GlyphBackList = this.fonts[this._currentFont].GlyphBackList;
                    this.GlyphRtfList = this.fonts[this._currentFont].GlyphRtfList;
                    this.SymsToPDF = this.fonts[this._currentFont].SymsToPDF;
                    this.CharPdfNames = this.fonts[this._currentFont].CharPdfNames;
                    this.MappedSymbolsCount = this.fonts[this._currentFont].MappedSymbolsCount;
                    this.NeedSyntBold = this.fonts[this._currentFont].NeedSyntBold;
                    this.NeedSyntItalic = this.fonts[this._currentFont].NeedSyntItalic;
                    this.GlyphWidths = this.fonts[this._currentFont].GlyphWidths;
                    this.ChildFontsMap = this.fonts[this._currentFont].ChildFontsMap;
                    this.UseUnicode = this.fonts[this._currentFont].UseUnicode;
                }
            }
        }
        InitFontsData(report) {
            let fontsCount = this.fontList.length;
            for (let indexFont = 0; indexFont < fontsCount; indexFont++) {
                let currFont = this.fontList[indexFont];
                let useUnicode = this.forceUseUnicode;
                if (useUnicode) {
                    let buff = null;
                    buff = this.getFontDataBuf(currFont.Font, report);
                    if (buff == null || buff.Length == 0) {
                        useUnicode = false;
                    }
                }
                currFont.UseUnicode = useUnicode;
                this.fontList[indexFont] = currFont;
                if (!useUnicode) {
                    let map = this.UnicodeMapsList[indexFont];
                    let mapSymbol = this.firstMappedSymbol;
                    for (let indexChar = this.firstMappedSymbol; indexChar < 65536; indexChar++) {
                        if (map[indexChar] > 0)
                            mapSymbol++;
                    }
                    if (mapSymbol > 255) {
                        currFont = this.fontList[indexFont];
                        let newMap = null;
                        let fontsMap = StiArray.create(Number, 65536);
                        let currentFontNumber = this.fontList.length;
                        for (let indexChar = 0; indexChar < this.firstMappedSymbol; indexChar++)
                            fontsMap[indexChar] = currentFontNumber;
                        let needAddNewFontInfo = true;
                        mapSymbol = this.firstMappedSymbol;
                        for (let indexChar = this.firstMappedSymbol; indexChar < 65536; indexChar++) {
                            if (needAddNewFontInfo) {
                                let fi = new pfontInfo();
                                fi.Name = currFont.Name;
                                fi.PdfName = currFont.PdfName;
                                fi.Bold = currFont.Bold;
                                fi.Italic = currFont.Italic;
                                fi.Number = currFont.Number;
                                fi.Font = currFont.Font;
                                fi.ParentFontNumber = indexFont;
                                fi.UseUnicode = useUnicode;
                                this.fontList.push(fi);
                                newMap = StiArray.create(Number, 65536);
                                StiArray.copy(map, 0, newMap, 64);
                                this.UnicodeMapsList.push(newMap);
                                this.GlyphMapsList.push(StiArray.create(Number, 65536));
                                currentFontNumber = this.fontList.length - 1;
                                mapSymbol = this.firstMappedSymbol;
                                needAddNewFontInfo = false;
                            }
                            if (map[indexChar] > 0) {
                                newMap[indexChar] = 1;
                                fontsMap[indexChar] = currentFontNumber;
                                mapSymbol++;
                                if (mapSymbol == 254)
                                    needAddNewFontInfo = true;
                            }
                        }
                        currFont.ChildFontsMap = fontsMap;
                        this.fontList[indexFont] = currFont;
                    }
                }
            }
            this.fonts = StiArray.create(PdfFontInfo, this.fontList.length);
            for (let indexFont = 0; indexFont < this.fontList.length; indexFont++) {
                this.fonts[indexFont] = new PdfFontInfo();
                let currentFontInfo = this.fonts[indexFont];
                currentFontInfo.UnicodeMap = this.UnicodeMapsList[indexFont];
                currentFontInfo.UnicodeMapBack = StiArray.create(Number, this.maxSymbols + 1);
                currentFontInfo.UseUnicode = this.fontList[indexFont].UseUnicode;
                let tempGlyphMap = this.GlyphMapsList[indexFont];
                let mappedSymbol = this.firstMappedSymbol;
                for (let indexSymbol = this.firstMappedSymbol; indexSymbol < 65536; indexSymbol++) {
                    if (currentFontInfo.UnicodeMap[indexSymbol] != 0) {
                        currentFontInfo.UnicodeMap[indexSymbol] = mappedSymbol;
                        currentFontInfo.UnicodeMapBack[mappedSymbol] = indexSymbol;
                        mappedSymbol++;
                        if (mappedSymbol > this.maxSymbols)
                            mappedSymbol = this.maxSymbols;
                        if (!currentFontInfo.UseUnicode && mappedSymbol == 92) {
                            currentFontInfo.UnicodeMapBack[mappedSymbol] = indexSymbol;
                            mappedSymbol++;
                        }
                    }
                }
                let tempIndexSymbol = 8226;
                currentFontInfo.UnicodeMap[tempIndexSymbol] = mappedSymbol;
                currentFontInfo.UnicodeMapBack[mappedSymbol] = tempIndexSymbol;
                mappedSymbol++;
                currentFontInfo.MappedSymbolsCount = mappedSymbol;
                for (let indexSymbol = 0; indexSymbol < this.firstMappedSymbol; indexSymbol++) {
                    currentFontInfo.UnicodeMap[indexSymbol] = indexSymbol;
                    currentFontInfo.UnicodeMapBack[indexSymbol] = indexSymbol;
                }
                currentFontInfo.CharPdfNames = StiArray.create(String, mappedSymbol);
                currentFontInfo.SymsToPDF = StiArray.create(Number, mappedSymbol);
                for (let indexTemp = 32; indexTemp < currentFontInfo.MappedSymbolsCount; indexTemp++) {
                    let offset = -1;
                    for (let indexOffset = 0; indexOffset < this.standardFontNumWidths; indexOffset++) {
                    }
                    currentFontInfo.SymsToPDF[indexTemp] = offset;
                    let st = __.b.StiPdfResources.standardFontCharsNames[currentFontInfo.UnicodeMapBack[indexTemp]];
                    if (st == null) {
                        st = 'uni' + currentFontInfo.UnicodeMapBack[indexTemp].toString(16).toUpperCase().stimulsoft().padLeft(4, '0');
                    }
                    currentFontInfo.CharPdfNames[indexTemp] = st;
                }
                currentFontInfo.GlyphList = StiArray.create(Number, mappedSymbol);
                let tmpfi = this.fontList[indexFont];
                this.fonts[indexFont].Widths = StiArray.create(Number, mappedSymbol);
                this.getFontMetrics(tmpfi.Font, currentFontInfo, tempGlyphMap, report);
                for (let tempIndex = 0; tempIndex < mappedSymbol - 32; tempIndex++) {
                    this.fonts[indexFont].Widths[tempIndex] = this.WIDTHS[32 + tempIndex];
                }
                if (this.standardPdfFonts == true) {
                }
                if (this.fontList[indexFont].ChildFontsMap != null) {
                    currentFontInfo.MappedSymbolsCount = 255;
                    currentFontInfo.ChildFontsMap = this.fontList[indexFont].ChildFontsMap;
                }
            }
            this._currentFont = -1;
            this.currentFont = 0;
        }
        getFontNumber(incomingFont) {
            let fontNumber = -1;
            if (this.fontList.length > 0) {
                for (let index = 0; index < this.fontList.length; index++) {
                    let tmpfi = this.fontList[index];
                    if (tmpfi.Name == incomingFont.name && tmpfi.Bold == incomingFont.bold && tmpfi.Italic == incomingFont.italic) {
                        fontNumber = index;
                        break;
                    }
                }
            }
            if (fontNumber == -1) {
                let fi = new pfontInfo();
                fi.Name = incomingFont.name;
                fi.Bold = incomingFont.bold;
                fi.Italic = incomingFont.italic;
                fi.Font = incomingFont;
                fi.ParentFontNumber = -1;
                fontNumber = 0;
                for (let st of this.family_Helvetica)
                    if (fi.Name == st)
                        fontNumber = 0;
                for (let st of this.family_Times_Roman)
                    if (fi.Name == st)
                        fontNumber = 4;
                for (let st of this.family_Courier)
                    if (fi.Name == st)
                        fontNumber = 8;
                if (fontNumber < 12) {
                    if (fi.Bold == true)
                        fontNumber += 1;
                    if (fi.Italic == true)
                        fontNumber += 2;
                }
                fi.Number = fontNumber;
                fi.PdfName = this.PdfFontName[fontNumber];
                this.fontList.push(fi);
                fontNumber = this.fontList.length - 1;
                this.UnicodeMapsList.push(StiArray.create(Number, 65536));
                this.GlyphMapsList.push(StiArray.create(Number, 65536));
            }
            this.currentFont = fontNumber;
            return fontNumber;
        }
        storeUnicodeSymbolsInMap(st) {
            if (!StiString.isNullOrEmpty(st) && this.currentFont != -1) {
                let map = this.UnicodeMapsList[this.currentFont];
                for (let indexChar = 0; indexChar < st.length; indexChar++) {
                    map[st.charCodeAt(indexChar)] = 1;
                }
            }
        }
        storeGlyphsInMap(sb) {
            if (sb.length > 0 && this.currentFont != -1) {
                let map = this.GlyphMapsList[this.currentFont];
                for (let indexChar = 0; indexChar < sb.length; indexChar++) {
                    map[sb.charCodeAt(indexChar)] = 1;
                }
                map[65535] = 1;
            }
        }
        getCharToGlyphTable(buff, fontName) {
            let ttf = this.scanFontFile(buff, fontName);
            if (ttf != null) {
                return this.getCmapTable(buff, ttf);
            }
            return null;
        }
        reduceFontSize(buff, fontName, remakeGlyphTable) {
            let ttf = this.scanFontFile(buff, fontName);
            let outputStream = null;
            if (ttf != null) {
                if (ttf.IndexLocaTable == ttf.IndexGlyfTable && ttf.IndexCFFTable != -1) {
                    ttf.Tables[ttf.IndexCFFTable].Required = true;
                    ttf.NumTablesRequired++;
                    remakeGlyphTable = false;
                }
                if (remakeGlyphTable) {
                    let glyphNeeds = StiArray.create(Boolean, ttf.NumGlyphs);
                    let glyphNeedsScan = StiArray.create(Boolean, ttf.NumGlyphs);
                    for (let indexGlyph = 0; indexGlyph < this.GlyphList.length; indexGlyph++) {
                        let glyphNumber = this.GlyphList[indexGlyph];
                        if (glyphNumber < ttf.NumGlyphs) {
                            glyphNeeds[glyphNumber] = true;
                            glyphNeedsScan[glyphNumber] = true;
                        }
                    }
                    glyphNeeds[0] = true;
                    glyphNeeds[1] = true;
                    glyphNeeds[2] = true;
                    glyphNeeds[3] = true;
                    glyphNeedsScan[0] = true;
                    glyphNeedsScan[1] = true;
                    glyphNeedsScan[2] = true;
                    glyphNeedsScan[3] = true;
                    let offsetLocaTable = ttf.Tables[ttf.IndexLocaTable].Offset;
                    let offsetGlyfTable = ttf.Tables[ttf.IndexGlyfTable].Offset;
                    let needScan = true;
                    while (needScan) {
                        needScan = false;
                        for (let indexGlyph = 0; indexGlyph < ttf.NumGlyphs; indexGlyph++) {
                            if (glyphNeedsScan[indexGlyph] == true) {
                                glyphNeedsScan[indexGlyph] = false;
                                let locaOffsetScan = offsetLocaTable + indexGlyph * (ttf.IndexToLocFormat == 1 ? 4 : 2);
                                let offsetGlyf = 0;
                                if (ttf.IndexToLocFormat == 1) {
                                    offsetGlyf = this.GetUInt32(buff, locaOffsetScan);
                                } else {
                                    offsetGlyf = 2 * this.GetUInt16(buff, locaOffsetScan);
                                }
                                offsetGlyf += offsetGlyfTable;
                                if (this.GetInt16(buff, offsetGlyf) == -1) {
                                    needScan = true;
                                    offsetGlyf += 10;
                                    let flags = 0;
                                    do {
                                        flags = this.GetUInt16(buff, offsetGlyf);
                                        let glyphIndex = this.GetUInt16(buff, offsetGlyf + 2);
                                        if (glyphIndex < ttf.NumGlyphs) {
                                            glyphNeeds[glyphIndex] = true;
                                            glyphNeedsScan[glyphIndex] = true;
                                        }
                                        offsetGlyf += 4;
                                        if ((flags & this.ARG_1_AND_2_ARE_WORDS) > 0) {
                                            offsetGlyf += 2;
                                            offsetGlyf += 2;
                                        } else {
                                            offsetGlyf += 2;
                                        }
                                        if ((flags & this.WE_HAVE_A_SCALE) > 0) {
                                            offsetGlyf += 2;
                                        } else {
                                            if ((flags & this.WE_HAVE_AN_X_AND_Y_SCALE) > 0) {
                                                offsetGlyf += 2;
                                                offsetGlyf += 2;
                                            } else {
                                                if ((flags & this.WE_HAVE_A_TWO_BY_TWO) > 0) {
                                                    offsetGlyf += 2;
                                                    offsetGlyf += 2;
                                                    offsetGlyf += 2;
                                                    offsetGlyf += 2;
                                                }
                                            }
                                        }
                                    } while ((flags & this.MORE_COMPONENTS) > 0);
                                }
                            }
                        }
                    }
                    let newLength = 0;
                    let locaOffset = offsetLocaTable;
                    for (let indexGlyph = 0; indexGlyph < ttf.NumGlyphs; indexGlyph++) {
                        let offsetBegin = 0;
                        let offsetEnd = 0;
                        if (ttf.IndexToLocFormat == 1) {
                            offsetBegin = this.GetUInt32(buff, locaOffset);
                            offsetEnd = this.GetUInt32(buff, locaOffset + 4);
                            locaOffset += 4;
                        } else {
                            offsetBegin = 2 * this.GetUInt16(buff, locaOffset);
                            offsetEnd = 2 * this.GetUInt16(buff, locaOffset + 2);
                            locaOffset += 2;
                        }
                        if (glyphNeeds[indexGlyph]) {
                            newLength += offsetEnd - offsetBegin;
                        }
                    }
                    let newGlyfTable = new Uint8Array(newLength + 4);
                    let newLocaTable = new Uint8Array(ttf.Tables[ttf.IndexLocaTable].Length + 4);
                    let currentGlyfPos = 0;
                    locaOffset = offsetLocaTable;
                    let locaOffset2 = 0;
                    for (let indexGlyph = 0; indexGlyph < ttf.NumGlyphs; indexGlyph++) {
                        let offsetBegin = 0;
                        let offsetEnd = 0;
                        if (ttf.IndexToLocFormat == 1) {
                            offsetBegin = this.GetUInt32(buff, locaOffset);
                            offsetEnd = this.GetUInt32(buff, locaOffset + 4);
                            locaOffset += 4;
                        } else {
                            offsetBegin = 2 * this.GetUInt16(buff, locaOffset);
                            offsetEnd = 2 * this.GetUInt16(buff, locaOffset + 2);
                            locaOffset += 2;
                        }
                        let lengthGlyf = offsetEnd - offsetBegin;
                        if (glyphNeeds[indexGlyph] == true) {
                            for (let indexPos = 0; indexPos < lengthGlyf; indexPos++) {
                                newGlyfTable[currentGlyfPos + indexPos] = buff[offsetGlyfTable + offsetBegin + indexPos];
                            }
                        } else {
                            lengthGlyf = 0;
                        }
                        if (ttf.IndexToLocFormat == 0) {
                            this.SetUInt16(newLocaTable, locaOffset2, currentGlyfPos / 2);
                        } else {
                            this.SetUInt32(newLocaTable, locaOffset2, currentGlyfPos);
                        }
                        currentGlyfPos += lengthGlyf;
                        locaOffset2 += ttf.IndexToLocFormat == 1 ? 4 : 2;
                    }
                    if (ttf.IndexToLocFormat == 0) {
                        this.SetUInt16(newLocaTable, locaOffset2, currentGlyfPos / 2);
                    } else {
                        this.SetUInt32(newLocaTable, locaOffset2, currentGlyfPos);
                    }
                    ttf.Tables[ttf.IndexGlyfTable].NewLength = currentGlyfPos;
                    ttf.Tables[ttf.IndexGlyfTable].NewTable = newGlyfTable;
                    ttf.Tables[ttf.IndexLocaTable].NewTable = newLocaTable;
                }
                let newHeader = new Uint8Array(this.TtfHeaderSize + ttf.NumTablesRequired * 16);
                this.copyUint8Array(buff, ttf.HeaderOffset, newHeader, 0, newHeader.length);
                let maximumPower = 1;
                while (2 << maximumPower - 1 <= ttf.NumTablesRequired) {
                    maximumPower++;
                }
                maximumPower--;
                let searchRange = (2 << maximumPower - 1) * 16;
                let entrySelector = maximumPower;
                let rangeShift = ttf.NumTablesRequired * 16 - searchRange;
                this.SetUInt16(newHeader, 4, ttf.NumTablesRequired);
                this.SetUInt16(newHeader, 6, searchRange);
                this.SetUInt16(newHeader, 8, entrySelector);
                this.SetUInt16(newHeader, 10, rangeShift);
                let currentTable = 0;
                let currentPos = this.TtfHeaderSize + ttf.NumTablesRequired * 16;
                for (let indexTable = 0; indexTable < ttf.NumTables; indexTable++) {
                    if (ttf.Tables[indexTable].Required) {
                        ttf.Tables[indexTable].NewOffset = currentPos;
                        currentPos += ttf.Tables[indexTable].NewLength;
                        let remainder = currentPos % 4;
                        if (remainder > 0) {
                            currentPos += 4 - remainder;
                        }
                        let pos = this.TtfHeaderSize + currentTable * 16;
                        this.SetUInt32(newHeader, pos, ttf.Tables[indexTable].Tag);
                        this.SetUInt32(newHeader, pos + 4, ttf.Tables[indexTable].CheckSum);
                        this.SetUInt32(newHeader, pos + 8, ttf.Tables[indexTable].NewOffset);
                        this.SetUInt32(newHeader, pos + 12, ttf.Tables[indexTable].NewLength);
                        currentTable++;
                    }
                }
                outputStream = new MemoryStream();
                outputStream.writeBytes(newHeader, 0, newHeader.length);
                for (let indexTable = 0; indexTable < ttf.NumTables; indexTable++) {
                    if (ttf.Tables[indexTable].Required) {
                        if (ttf.Tables[indexTable].NewTable != null) {
                            outputStream.writeBytes(ttf.Tables[indexTable].NewTable, 0, ttf.Tables[indexTable].NewLength);
                        } else {
                            outputStream.writeBytes(buff, ttf.Tables[indexTable].Offset, ttf.Tables[indexTable].NewLength);
                        }
                        let remainder = ttf.Tables[indexTable].NewLength % 4;
                        if (remainder > 0) {
                            outputStream.write(StiArray.create(Number, 4 - remainder), 0, 4 - remainder);
                        }
                    }
                }
                outputStream.flush();
            }
            return outputStream;
        }
        scanFontFile(buff, fontName) {
            let ttf = null;
            let tag = this.GetUInt32(buff, 0);
            if (tag == 65536 || tag == 1330926671) {
                ttf = this.getTtfInfo(buff, 0);
            } else {
                let ttcVer = this.GetUInt32(buff, 4);
                if (tag == 1953784678 && (ttcVer == 65536 || ttcVer == 131072)) {
                    let numFontsTtc = this.GetUInt32(buff, 8);
                    for (let indexTtc = numFontsTtc - 1; indexTtc >= 0; indexTtc--) {
                        let offset = this.GetUInt32(buff, 12 + indexTtc * 4);
                        let tagTtc = this.GetUInt32(buff, offset);
                        if (tagTtc == 65536) {
                            ttf = this.getTtfInfo(buff, offset);
                            if (ttf.FontName.contains(fontName)) {
                                break;
                            }
                        }
                    }
                }
            }
            return ttf;
        }
        getCmapTable(buff, ttf) {
            let charToGlyph = null;
            let offsetCmapTable = ttf.Tables[ttf.IndexCmapTable].Offset;
            let numCmapTables = this.GetUInt16(buff, offsetCmapTable + 2);
            for (let indexRecord = 0; indexRecord < numCmapTables; indexRecord++) {
                let offsetRecord = offsetCmapTable + 4 + indexRecord * 8;
                let platformID = this.GetUInt16(buff, offsetRecord);
                let encodingID = this.GetUInt16(buff, offsetRecord + 2);
                let offsetTable = offsetCmapTable + this.GetUInt32(buff, offsetRecord + 4);
                if (platformID == 3 && encodingID == 1) {
                    let formatNumber = this.GetUInt16(buff, offsetTable);
                    if (formatNumber == 4) {
                        charToGlyph = StiArray.create(Number, 65536);
                        for (let indexT1 = 0; indexT1 < 65536; indexT1++)
                            charToGlyph[indexT1] = 65535;
                        let segCountX2 = this.GetUInt16(buff, offsetTable + 6);
                        for (let indexSeg = 0; indexSeg < segCountX2; indexSeg += 2) {
                            let offsetSeg = offsetTable + 14 + indexSeg;
                            let endCode = this.GetUInt16(buff, offsetSeg);
                            let startCode = this.GetUInt16(buff, offsetSeg + 2 + segCountX2);
                            let idDelta = this.GetInt16(buff, offsetSeg + 2 + segCountX2 * 2);
                            let idRangeOffset = this.GetUInt16(buff, offsetSeg + 2 + segCountX2 * 3);
                            if (startCode != 65535) {
                                for (let indexChar = startCode; indexChar <= endCode; indexChar++) {
                                    let glyphId = 65535;
                                    if (idRangeOffset == 0) {
                                        glyphId = idDelta + indexChar & 65535;
                                    } else {
                                        let glyphIndexAddress = idRangeOffset + 2 * (indexChar - startCode) + (offsetSeg + 2 + segCountX2 * 3);
                                        glyphId = this.GetUInt16(buff, glyphIndexAddress);
                                        if (glyphId != 0)
                                            glyphId += idDelta;
                                    }
                                    charToGlyph[indexChar] = glyphId;
                                }
                            }
                        }
                    }
                }
            }
            return charToGlyph;
        }
        copyUint8Array(source, from, destination, to, count) {
            for (let index = 0; index < count; index++) {
                destination[to + index] = source[from + index];
            }
        }
        getTtfInfo(buff, bufOffset) {
            let ttf = new TtfInfo();
            ttf.HeaderOffset = bufOffset;
            ttf.SfntVersion = this.GetUInt32(buff, ttf.HeaderOffset);
            ttf.NumTables = this.GetUInt16(buff, ttf.HeaderOffset + 4);
            ttf.NumTablesRequired = 0;
            ttf.Tables = [];
            for (let indexTable = 0; indexTable < ttf.NumTables; indexTable++)
                ttf.Tables[indexTable] = new TableDirectoryItem();
            for (let index = 0; index < ttf.NumTables; index++) {
                let pos = ttf.HeaderOffset + this.TtfHeaderSize + index * 16;
                let sbTable = new StringBuilder();
                for (let tempIndex = 0; tempIndex < 4; tempIndex++) {
                    sbTable.append(String.fromCharCode(this.GetUInt8(buff, pos + tempIndex)));
                }
                ttf.Tables[index].Tag = this.GetUInt32(buff, pos);
                ttf.Tables[index].TagString = sbTable.toString();
                ttf.Tables[index].CheckSum = this.GetUInt32(buff, pos + 4);
                ttf.Tables[index].Offset = this.GetUInt32(buff, pos + 8);
                ttf.Tables[index].Length = this.GetUInt32(buff, pos + 12);
                ttf.Tables[index].NewLength = ttf.Tables[index].Length;
                for (let tempIndex = 0; tempIndex < this.TablesNames.length; tempIndex++) {
                    if (ttf.Tables[index].TagString == this.TablesNames[tempIndex]) {
                        ttf.Tables[index].Required = true;
                        ttf.NumTablesRequired++;
                        break;
                    }
                }
                switch (ttf.Tables[index].TagString) {
                case 'head':
                    ttf.IndexToLocFormat = this.GetUInt16(buff, ttf.Tables[index].Offset + 50);
                    break;
                case 'maxp':
                    ttf.NumGlyphs = this.GetUInt16(buff, ttf.Tables[index].Offset + 4);
                    break;
                case 'loca':
                    ttf.IndexLocaTable = index;
                    break;
                case 'glyf':
                    ttf.IndexGlyfTable = index;
                    break;
                case 'cmap':
                    ttf.IndexCmapTable = index;
                    break;
                case 'CFF ':
                    ttf.IndexCFFTable = index;
                    break;
                case 'name': {
                        let tableOffset = ttf.Tables[index].Offset;
                        let countNames = this.GetUInt16(buff, tableOffset + 2);
                        let storageOffset = this.GetUInt16(buff, tableOffset + 4);
                        for (let indexName = 0; indexName < countNames; indexName++) {
                            let posName = tableOffset + 6 + indexName * 12;
                            let platformID = this.GetUInt16(buff, posName);
                            let encodingID = this.GetUInt16(buff, posName + 2);
                            let nameID = this.GetUInt16(buff, posName + 6);
                            let lengthName = this.GetUInt16(buff, posName + 8);
                            let offsetName = this.GetUInt16(buff, posName + 10);
                            if (platformID == 3 && encodingID == 1 && nameID == 1 || platformID == 0 && encodingID == 3 && nameID == 1) {
                                let sbName = new StringBuilder();
                                for (let indexChar = 0; indexChar < lengthName / 2; indexChar++) {
                                    sbName.append(String.fromCharCode(this.GetUInt16(buff, tableOffset + storageOffset + offsetName + indexChar * 2)));
                                }
                                let name = sbName.toString();
                                ttf.FontName.set(name, name);
                            }
                        }
                        break;
                    }
                }
            }
            return ttf;
        }
        GetUInt8(buff, pos) {
            return buff[pos];
        }
        GetUInt16(buff, pos) {
            return (buff[pos] << 8) + buff[pos + 1];
        }
        GetUInt32(buff, pos) {
            return (buff[pos] << 24) + (buff[pos + 1] << 16) + (buff[pos + 2] << 8) + buff[pos + 3];
        }
        GetInt16(buff, pos) {
            let vvalue = (buff[pos] << 8) + buff[pos + 1];
            return vvalue > 32767 ? vvalue - 65536 : vvalue;
        }
        SetUInt16(buff, pos, value) {
            buff[pos + 0] = value >>> 8 & 255;
            buff[pos + 1] = value & 255;
        }
        SetUInt32(buff, pos, value) {
            buff[pos + 0] = value >>> 24 & 255;
            buff[pos + 1] = value >>> 16 & 255;
            buff[pos + 2] = value >>> 8 & 255;
            buff[pos + 3] = value & 255;
        }
        clear() {
            this.fonts = null;
            this.fontList = null;
            this.UnicodeMapsList = null;
            this.GlyphMapsList = null;
            this.Widths = null;
            this.CharPdfNames = null;
            this.UnicodeMap = null;
            this.UnicodeMapBack = null;
            this.GlyphList = null;
            this.GlyphBackList = null;
            this.GlyphRtfList = null;
            this.SymsToPDF = null;
            this.GlyphWidths = null;
            this.fontsInfoStore.clear();
        }
        getFontDataBuf(font, report) {
            return this.getFontDataFromGdi(font, report);
        }
        getFontDataFromGdi(font, report) {
            let buff = null;
            if (PdfFonts.isFontStimulsoft(font.name)) {
                let stimulsoftFontBase64 = __.a.Resources.StimulsoftFont.getBase64Content();
                let buf = Stimulsoft.System.Convert.fromBase64String(stimulsoftFontBase64);
                return new Uint8Array(buf);
            }
            let fontData = Stimulsoft.Base.StiFontCollection.getBinFont(font.name, font.style);
            buff = fontData != null ? fontData.data : null;
            if (!(buff instanceof Uint8Array))
                buff = null;
            if (buff == null) {
                let isBold = (font.style & FontStyle.Bold) > 0;
                let isItalic = (font.style & FontStyle.Italic) > 0;
                if (isBold && isItalic) {
                    fontData = Stimulsoft.Base.StiFontCollection.getBinFont(font.name, FontStyle.Italic);
                    if (fontData != null && fontData.data != null) {
                        buff = fontData.data;
                        this.NeedSyntBold = true;
                    } else {
                        fontData = Stimulsoft.Base.StiFontCollection.getBinFont(font.name, FontStyle.Bold);
                        if (fontData != null && fontData.data != null) {
                            buff = fontData.data;
                            this.NeedSyntItalic = true;
                        } else {
                            fontData = Stimulsoft.Base.StiFontCollection.getBinFont(font.name, FontStyle.Regular);
                            if (fontData != null && fontData.data != null) {
                                buff = fontData.data;
                                this.NeedSyntItalic = true;
                                this.NeedSyntBold = true;
                            }
                        }
                    }
                } else {
                    if (isBold) {
                        fontData = Stimulsoft.Base.StiFontCollection.getBinFont(font.name, FontStyle.Regular);
                        if (fontData != null && fontData.data != null) {
                            buff = fontData.data;
                            this.NeedSyntBold = true;
                        }
                    }
                    if (isItalic) {
                        fontData = Stimulsoft.Base.StiFontCollection.getBinFont(font.name, FontStyle.Regular);
                        if (fontData != null && fontData.data != null) {
                            buff = fontData.data;
                            this.NeedSyntItalic = true;
                        }
                    }
                }
            }
            if (buff == null) {
                let resource = report.dictionary.resources.getByName(font.name);
                if (resource == null)
                    resource = report.dictionary.resources.getByAlias(font.name);
                if (resource != null && resource.content != null && resource.content.length > 0) {
                    buff = new Uint8Array(resource.content);
                    this.NeedSyntBold = true;
                    this.NeedSyntItalic = true;
                }
            }
            return buff;
        }
    };
    __.b.PdfFonts = PdfFonts;
    let FontsInfoStore = class {
        clear() {
        }
    };
    __.b.FontsInfoStore = FontsInfoStore;
}
let Point = Stimulsoft.System.Drawing.Point;
let StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
let StiPenUtils = Stimulsoft.Base.Drawing.StiPenUtils;
let DashStyle = Stimulsoft.System.Drawing.Drawing2D.DashStyle;
let StringFormat = Stimulsoft.System.Drawing.StringFormat;
let StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
let StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
let SizeD = Stimulsoft.System.Drawing.Size;
{
    __.b.StiPdfGeomWriter = class {
        constructor(stream, service, assembleData = false) {
            this.penWidthDefault = 0.1;
            this.precision_digits = 3;
            this.hiToTwips = 0.72;
            this.pdfCKT = 0.55228;
            this.makepath = false;
            this.pathClosed = false;
            this.path = null;
            this.pageStream = null;
            this.pdfService = null;
            this.assembleData = false;
            this.pageNumber = 0;
            this.matrixCache = null;
            this.xmin = null;
            this.xmax = null;
            this.ymin = null;
            this.ymax = null;
            this.pageStream = stream;
            this.pdfService = service;
            this.assembleData = assembleData;
            this.matrixCache = new Array();
        }
        calculateMinMax(pt) {
            if (this.xmin == null) {
                this.xmin = pt.x;
            } else {
                this.xmin = Math.min(this.xmin, pt.x);
            }
            if (this.xmax == null) {
                this.xmax = pt.x;
            } else {
                this.xmax = Math.max(this.xmax, pt.x);
            }
            if (this.ymin == null) {
                this.ymin = pt.y;
            } else {
                this.ymin = Math.min(this.ymin, pt.y);
            }
            if (this.ymax == null) {
                this.ymax = pt.y;
            } else {
                this.ymax = Math.max(this.ymax, pt.y);
            }
        }
        convertToString(value) {
            return StiMath.round2(value, this.precision_digits).toString().stimulsoft().replaceAll(',', Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
        }
        setPen(objPen, saveState = false) {
            if (objPen == null)
                return false;
            let needSaveState = false;
            if (objPen.stimulsoft().is(Stimulsoft.Base.Context.StiPenGeom)) {
                let pen = objPen.stimulsoft().as(StiPenGeom);
                let color = Color.transparent;
                if (pen.brush instanceof Color) {
                    color = pen.brush;
                } else {
                    color = StiBrush.toColor(pen.brush.stimulsoft().as(StiBrush));
                }
                this.pdfService.setStrokeColor(color);
                let penWidth = pen.thickness > 1 ? pen.thickness : pen.thickness * this.hiToTwips;
                if (penWidth == 0)
                    penWidth = this.penWidthDefault;
                this.pageStream.writeLine1('{0} w', this.convertToString(penWidth));
                needSaveState = saveState && pen.penStyle != StiPenStyle.Solid;
                if (needSaveState) {
                    this.pageStream.writeLine('q');
                }
                let dash = this.getPenStyleDashString(StiPenUtils.getPenStyle(pen.penStyle), pen.thickness * 0.025);
                if (dash != null) {
                    this.pageStream.writeLine(dash);
                }
            }
            return needSaveState;
        }
        setBrush(brush, rect, saveState = false) {
            if (brush == null)
                return false;
            if (this.assembleData) {
                if (!(brush instanceof Color) && (brush.is(StiGradientBrush) || brush.is(StiGlareBrush) || brush.is(StiHatchBrush) || brush.is(StiGlassBrush))) {
                    this.pdfService.storeShadingData1(brush.stimulsoft().as(StiBrush), this.pageNumber);
                    this.pdfService.storeHatchData(brush.stimulsoft().as(StiBrush));
                }
                return false;
            }
            let needSaveState = false;
            let tempColor = Color.transparent;
            if (brush instanceof Color) {
                tempColor = brush;
            } else {
                tempColor = StiBrush.toColor(brush.stimulsoft().as(StiBrush));
            }
            this.pdfService.setNonStrokeColor(tempColor);
            if (!(brush instanceof Color) && (brush.is(StiGradientBrush) || brush.is(StiGlareBrush) || brush.is(StiHatchBrush) || brush.is(StiGlassBrush))) {
                let mm = this.matrixCache.stimulsoft().peek();
                let p1 = new Point(rect.x, rect.bottom);
                let p2 = new Point(rect.right, rect.y);
                let points = [
                    p1,
                    p2
                ];
                mm.transformPoints(points);
                let rect2 = new Rectangle(points[0].x, points[0].y, points[1].x - points[0].x, points[1].y - points[0].y);
                let shadingCurrent = this.pdfService.storeShadingData2(rect2.x, rect2.y, rect2.width, rect2.height, brush.stimulsoft().as(StiBrush));
                if (brush.is(StiGradientBrush) || brush.is(StiGlareBrush)) {
                    this.pageStream.writeLine1('/Pattern cs /P{0} scn', 1 + shadingCurrent);
                }
                if (brush.is(StiHatchBrush)) {
                    let hBrush = brush;
                    this.pageStream.writeLine1('/Cs1 cs /PH{0} scn', this.pdfService.getHatchNumber(hBrush) + 1);
                }
                needSaveState = true;
            }
            needSaveState = needSaveState && saveState;
            if (needSaveState) {
                this.pageStream.writeLine('q');
            }
            return needSaveState;
        }
        outputLineString(st, pen) {
            if (pen != null) {
                let needRestoreState = this.setPen(pen, true);
                this.pageStream.writeLine(st);
                if (needRestoreState) {
                    this.pageStream.writeLine('Q');
                }
            }
        }
        convertArcToBezierPoints(rect, startAngle, sweepAngle) {
            let cx = rect.x + rect.width / 2;
            let cy = rect.y + rect.height / 2;
            let rx = rect.width / 2;
            let ry = rect.height / 2;
            startAngle *= Math.PI / 180;
            sweepAngle *= Math.PI / 180;
            let nCurves = Math.ceil(Math.abs(sweepAngle) / (Math.PI / 2));
            let pts = StiArray.create(Point, 3 * nCurves + 1, true);
            let aSweep = sweepAngle / nCurves;
            let y0 = Math.sin(aSweep / 2);
            let x0 = Math.cos(aSweep / 2);
            let tx = (1 - x0) * 4 / 3;
            let ty = y0 - tx * x0 / (y0 + 0.0001);
            let px = [];
            let py = [];
            px[0] = x0;
            py[0] = -y0;
            px[1] = x0 + tx;
            py[1] = -ty;
            px[2] = x0 + tx;
            py[2] = ty;
            px[3] = x0;
            py[3] = y0;
            let sn = Math.sin(startAngle + aSweep / 2);
            let cs = Math.cos(startAngle + aSweep / 2);
            pts[0].x = cx + rx * (px[0] * cs - py[0] * sn);
            pts[0].y = cy + ry * (px[0] * sn + py[0] * cs);
            for (let iCurve = 0; iCurve < nCurves; iCurve++) {
                let aStart = startAngle + aSweep * iCurve;
                sn = Math.sin(aStart + aSweep / 2);
                cs = Math.cos(aStart + aSweep / 2);
                for (let index = 1; index <= 3; index++) {
                    pts[index + iCurve * 3].x = cx + rx * (px[index] * cs - py[index] * sn);
                    pts[index + iCurve * 3].y = cy + ry * (px[index] * sn + py[index] * cs);
                }
            }
            return pts;
        }
        convertSplineToCubicBezier(points, tension) {
            let count = points.length;
            let len_pt = count * 3 - 2;
            let pt = [];
            tension = tension * 0.3;
            pt[0] = points[0];
            pt[1] = this.calculateCurveBezierEndPoints(points[0], points[1], tension);
            for (let index = 0; index < count - 2; index++) {
                let temp = this.calculateCurveBezier(points, index, tension);
                pt[3 * index + 2] = temp[0];
                pt[3 * index + 3] = points[index + 1];
                pt[3 * index + 4] = temp[1];
            }
            pt[len_pt - 2] = this.calculateCurveBezierEndPoints(points[count - 1], points[count - 2], tension);
            pt[len_pt - 1] = points[count - 1];
            return pt;
        }
        calculateCurveBezier(points, index, tension) {
            let xDiff = points[index + 2].x - points[index + 0].x;
            let yDiff = points[index + 2].y - points[index + 0].y;
            let p1 = new Point(points[index + 1].x - tension * xDiff, points[index + 1].y - tension * yDiff);
            let p2 = new Point(points[index + 1].x + tension * xDiff, points[index + 1].y + tension * yDiff);
            return [
                p1,
                p2
            ];
        }
        calculateCurveBezierEndPoints(end, adj, tension) {
            return new Point(tension * (adj.x - end.x) + end.x, tension * (adj.y - end.y) + end.y);
        }
        getPointString(point) {
            this.calculateMinMax(point);
            return StiString.format('{0} {1} {2} ', this.convertToString(point.x), this.convertToString(point.y), this.makepath && this.path.length > 0 ? 'l' : 'm');
        }
        getLineToString(pointTo) {
            this.calculateMinMax(pointTo);
            return StiString.format('{0} {1} l ', this.convertToString(pointTo.x), this.convertToString(pointTo.y));
        }
        getRectString4(x, y, width, height) {
            return this.getRectString(new Rectangle(x, y, width, height));
        }
        getRectString(rect) {
            return StiString.format('{0} {1} {2} {3} re ', this.convertToString(rect.x), this.convertToString(rect.top), this.convertToString(rect.right - rect.x), this.convertToString(rect.bottom - rect.y));
        }
        getBezierString(p1, p2, p3) {
            this.calculateMinMax(p1);
            this.calculateMinMax(p2);
            this.calculateMinMax(p3);
            return StiString.format('{0} {1} {2} {3} {4} {5} c ', this.convertToString(p1.x), this.convertToString(p1.y), this.convertToString(p2.x), this.convertToString(p2.y), this.convertToString(p3.x), this.convertToString(p3.y));
        }
        getBezierString2(p1x, p1y, p2x, p2y, p3x, p3y) {
            this.calculateMinMax(new Point(p1x, p1y));
            this.calculateMinMax(new Point(p2x, p2y));
            this.calculateMinMax(new Point(p3x, p3y));
            return StiString.format('{0} {1} {2} {3} {4} {5} c ', this.convertToString(p1x), this.convertToString(p1y), this.convertToString(p2x), this.convertToString(p2y), this.convertToString(p3x), this.convertToString(p3y));
        }
        getPolylineString(points, close, drawTo) {
            let sb = new StringBuilder();
            if (!drawTo) {
                sb.append(this.getPointString(points[0]));
            }
            for (let index = drawTo ? 0 : 1; index < points.length; index++) {
                sb.append(this.getLineToString(points[index]));
            }
            if (close) {
                sb.append('h ');
            }
            return sb.toString();
        }
        getEllipseString4(x, y, width, height) {
            return this.getEllipseString(new Rectangle(x, y, width, height));
        }
        getEllipseString(rect) {
            let tmpX = rect.width / 2 * (1 - this.pdfCKT);
            let tmpY = rect.height / 2 * (1 - this.pdfCKT);
            let sb = new StringBuilder();
            sb.appendFormat('{0} {1} m ', this.convertToString(rect.x), this.convertToString(rect.y + rect.height / 2));
            sb.append(this.getBezierString2(rect.x, rect.y + rect.height - tmpY, rect.x + tmpX, rect.y + rect.height, rect.x + rect.width / 2, rect.y + rect.height));
            sb.append(this.getBezierString2(rect.x + rect.width - tmpX, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height - tmpY, rect.x + rect.width, rect.y + rect.height / 2));
            sb.append(this.getBezierString2(rect.x + rect.width, rect.y + tmpY, rect.x + rect.width - tmpX, rect.y, rect.x + rect.width / 2, rect.y));
            sb.append(this.getBezierString2(rect.x + tmpX, rect.y, rect.x, rect.y + tmpY, rect.x, rect.y + rect.height / 2));
            return sb.toString();
        }
        getPenStyleDashString(style, step) {
            switch (style) {
            case DashStyle.Dot:
                return StiString.format('[{0} {1}] 0 d', this.convertToString(step), this.convertToString(step * 58));
            case DashStyle.Dash:
                return StiString.format('[{0} {1}] 0 d', this.convertToString(step * 49.5), this.convertToString(step * 62));
            case DashStyle.DashDot:
                return StiString.format('[{0} {1} {2} {1}] 0 d', this.convertToString(step * 50), this.convertToString(step * 55), this.convertToString(step));
            case DashStyle.DashDotDot:
                return StiString.format('[{0} {1} {2} {1} {2} {1}] 0 d', this.convertToString(step * 50), this.convertToString(step * 55), this.convertToString(step));
            }
            return null;
        }
        beginPath() {
            if (this.assembleData)
                return;
            this.path = new StringBuilder();
            this.makepath = true;
            this.pathClosed = false;
            this.xmin = null;
            this.xmax = null;
            this.ymin = null;
            this.ymax = null;
        }
        closeFigure() {
            if (this.assembleData)
                return;
            this.path.append('h ');
            this.pathClosed = true;
        }
        endPath() {
            if (this.assembleData)
                return;
            this.makepath = false;
        }
        fillPath(brush) {
            let rect = this.assembleData ? new Rectangle() : new Rectangle(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
            let needRestore = this.setBrush(brush, rect, true);
            if (this.assembleData)
                return;
            if (!this.pathClosed) {
                this.endPath();
            }
            this.pageStream.writeString(this.path.toString());
            this.pageStream.writeLine('f');
            if (needRestore)
                this.pageStream.writeLine('Q');
        }
        strokePath(pen) {
            if (this.assembleData)
                return;
            this.setPen(pen);
            this.pageStream.writeString(this.path.toString());
            this.pageStream.writeLine('S');
        }
        moveTo(point) {
            if (this.assembleData)
                return;
            this.lastPoint = point;
            let stPoint = this.getPointString(point);
            if (this.makepath) {
                this.path.appendLine(stPoint);
            } else {
                this.pageStream.writeLine(stPoint);
            }
        }
        drawLine(pointFrom, pointTo, pen) {
            if (this.assembleData)
                return;
            let stLine = this.getPointString(pointFrom) + this.getLineToString(pointTo);
            if (this.makepath) {
                this.path.appendLine(stLine);
            } else {
                this.outputLineString(stLine + 'S', pen);
            }
            this.lastPoint = pointTo;
        }
        drawLineTo(pointTo, pen) {
            if (this.assembleData)
                return;
            let stLine = this.getLineToString(pointTo);
            if (this.makepath) {
                this.path.appendLine(stLine);
            } else {
                this.outputLineString(stLine + 'S', pen);
            }
            this.lastPoint = pointTo;
        }
        drawRectangle(rect, pen) {
            if (this.assembleData)
                return;
            this.outputLineString(this.getRectString(rect) + 'S', pen);
        }
        fillRectangle(rect, brush) {
            let needRestore = this.setBrush(brush, rect, true);
            if (this.assembleData)
                return;
            if (brush != null) {
                this.pageStream.writeLine(this.getRectString(rect) + 'f');
            }
            if (needRestore)
                this.pageStream.writeLine('Q');
        }
        drawPolygon(points, pen) {
            this.drawPolyline(points, pen, true);
        }
        drawPolyline(points, pen, close = false, drawTo = false) {
            if (this.assembleData)
                return;
            let stPolyline = this.getPolylineString(points, close, drawTo);
            if (this.makepath) {
                this.path.appendLine(stPolyline);
            } else {
                this.outputLineString(stPolyline + 'S', pen);
            }
            this.lastPoint = points[points.length - 1];
        }
        drawPolylineTo(points, pen) {
            this.drawPolyline(points, pen, false, true);
        }
        fillPolygon(points, brush) {
            for (let pt of points) {
                this.calculateMinMax(pt);
            }
            let rect = new Rectangle(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
            let needRestore = this.setBrush(brush, rect, true);
            if (this.assembleData)
                return;
            if (brush != null) {
                let stPolygon = this.getPolylineString(points, true, false);
                this.pageStream.writeLine(stPolygon + 'f');
            }
            if (needRestore)
                this.pageStream.writeLine('Q');
        }
        drawBezier(p1, p2, p3, p4, pen) {
            if (this.assembleData)
                return;
            let stBezier = this.getPointString(p1) + this.getBezierString(p2, p3, p4);
            if (this.makepath) {
                this.path.appendLine(stBezier);
            } else {
                this.outputLineString(stBezier + 'S', pen);
            }
            this.lastPoint = p4;
        }
        drawBezierTo(p2, p3, p4, pen) {
            if (this.assembleData)
                return;
            let stBezier = this.getBezierString(p2, p3, p4);
            if (this.makepath) {
                this.path.appendLine(stBezier);
            } else {
                this.outputLineString(stBezier + 'S', pen);
            }
            this.lastPoint = p4;
        }
        drawSpline(points, tension, pen) {
            if (this.assembleData)
                return;
            let pts = this.convertSplineToCubicBezier(points, tension);
            let nCurves = (pts.length - 1) / 3;
            let stSpline = new StringBuilder();
            stSpline.append(this.getPointString(pts[0]) + this.getBezierString(pts[1], pts[2], pts[3]));
            for (let index = 1; index < nCurves; index++) {
                stSpline.append(this.getBezierString(pts[index * 3 + 1], pts[index * 3 + 2], pts[index * 3 + 3]));
            }
            if (this.makepath) {
                this.path.appendLine(stSpline.toString());
            } else {
                this.outputLineString(stSpline.toString() + 'S', pen);
            }
            this.lastPoint = pts[pts.length - 1];
        }
        drawArc(rect, startAngle, sweepAngle) {
            if (this.assembleData)
                return;
            let pts = this.convertArcToBezierPoints(rect, startAngle, sweepAngle);
            let nCurves = (pts.length - 1) / 3;
            this.drawBezier(pts[0], pts[1], pts[2], pts[3], null);
            for (let index = 1; index < nCurves; index++) {
                this.drawBezierTo(pts[index * 3 + 1], pts[index * 3 + 2], pts[index * 3 + 3], null);
            }
        }
        drawEllipse(rect, pen) {
            if (this.assembleData)
                return;
            this.outputLineString(this.getEllipseString(rect) + 'S', pen);
        }
        fillEllipse(rect, brush) {
            let needRestore = this.setBrush(brush, rect, true);
            if (this.assembleData)
                return;
            if (brush != null) {
                this.pageStream.writeLine(this.getEllipseString(rect) + 'f');
            }
            if (needRestore)
                this.pageStream.writeLine('Q');
        }
        drawPie(rect, startAngle, sweepAngle) {
            if (this.assembleData)
                return;
            let pts = this.convertArcToBezierPoints(rect, startAngle, sweepAngle);
            let nCurves = (pts.length - 1) / 3;
            let cx = rect.x + rect.width / 2;
            let cy = rect.y + rect.height / 2;
            this.drawBezier(pts[0], pts[1], pts[2], pts[3], null);
            for (let index = 1; index < nCurves; index++) {
                this.drawBezierTo(pts[index * 3 + 1], pts[index * 3 + 2], pts[index * 3 + 3], null);
            }
            this.drawLineTo(new Point(cx, cy), null);
            this.drawLineTo(pts[0], null);
        }
        drawString(st, font, brush, rect, sf) {
            if (this.assembleData) {
                if (font != null) {
                    this.pdfService.pdfFont.getFontNumber(font);
                }
                this.pdfService.pdfFont.storeUnicodeSymbolsInMap(st);
                return;
            }
            let txt = new StiText();
            txt.clientRectangle = new RectangleD(rect.x, rect.y, rect.width, rect.height);
            txt.text = st;
            txt.font = font;
            txt.textBrush = brush;
            if (!sf)
                sf = new StringFormat();
            if (sf.alignment == StringAlignment.Center)
                txt.horAlignment = StiTextHorAlignment.Center;
            if (sf.alignment == StringAlignment.Far)
                txt.horAlignment = StiTextHorAlignment.Right;
            if (sf.lineAlignment == StringAlignment.Center)
                txt.vertAlignment = StiVertAlignment.Center;
            if (sf.lineAlignment == StringAlignment.Far)
                txt.vertAlignment = StiVertAlignment.Bottom;
            if ((sf.formatFlags & StringFormatFlags.NoWrap) == 0)
                txt.wordWrap = true;
            let pp = new __.b.StiPdfData(this.pdfService);
            pp.Component = txt;
            pp.Width = rect.width * this.hiToTwips;
            pp.Height = rect.height * this.hiToTwips;
            this.pageStream.writeLine('q');
            this.pdfService.pushColorToStack();
            this.pageStream.writeLine1('1 0 0 1 {0} {1} cm', this.convertToString(rect.x), this.convertToString(rect.y + rect.height));
            this.pageStream.writeLine('1.39 0 0 -1.39 0 0 cm');
            __.b.StiPdfRenderText.renderTextFont(pp);
            __.b.StiPdfRenderText.renderText(pp);
            this.pageStream.writeLine('Q');
            this.pdfService.popColorFromStack();
        }
        saveState() {
            if (this.assembleData)
                return;
            this.pageStream.writeLine('q');
            this.pdfService.pushColorToStack();
            if (this.matrixCache.length > 0)
                this.matrixCache.push(this.matrixCache.stimulsoft().peek().clone());
        }
        restoreState() {
            if (this.assembleData)
                return;
            this.pageStream.writeLine('Q');
            this.pdfService.popColorFromStack();
            if (this.matrixCache.length > 0)
                this.matrixCache.pop();
        }
        translateTransform(x, y) {
            if (this.assembleData)
                return;
            this.pageStream.writeLine1('1 0 0 1 {0} {1} cm', this.convertToString(x), this.convertToString(y));
            if (this.matrixCache.length > 0)
                this.matrixCache.stimulsoft().peek().translate(x, y);
        }
        rotateTransform(angle) {
            if (this.assembleData)
                return;
            let AngleInRadians = angle * Math.PI / 180;
            this.pageStream.writeLine1('{0} {1} {2} {3} 0 0 cm', this.convertToString(Math.cos(AngleInRadians)), this.convertToString(Math.sin(AngleInRadians)), this.convertToString(-Math.sin(AngleInRadians)), this.convertToString(Math.cos(AngleInRadians)));
            if (this.matrixCache.length > 0)
                this.matrixCache.stimulsoft().peek().rotate(angle);
        }
        setClip(rect) {
            if (this.assembleData)
                return;
            this.pageStream.writeLine(this.getRectString(rect) + 'W n');
        }
        drawArc2(rect, p1, p2, pen) {
        }
        drawText(basePoint, text, charsOffset, font, textColor, angle, textAlign) {
        }
        setPixel(point, color) {
        }
        measureString(st, font) {
            return new SizeD(0, 0);
        }
        drawImage(img, rect) {
            let image = new StiImage();
            image.clientRectangle = rect;
            image.imageToDraw = img;
            image.smoothing = true;
            image.stretch = true;
            if (this.assembleData) {
                this.pdfService.storeImageDataForGeom(image);
                return;
            }
            let pp = new __.b.StiPdfData(this.pdfService);
            pp.Component = image;
            pp.Width = rect.width;
            pp.Height = rect.height;
            this.pageStream.writeLine('q');
            this.pdfService.pushColorToStack();
            this.pageStream.writeLine1('1 0 0 1 {0} {1} cm', this.convertToString(rect.x), this.convertToString(rect.y + rect.height));
            this.pageStream.writeLine('1 0 0 -1 0 0 cm');
            this.pdfService.renderImage(pp, 100);
            this.pageStream.writeLine('Q');
            this.pdfService.popColorFromStack();
        }
    };
}
let StiSparklinePainter = __.a.Painters.StiSparklinePainter;
let Graphics = Stimulsoft.System.Drawing.Graphics;
let StiContext = Stimulsoft.Base.Context.StiContext;
let StiContextPainter = Stimulsoft.Base.Context.StiContextPainter;
let StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
let StiPushTranslateTransformGeom = Stimulsoft.Base.Context.StiPushTranslateTransformGeom;
let StiPushRotateTransformGeom = Stimulsoft.Base.Context.StiPushRotateTransformGeom;
let StiPopTransformGeom = Stimulsoft.Base.Context.StiPopTransformGeom;
let StiBorderGeom = Stimulsoft.Base.Context.StiBorderGeom;
let StiLineGeom = Stimulsoft.Base.Context.StiLineGeom;
let StiLinesGeom = Stimulsoft.Base.Context.StiLinesGeom;
let StiPushClipGeom = Stimulsoft.Base.Context.StiPushClipGeom;
let StiPopClipGeom = Stimulsoft.Base.Context.StiPopClipGeom;
let StiPushSmothingModeToAntiAliasGeom = Stimulsoft.Base.Context.StiPushSmothingModeToAntiAliasGeom;
let StiPopSmothingModeGeom = Stimulsoft.Base.Context.StiPopSmothingModeGeom;
let StiPushTextRenderingHintToAntiAliasGeom = Stimulsoft.Base.Context.StiPushTextRenderingHintToAntiAliasGeom;
let StiPopTextRenderingHintGeom = Stimulsoft.Base.Context.StiPopTextRenderingHintGeom;
let StiCurveGeom = Stimulsoft.Base.Context.StiCurveGeom;
let StiEllipseGeom = Stimulsoft.Base.Context.StiEllipseGeom;
let StiCachedShadowGeom = Stimulsoft.Base.Context.StiCachedShadowGeom;
let StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
let StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
let StiTextGeom = Stimulsoft.Base.Context.StiTextGeom;
let StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
let StiPieSegmentGeom = Stimulsoft.Base.Context.StiPieSegmentGeom;
let StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
let StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
let StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
let StiCurveSegmentGeom = Stimulsoft.Base.Context.StiCurveSegmentGeom;
let StiCloseFigureSegmentGeom = Stimulsoft.Base.Context.StiCloseFigureSegmentGeom;
let Matrix = Stimulsoft.System.Drawing.Drawing2D.Matrix;
{
    __.b.StiPdfRenderChart = class {
        static renderChart(pp, assemble, pageNumber) {
            let chart = pp.Component.as(IStiChart);
            let scale = 0.96;
            let rectWidth = pp.service.report.unit.convertToHInches(pp.Component.width) * scale;
            let rectHeight = pp.service.report.unit.convertToHInches(pp.Component.height) * scale;
            let angle = 0;
            let deltaX = 0;
            let deltaY = 0;
            let scaleX = 1;
            let scaleY = 1;
            switch (chart.rotation) {
            case StiImageRotation.Rotate90CCW:
                angle = -90;
                deltaY = rectHeight;
                break;
            case StiImageRotation.Rotate90CW:
                angle = 90;
                deltaX = rectWidth;
                break;
            case StiImageRotation.Rotate180:
                angle = -180;
                deltaX = rectWidth;
                deltaY = rectHeight;
                break;
            case StiImageRotation.FlipVertical:
                scaleY = -1;
                deltaY = rectHeight;
                break;
            case StiImageRotation.FlipHorizontal:
                scaleX = -1;
                deltaX = rectWidth;
                break;
            }
            switch (chart.rotation) {
            case StiImageRotation.Rotate90CCW:
            case StiImageRotation.Rotate90CW: {
                    let temp = rectWidth;
                    rectWidth = rectHeight;
                    rectHeight = temp;
                    break;
                }
            }
            if (!assemble && chart.rotation != StiImageRotation.None) {
                let matrix2 = new Matrix(1, 0, 0, 1, 0, 0);
                matrix2.translate(deltaX, deltaY);
                matrix2.scale(scaleX, scaleY);
                matrix2.rotate(angle);
                pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} cm', pp.service.convertToString(matrix2.elements[0]), pp.service.convertToString(matrix2.elements[1]), pp.service.convertToString(matrix2.elements[2]), pp.service.convertToString(matrix2.elements[3]), pp.service.convertToString(matrix2.elements[4]), pp.service.convertToString(matrix2.elements[5]));
            }
            let painter = new StiContextPainter();
            let context = new StiContext(painter, true, false, false, 1);
            let storeIsAnimation = chart.isAnimation;
            chart.isAnimation = false;
            let chartGeom = chart.core.render(context, new Rectangle(0, 0, rectWidth, rectHeight), true);
            chartGeom.drawGeom(context);
            chart.isAnimation = storeIsAnimation;
            this.renderContext(pp, assemble, pageNumber, context);
        }
        static renderSparkline(pp, assemble, pageNumber) {
            let sparkline = pp.Component.as(StiSparkline);
            let scale = 0.96;
            let rectWidth = pp.service.report.unit.convertToHInches(pp.Component.width) * scale;
            let rectHeight = pp.service.report.unit.convertToHInches(pp.Component.height) * scale;
            let painter = new StiContextPainter();
            let context = new StiContext(painter, true, false, false, 1);
            StiSparklinePainter.renderSparkline(context, new Rectangle(0, 0, rectWidth, rectHeight), sparkline, 1);
            this.renderContext(pp, assemble, pageNumber, context);
        }
        static renderContext(pp, assemble, pageNumber, context) {
            var _a, _b, _c, _d;
            let matrix = new Matrix(1, 0, 0, 1, 0, 0);
            let chartScale = pp.service.hiToTwips / 0.96;
            matrix.translate(pp.X, pp.Y + pp.Height);
            matrix.scale(1, -1);
            matrix.scale(chartScale, chartScale);
            let pdfGeomWriter = new __.b.StiPdfGeomWriter(pp.service.pageStream, pp.service, assemble);
            pdfGeomWriter.pageNumber = pageNumber;
            pdfGeomWriter.matrixCache.push(matrix);
            for (let geom of context.geoms) {
                if (geom.is(StiPushTranslateTransformGeom)) {
                    let pushTranslateGeom = geom;
                    pdfGeomWriter.saveState();
                    pdfGeomWriter.translateTransform(pushTranslateGeom.x, pushTranslateGeom.y);
                }
                if (geom.is(StiPushRotateTransformGeom)) {
                    let pushRotateGeom = geom;
                    pdfGeomWriter.saveState();
                    pdfGeomWriter.rotateTransform(pushRotateGeom.angle);
                }
                if (geom.is(StiPopTransformGeom)) {
                    pdfGeomWriter.restoreState();
                }
                if (geom.is(StiPushClipGeom)) {
                    let clipGeom = geom;
                    pdfGeomWriter.saveState();
                    pdfGeomWriter.setClip(clipGeom.clipRectangle);
                }
                if (geom.is(StiPopClipGeom)) {
                    pdfGeomWriter.restoreState();
                }
                if (geom.is(StiPushSmothingModeToAntiAliasGeom)) {
                    pdfGeomWriter.saveState();
                }
                if (geom.is(StiPopSmothingModeGeom)) {
                    pdfGeomWriter.restoreState();
                }
                if (geom.is(StiPushTextRenderingHintToAntiAliasGeom)) {
                    pdfGeomWriter.saveState();
                }
                if (geom.is(StiPopTextRenderingHintGeom)) {
                    pdfGeomWriter.restoreState();
                }
                if (geom.is(StiBorderGeom)) {
                    let border = geom;
                    if (border.background != null) {
                        pdfGeomWriter.fillRectangle(this.rectToRectangle(border.rect), border.background);
                    }
                    if (this.checkPenGeom(border.borderPen)) {
                        pdfGeomWriter.drawRectangle(this.rectToRectangle(border.rect), border.borderPen);
                    }
                }
                if (geom.is(StiLineGeom)) {
                    let line = geom;
                    if (this.checkPenGeom(line.pen)) {
                        pdfGeomWriter.drawLine(new Point(line.x1, line.y1), new Point(line.x2, line.y2), line.pen);
                    }
                }
                if (geom.is(StiLinesGeom)) {
                    let lines = geom;
                    if (this.checkPenGeom(lines.pen)) {
                        pdfGeomWriter.drawPolyline(lines.points, lines.pen);
                    }
                }
                if (geom.is(StiCurveGeom)) {
                    let curve = geom;
                    if (this.checkPenGeom(curve.pen)) {
                        pdfGeomWriter.drawSpline(curve.points, curve.tension, curve.pen);
                    }
                }
                if (geom.is(StiEllipseGeom)) {
                    let ellipse = geom;
                    if (ellipse.background != null) {
                        pdfGeomWriter.fillEllipse(this.rectToRectangle(ellipse.rect), ellipse.background);
                    }
                    if (this.checkPenGeom(ellipse.borderPen)) {
                        pdfGeomWriter.drawEllipse(this.rectToRectangle(ellipse.rect), ellipse.borderPen);
                    }
                }
                if (geom.is(StiCachedShadowGeom)) {
                    let shadow = geom;
                    let rect = shadow.rect;
                    let sides = shadow.sides;
                    let yTop = rect.y + 8;
                    let xLeft = rect.x + 8;
                    let edgeOffset = (sides & StiShadowSides.Edge) > 0 ? 4 : 0;
                    if ((sides & StiShadowSides.Top) > 0) {
                        yTop = rect.y + 4;
                    }
                    if ((sides & StiShadowSides.Left) > 0) {
                        xLeft = rect.x + 4;
                    }
                    for (let index = 0; index < 3; index++) {
                        let pts = new Array();
                        if ((sides & StiShadowSides.Right) > 0) {
                            pts.push(new Point(rect.right, yTop));
                            if ((sides & StiShadowSides.Bottom) > 0) {
                                pts.push(new Point(rect.right, rect.bottom));
                                pts.push(new Point(xLeft, rect.bottom));
                                pts.push(new Point(xLeft, rect.bottom + index + 1));
                                pts.push(new Point(rect.right + index + 1, rect.bottom + index + 1));
                            } else {
                                pts.push(new Point(rect.right, rect.bottom + edgeOffset));
                                pts.push(new Point(rect.right + index + 1, rect.bottom + edgeOffset));
                            }
                            pts.push(new Point(rect.right + index + 1, yTop));
                        } else {
                            pts.push(new Point(xLeft, rect.bottom));
                            pts.push(new Point(rect.right + edgeOffset, rect.bottom));
                            pts.push(new Point(rect.right + edgeOffset, rect.bottom + index + 1));
                            pts.push(new Point(xLeft, rect.bottom + index + 1));
                        }
                        let shadowBrush = new StiSolidBrush(Color.fromArgb(40 - 10 * index, Color.black));
                        pdfGeomWriter.fillPolygon(pts, shadowBrush);
                    }
                }
                if (geom.is(StiTextGeom)) {
                    let text = geom;
                    let font = new Font(text.font.fontName, text.font.fontSize, text.font.fontStyle, text.font.unit);
                    let sf = new StringFormat();
                    sf.alignment = text.stringFormat.alignment;
                    sf.formatFlags = text.stringFormat.formatFlags;
                    sf.hotkeyPrefix = text.stringFormat.hotkeyPrefix;
                    sf.lineAlignment = text.stringFormat.lineAlignment;
                    sf.trimming = text.stringFormat.trimming;
                    let brush = this.brushToStiBrush(text.brush);
                    if (text.isRotatedText) {
                        let point = new Point();
                        if (text.location instanceof Point) {
                            point = text.location;
                        } else {
                            let rect2 = this.rectToRectangle(text.location);
                            point = new Point(rect2.x + rect2.width / 2, rect2.y + rect2.height / 2);
                        }
                        let textSize = Graphics.measureString(text.text, font, text.maximalWidth);
                        let textRect = new Rectangle(0, 0, textSize.width, textSize.height);
                        let startPoint = this.getStartPoint(text.rotationMode, textRect);
                        textRect.x -= startPoint.x;
                        textRect.y -= startPoint.y;
                        if (sf.alignment == Stimulsoft.System.Drawing.StringAlignment.Center)
                            textRect.x -= 1;
                        if (sf.alignment == Stimulsoft.System.Drawing.StringAlignment.Far)
                            textRect.x -= 2;
                        textRect.width += 2.5;
                        pdfGeomWriter.saveState();
                        pdfGeomWriter.translateTransform(point.x, point.y);
                        if (text.angle != 0)
                            pdfGeomWriter.rotateTransform(text.angle);
                        pdfGeomWriter.drawString(text.text, font, brush, textRect, sf);
                        pdfGeomWriter.restoreState();
                    } else {
                        pdfGeomWriter.drawString(text.text, font, brush, this.rectToRectangle(text.location), sf);
                    }
                }
                if (geom.is(StiPathGeom)) {
                    let path = geom;
                    pdfGeomWriter.beginPath();
                    for (let geom2 of path.geoms) {
                        if (geom2.is(StiPieSegmentGeom)) {
                            let pie = geom2;
                            let startAngle = (_a = pie.realStartAngle) !== null && _a !== void 0 ? _a : pie.startAngle;
                            let sweepAngle = (_b = pie.realSweepAngle) !== null && _b !== void 0 ? _b : pie.sweepAngle;
                            pdfGeomWriter.drawPie(pie.rect, startAngle, sweepAngle);
                        }
                        if (geom2.is(StiArcSegmentGeom)) {
                            let arc = geom2;
                            let startAngle = (_c = arc.realStartAngle) !== null && _c !== void 0 ? _c : arc.startAngle;
                            let sweepAngle = (_d = arc.realSweepAngle) !== null && _d !== void 0 ? _d : arc.sweepAngle;
                            pdfGeomWriter.drawArc(arc.rect, startAngle, sweepAngle);
                        }
                        if (geom2.is(StiLineSegmentGeom)) {
                            let linep = geom2;
                            pdfGeomWriter.drawLine(new Point(linep.x1, linep.y1), new Point(linep.x2, linep.y2), null);
                        }
                        if (geom2.is(StiLinesSegmentGeom)) {
                            let linesp = geom2;
                            pdfGeomWriter.drawPolyline(linesp.points, null);
                        }
                        if (geom2.is(StiCurveSegmentGeom)) {
                            let curvep = geom2;
                            pdfGeomWriter.drawSpline(curvep.points, curvep.tension, null);
                        }
                        if (geom2.is(StiCloseFigureSegmentGeom)) {
                            pdfGeomWriter.closeFigure();
                        }
                    }
                    pdfGeomWriter.closeFigure();
                    pdfGeomWriter.endPath();
                    if (path.background != null) {
                        pdfGeomWriter.fillPath(path.background);
                    }
                    if (this.checkPenGeom(path.pen)) {
                        pdfGeomWriter.strokePath(path.pen);
                    }
                }
            }
        }
        static getStartPoint(rotationMode, textRect) {
            let centerPoint = new Point(textRect.x + textRect.width / 2, textRect.y + textRect.height / 2);
            switch (rotationMode) {
            case StiRotationMode.LeftCenter:
                return new Point(textRect.x, centerPoint.y);
            case StiRotationMode.LeftBottom:
                return new Point(textRect.x, textRect.bottom);
            case StiRotationMode.CenterTop:
                return new Point(centerPoint.x, textRect.top);
            case StiRotationMode.CenterCenter:
                return centerPoint;
            case StiRotationMode.CenterBottom:
                return new Point(centerPoint.x, textRect.bottom);
            case StiRotationMode.RightTop:
                return new Point(textRect.right, textRect.top);
            case StiRotationMode.RightCenter:
                return new Point(textRect.right, centerPoint.y);
            case StiRotationMode.RightBottom:
                return new Point(textRect.right, textRect.bottom);
            default:
                return new Point(textRect.x, textRect.y);
            }
        }
        static rectToRectangle(rect) {
            if (rect == null)
                return new Rectangle();
            if (rect instanceof Rectangle)
                return rect;
            return new Rectangle();
        }
        static brushToStiBrush(brush) {
            if (brush == null)
                return null;
            if (brush instanceof Color) {
                return new StiSolidBrush(brush);
            } else {
                return brush;
            }
            return null;
        }
        static checkPenGeom(penGeom) {
            return !(penGeom == null || penGeom.brush == null || penGeom.penStyle == StiPenStyle.None);
        }
    };
}
let StiDataBarDirection = __.a.Components.StiDataBarDirection;
let ContentAlignment = Stimulsoft.System.Drawing.ContentAlignment;
{
    __.b.StiPdfRenderIndicators = class {
        static renderIndicators(pp) {
            let textComp = pp.Component.as(StiText);
            if (textComp == null || textComp.indicator == null)
                return pp;
            let rect = new Rectangle(pp.X, pp.Y, pp.Width, pp.Height);
            let iconSetIndicator = textComp.indicator.stimulsoft().as(StiIconSetIndicator);
            if (iconSetIndicator != null && (iconSetIndicator.icon != StiIcon.None || iconSetIndicator.customIcon != null)) {
                let pd = pp.service.imageList[pp.service.imagesCurrent];
                let imageWidth = pd.Width * pp.service.hiToTwips;
                let imageHeight = pd.Height * pp.service.hiToTwips;
                let iconRect = rect.clone();
                let cf = pp.service.hiToTwips;
                iconRect.inflate(-cf, -cf);
                switch (iconSetIndicator.alignment) {
                case ContentAlignment.TopLeft:
                    iconRect = new Rectangle(iconRect.x, iconRect.bottom - imageHeight, imageWidth, imageHeight);
                    rect.x += iconRect.width + 1;
                    rect.width -= iconRect.width + 1;
                    break;
                case ContentAlignment.TopCenter:
                    iconRect = new Rectangle(iconRect.x + (iconRect.width - imageWidth) / 2, iconRect.bottom - imageHeight, imageWidth, imageHeight);
                    break;
                case ContentAlignment.TopRight:
                    iconRect = new Rectangle(iconRect.right - imageWidth, iconRect.bottom - imageHeight, imageWidth, imageHeight);
                    rect.width -= iconRect.width + 1;
                    break;
                case ContentAlignment.MiddleLeft:
                    iconRect = new Rectangle(iconRect.x, iconRect.y + (iconRect.height - imageHeight) / 2, imageWidth, imageHeight);
                    rect.x += iconRect.width + 1;
                    rect.width -= iconRect.width + 1;
                    break;
                case ContentAlignment.MiddleCenter:
                    iconRect = new Rectangle(iconRect.x + (iconRect.width - imageWidth) / 2, iconRect.y + (iconRect.height - imageHeight) / 2, imageWidth, imageHeight);
                    break;
                case ContentAlignment.MiddleRight:
                    iconRect = new Rectangle(iconRect.right - imageWidth, iconRect.y + (iconRect.height - imageHeight) / 2, imageWidth, imageHeight);
                    rect.width -= iconRect.width + 1;
                    break;
                case ContentAlignment.BottomLeft:
                    iconRect = new Rectangle(iconRect.x, iconRect.y, imageWidth, imageHeight);
                    rect.x += iconRect.width + 1;
                    rect.width -= iconRect.width + 1;
                    break;
                case ContentAlignment.BottomCenter:
                    iconRect = new Rectangle(iconRect.x + (iconRect.width - imageWidth) / 2, iconRect.y, imageWidth, imageHeight);
                    break;
                case ContentAlignment.BottomRight:
                    iconRect = new Rectangle(iconRect.right - imageWidth, iconRect.y, imageWidth, imageHeight);
                    rect.width -= iconRect.width + 1;
                    break;
                }
                let pp2 = new __.b.StiPdfData(pp.service);
                pp2.X = iconRect.x;
                pp2.Y = iconRect.y;
                pp2.Width = iconRect.width;
                pp2.Height = iconRect.height;
                pp.service.writeImageInfo2(pp2, 1, 1);
            }
            let barIndicator = textComp.indicator.stimulsoft().as(StiDataBarIndicator);
            if (barIndicator != null && barIndicator.value != 0) {
                let barRect = rect.clone();
                let cf = pp.service.hiToTwips;
                barRect.inflate(-2 * cf, -2 * cf);
                let totalWidth = barIndicator.maximum + Math.abs(barIndicator.minimum);
                let minimumPart = barRect.width * Math.abs(barIndicator.minimum) / totalWidth;
                let maximumPart = barRect.width * barIndicator.maximum / totalWidth;
                let valuePart = barRect.width * Math.abs(barIndicator.value) / totalWidth;
                let direction = barIndicator.direction;
                if (direction == StiDataBarDirection.Default) {
                    if (textComp.textOptions != null && textComp.textOptions.rightToLeft)
                        direction = StiDataBarDirection.RighToLeft;
                    else
                        direction = StiDataBarDirection.LeftToRight;
                }
                let angle = 0;
                if (direction == StiDataBarDirection.LeftToRight) {
                    if (barIndicator.value < 0)
                        barRect.x += minimumPart - valuePart;
                    else
                        barRect.x += minimumPart;
                    barRect.width = valuePart;
                } else {
                    angle = 180;
                    if (barIndicator.value < 0)
                        barRect.x = barRect.right - minimumPart;
                    else
                        barRect.x = barRect.right - minimumPart - valuePart;
                    barRect.width = valuePart;
                }
                if (barIndicator.value < 0) {
                    angle += 180;
                }
                let hasGradient = false;
                if (barRect.width > 0 && barRect.height > 0) {
                    if (barIndicator.brushType == __.a.Components.StiBrushType.Gradient) {
                        let fillRect;
                        if (direction == StiDataBarDirection.LeftToRight) {
                            if (barIndicator.value > 0)
                                fillRect = new Rectangle(rect.left + minimumPart, rect.top, maximumPart, rect.height);
                            else
                                fillRect = new Rectangle(rect.left, rect.top, minimumPart, rect.height);
                        } else {
                            if (barIndicator.value < 0)
                                fillRect = new Rectangle(rect.left + maximumPart, rect.top, minimumPart, rect.height);
                            else
                                fillRect = new Rectangle(rect.left, rect.top, maximumPart, rect.height);
                        }
                        if (barRect.width > 0 && barRect.width < 1)
                            barRect.width = 1;
                        if (fillRect.width > 0 && fillRect.width < 1)
                            fillRect.width = 1;
                        if (fillRect.width > 0 && barRect.width > 0) {
                            let startColor = barIndicator.value < 0 ? barIndicator.negativeColor : barIndicator.positiveColor;
                            let endColor = StiColorUtils.light(startColor, 200);
                            fillRect.x -= fillRect.width * 0.1;
                            fillRect.width += fillRect.width * 0.2;
                            let brush = new StiGradientBrush(startColor, endColor, angle);
                            pp.service.fillRectBrush(brush, barRect);
                            let ssd = pp.service.shadingArray[pp.service.shadingCurrent - 1];
                            ssd.Angle = angle;
                            ssd.X = fillRect.x;
                            ssd.Y = fillRect.y;
                            ssd.Width = fillRect.width;
                            ssd.Height = fillRect.height;
                            ssd.FunctionIndex = pp.service.getShadingFunctionNumber(startColor, endColor, false);
                            pp.service.shadingArray[pp.service.shadingCurrent - 1] = ssd;
                            hasGradient = true;
                        }
                    } else {
                        let brush = new StiSolidBrush(barIndicator.value < 0 ? barIndicator.negativeColor : barIndicator.positiveColor);
                        pp.service.fillRectBrush(brush, barRect);
                    }
                    if (barIndicator.showBorder) {
                        pp.service.pageStream.writeLine('q');
                        pp.service.pushColorToStack();
                        pp.service.setStrokeColor(barIndicator.value < 0 ? barIndicator.negativeBorderColor : barIndicator.positiveBorderColor);
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} re S', pp.service.convertToString(barRect.x), pp.service.convertToString(barRect.y), pp.service.convertToString(barRect.width), pp.service.convertToString(barRect.height));
                        pp.service.pageStream.writeLine('Q');
                        pp.service.popColorFromStack();
                    }
                }
                if (!hasGradient && barIndicator.brushType == __.a.Components.StiBrushType.Gradient) {
                    pp.service.shadingCurrent++;
                }
            }
            let pp2 = new __.b.StiPdfData(pp.service);
            pp2.X = rect.x;
            pp2.Y = pp.Y;
            pp2.Width = rect.width;
            pp2.Height = pp.Height;
            pp2.Component = pp.Component;
            return pp2;
        }
    };
}
let StiBorderSide = Stimulsoft.Base.Drawing.StiBorderSide;
let StiVerticalLineShapeType = __.a.Components.StiVerticalLineShapeType;
let StiHorizontalLineShapeType = __.a.Components.StiHorizontalLineShapeType;
let StiTopAndBottomLineShapeType = __.a.Components.StiTopAndBottomLineShapeType;
let StiLeftAndRightLineShapeType = __.a.Components.StiLeftAndRightLineShapeType;
let StiRectangleShapeType = __.a.Components.StiRectangleShapeType;
let StiRoundedRectangleShapeType = __.a.Components.StiRoundedRectangleShapeType;
let StiDiagonalDownLineShapeType = __.a.Components.StiDiagonalDownLineShapeType;
let StiDiagonalUpLineShapeType = __.a.Components.StiDiagonalUpLineShapeType;
let StiTriangleShapeType = __.a.Components.StiTriangleShapeType;
let StiOvalShapeType = __.a.Components.StiOvalShapeType;
let StiArrowShapeType = __.a.Components.StiArrowShapeType;
let StiOctagonShapeType = __.a.Components.StiOctagonShapeType;
let StiComplexArrowShapeType = __.a.Components.StiComplexArrowShapeType;
let StiBentArrowShapeType = __.a.Components.StiBentArrowShapeType;
let StiChevronShapeType = __.a.Components.StiChevronShapeType;
let StiDivisionShapeType = __.a.Components.StiDivisionShapeType;
let StiEqualShapeType = __.a.Components.StiEqualShapeType;
let StiFlowchartCardShapeType = __.a.Components.StiFlowchartCardShapeType;
let StiFlowchartCollateShapeType = __.a.Components.StiFlowchartCollateShapeType;
let StiFlowchartDecisionShapeType = __.a.Components.StiFlowchartDecisionShapeType;
let StiFlowchartManualInputShapeType = __.a.Components.StiFlowchartManualInputShapeType;
let StiFlowchartOffPageConnectorShapeType = __.a.Components.StiFlowchartOffPageConnectorShapeType;
let StiFlowchartPreparationShapeType = __.a.Components.StiFlowchartPreparationShapeType;
let StiFlowchartSortShapeType = __.a.Components.StiFlowchartSortShapeType;
let StiFrameShapeType = __.a.Components.StiFrameShapeType;
let StiMinusShapeType = __.a.Components.StiMinusShapeType;
let StiMultiplyShapeType = __.a.Components.StiMultiplyShapeType;
let StiParallelogramShapeType = __.a.Components.StiParallelogramShapeType;
let StiPlusShapeType = __.a.Components.StiPlusShapeType;
let StiRegularPentagonShapeType = __.a.Components.StiRegularPentagonShapeType;
let StiTrapezoidShapeType = __.a.Components.StiTrapezoidShapeType;
let StiSnipSameSideCornerRectangleShapeType = __.a.Components.StiSnipSameSideCornerRectangleShapeType;
let StiSnipDiagonalSideCornerRectangleShapeType = __.a.Components.StiSnipDiagonalSideCornerRectangleShapeType;
let StiShapeDirection = __.a.Components.StiShapeDirection;
let StiCheckStyle = __.a.Components.StiCheckStyle;
let StiRoundedRectanglePrimitive = __.a.Components.StiRoundedRectanglePrimitive;
{
    __.b.StiPdfRenderPrimitives = class {
        static renderBorder1(pp) {
            let brush = null;
            let mBrush = pp.Component.as(IStiBrush);
            if (mBrush != null && mBrush.brush != null) {
                brush = mBrush.brush;
            }
            if (brush != null) {
                pp.service.fillRectBrush(brush, new Rectangle(pp.X, pp.Y, pp.Width, pp.Height));
            }
        }
        static renderBorder2(pp) {
            let mBorder = pp.Component.as(IStiBorder);
            if (mBorder != null) {
                let tempColor = Color.transparent;
                if (mBorder.border.dropShadow && mBorder.border.shadowBrush != null) {
                    tempColor = StiBrush.toColor(mBorder.border.shadowBrush);
                    if (tempColor.a != 0) {
                        let shadowSize = mBorder.border.shadowSize * 0.8;
                        pp.service.setNonStrokeColor(tempColor);
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} re f', pp.service.convertToString(pp.X + shadowSize), pp.service.convertToString(pp.Y - shadowSize), pp.service.convertToString(pp.Width - shadowSize), pp.service.convertToString(shadowSize));
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} re f', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y - shadowSize), pp.service.convertToString(shadowSize), pp.service.convertToString(pp.Height));
                    }
                }
                let border = new StiBorderSide(mBorder.border.color, mBorder.border.size, mBorder.border.style);
                let advBorder = mBorder.border.stimulsoft().as(StiAdvancedBorder);
                let useAdvBorder = advBorder != null;
                let needBorderLeft = mBorder.border.isLeftBorderSidePresent;
                let needBorderRight = mBorder.border.isRightBorderSidePresent;
                let needBorderTop = mBorder.border.isTopBorderSidePresent;
                let needBorderBottom = mBorder.border.isBottomBorderSidePresent;
                let needPush = mBorder.border.style != StiPenStyle.None && mBorder.border.style != StiPenStyle.Solid;
                let needDraw = mBorder.border.side != StiBorderSides.None && mBorder.border.style != StiPenStyle.None;
                if (useAdvBorder) {
                    needDraw = advBorder.side != StiBorderSides.None;
                }
                if (needDraw) {
                    let offset = 0;
                    if (!useAdvBorder) {
                        if (needPush) {
                            pp.service.pageStream.writeLine('q');
                            pp.service.pushColorToStack();
                        }
                        offset = this.storeBorderSideData(border, pp);
                    }
                    if (!useAdvBorder && mBorder.border.side == StiBorderSides.All) {
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} re S', pp.service.convertToString(pp.X - offset), pp.service.convertToString(pp.Y - offset), pp.service.convertToString(pp.Width + offset * 2), pp.service.convertToString(pp.Height + offset * 2));
                        if (mBorder.border.style == StiPenStyle.Double) {
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} re S', pp.service.convertToString(pp.X + offset), pp.service.convertToString(pp.Y + offset), pp.service.convertToString(pp.Width - offset * 2), pp.service.convertToString(pp.Height - offset * 2));
                        }
                    } else {
                        if (needBorderLeft) {
                            if (useAdvBorder) {
                                border = advBorder.leftSide;
                                if (border.style != StiPenStyle.Solid) {
                                    pp.service.pageStream.writeLine('q');
                                    pp.service.pushColorToStack();
                                }
                                offset = this.storeBorderSideData(border, pp);
                            }
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X - offset), pp.service.convertToString(pp.Y - offset));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X - offset), pp.service.convertToString(pp.Y + pp.Height + offset));
                            if (border.style == StiPenStyle.Double) {
                                pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + offset), pp.service.convertToString(pp.Y + (needBorderBottom ? offset : -offset)));
                                pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + offset), pp.service.convertToString(pp.Y + pp.Height + (needBorderTop ? -offset : offset)));
                            }
                            if (useAdvBorder && border.style != StiPenStyle.Solid) {
                                pp.service.pageStream.writeLine('Q');
                                pp.service.popColorFromStack();
                            }
                        }
                        if (needBorderRight) {
                            if (useAdvBorder) {
                                border = advBorder.rightSide;
                                if (border.style != StiPenStyle.Solid) {
                                    pp.service.pageStream.writeLine('q');
                                    pp.service.pushColorToStack();
                                }
                                offset = this.storeBorderSideData(border, pp);
                            }
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + pp.Width + offset), pp.service.convertToString(pp.Y - offset));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width + offset), pp.service.convertToString(pp.Y + pp.Height + offset));
                            if (border.style == StiPenStyle.Double) {
                                pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + pp.Width - offset), pp.service.convertToString(pp.Y + (needBorderBottom ? offset : -offset)));
                                pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width - offset), pp.service.convertToString(pp.Y + pp.Height + (needBorderTop ? -offset : offset)));
                            }
                            if (useAdvBorder && border.style != StiPenStyle.Solid) {
                                pp.service.pageStream.writeLine('Q');
                                pp.service.popColorFromStack();
                            }
                        }
                        if (needBorderTop) {
                            if (useAdvBorder) {
                                border = advBorder.topSide;
                                if (border.style != StiPenStyle.Solid) {
                                    pp.service.pageStream.writeLine('q');
                                    pp.service.pushColorToStack();
                                }
                                offset = this.storeBorderSideData(border, pp);
                            }
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X - offset), pp.service.convertToString(pp.Y + pp.Height + offset));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width + offset), pp.service.convertToString(pp.Y + pp.Height + offset));
                            if (border.style == StiPenStyle.Double) {
                                pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + (needBorderLeft ? offset : -offset)), pp.service.convertToString(pp.Y + pp.Height - offset));
                                pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width + (needBorderRight ? -offset : offset)), pp.service.convertToString(pp.Y + pp.Height - offset));
                            }
                            if (useAdvBorder && border.style != StiPenStyle.Solid) {
                                pp.service.pageStream.writeLine('Q');
                                pp.service.popColorFromStack();
                            }
                        }
                        if (needBorderBottom) {
                            if (useAdvBorder) {
                                border = advBorder.bottomSide;
                                if (border.style != StiPenStyle.Solid) {
                                    pp.service.pageStream.writeLine('q');
                                    pp.service.pushColorToStack();
                                }
                                offset = this.storeBorderSideData(border, pp);
                            }
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X - offset), pp.service.convertToString(pp.Y - offset));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width + offset), pp.service.convertToString(pp.Y - offset));
                            if (border.style == StiPenStyle.Double) {
                                pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + (needBorderLeft ? offset : -offset)), pp.service.convertToString(pp.Y + offset));
                                pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width + (needBorderRight ? -offset : offset)), pp.service.convertToString(pp.Y + offset));
                            }
                            if (useAdvBorder && border.style != StiPenStyle.Solid) {
                                pp.service.pageStream.writeLine('Q');
                                pp.service.popColorFromStack();
                            }
                        }
                    }
                    if (!useAdvBorder && needPush) {
                        pp.service.pageStream.writeLine('Q');
                        pp.service.popColorFromStack();
                    }
                }
            }
        }
        static storeBorderSideData(border, pp) {
            let borderSizeHi = border.size;
            if (borderSizeHi < 1)
                borderSizeHi = 1;
            if (border.style == StiPenStyle.Double)
                borderSizeHi = 1;
            let borderSize = borderSizeHi * pp.service.hiToTwips * 0.955;
            pp.service.pageStream.writeLine1('{0} w', pp.service.convertToString(borderSize));
            let dash = this.getPenStyleDashString(border.style, borderSize * 0.04, pp);
            if (dash != null) {
                pp.service.pageStream.writeLine(dash);
            }
            pp.service.setStrokeColor(border.color);
            return border.style == StiPenStyle.Double ? borderSize : 0;
        }
        static getPenStyleDashString(style, step, pp) {
            switch (style) {
            case StiPenStyle.Dot:
                return StiString.format('[{0} {1}] 0 d', pp.service.convertToString(step), pp.service.convertToString(step * 58));
            case StiPenStyle.Dash:
                return StiString.format('[{0} {1}] 0 d', pp.service.convertToString(step * 49.5), pp.service.convertToString(step * 62));
            case StiPenStyle.DashDot:
                return StiString.format('[{0} {1} {2} {1}] 0 d', pp.service.convertToString(step * 50), pp.service.convertToString(step * 55), pp.service.convertToString(step));
            case StiPenStyle.DashDotDot:
                return StiString.format('[{0} {1} {2} {1} {2} {1}] 0 d', pp.service.convertToString(step * 50), pp.service.convertToString(step * 55), pp.service.convertToString(step));
            }
            return null;
        }
        static checkShape(shape) {
            if (shape.shapeType.is2(StiVerticalLineShapeType) || shape.shapeType.is2(StiHorizontalLineShapeType) || shape.shapeType.is2(StiTopAndBottomLineShapeType) || shape.shapeType.is2(StiLeftAndRightLineShapeType) || shape.shapeType.is2(StiRectangleShapeType) || shape.shapeType.is2(StiRoundedRectangleShapeType) || shape.shapeType.is2(StiDiagonalDownLineShapeType) || shape.shapeType.is2(StiDiagonalUpLineShapeType) || shape.shapeType.is2(StiTriangleShapeType) || shape.shapeType.is2(StiOvalShapeType) || shape.shapeType.is2(StiArrowShapeType) || shape.shapeType.is2(StiOctagonShapeType) || shape.shapeType.is2(StiComplexArrowShapeType) || shape.shapeType.is2(StiBentArrowShapeType) || shape.shapeType.is2(StiChevronShapeType) || shape.shapeType.is2(StiDivisionShapeType) || shape.shapeType.is2(StiEqualShapeType) || shape.shapeType.is2(StiFlowchartCardShapeType) || shape.shapeType.is2(StiFlowchartCollateShapeType) || shape.shapeType.is2(StiFlowchartDecisionShapeType) || shape.shapeType.is2(StiFlowchartManualInputShapeType) || shape.shapeType.is2(StiFlowchartOffPageConnectorShapeType) || shape.shapeType.is2(StiFlowchartPreparationShapeType) || shape.shapeType.is2(StiFlowchartSortShapeType) || shape.shapeType.is2(StiFrameShapeType) || shape.shapeType.is2(StiMinusShapeType) || shape.shapeType.is2(StiMultiplyShapeType) || shape.shapeType.is2(StiParallelogramShapeType) || shape.shapeType.is2(StiPlusShapeType) || shape.shapeType.is2(StiRegularPentagonShapeType) || shape.shapeType.is2(StiTrapezoidShapeType) || shape.shapeType.is2(StiSnipSameSideCornerRectangleShapeType) || shape.shapeType.is2(StiSnipDiagonalSideCornerRectangleShapeType)) {
                return true;
            }
            return false;
        }
        static renderShape(pp, imageResolution) {
            let shape = pp.Component.as(StiShape);
            if (shape != null) {
                if (this.checkShape(shape) == true) {
                    let mBrush = pp.Component.as(IStiBrush);
                    let geomWriter = new __.b.StiPdfGeomWriter(pp.service.pageStream, pp.service, false);
                    let tempColor = Color.transparent;
                    if (mBrush != null)
                        tempColor = StiBrush.toColor(mBrush.brush);
                    if (tempColor.a != 0) {
                        pp.service.setNonStrokeColor(tempColor);
                    }
                    if (mBrush != null) {
                        if (mBrush.brush.is(StiGradientBrush) || mBrush.brush.is(StiGlareBrush)) {
                            pp.service.storeShadingData2(pp.X, pp.Y, pp.Width, pp.Height, mBrush.brush);
                            pp.service.pageStream.writeLine1('/Pattern cs /P{0} scn', 1 + pp.service.shadingCurrent);
                        }
                        if (mBrush.brush.is(StiHatchBrush)) {
                            let hBrush = mBrush.brush;
                            pp.service.pageStream.writeLine1('/Cs1 cs /PH{0} scn', pp.service.getHatchNumber(hBrush) + 1);
                        }
                    }
                    let tempColor2 = shape.borderColor;
                    pp.service.setStrokeColor(tempColor2);
                    let needFill = tempColor.a > 0;
                    let needStroke = shape.style != StiPenStyle.None;
                    if (!needFill && !needStroke)
                        return;
                    let st = needFill ? needStroke ? 'B' : 'f' : needStroke ? 'S' : 'n';
                    pp.service.pageStream.writeLine1('{0} w', pp.service.convertToString(shape.size * pp.service.hiToTwips));
                    pp.service.pageStream.writeLine('q');
                    let step = shape.size * pp.service.hiToTwips * 0.04;
                    switch (shape.style) {
                    case StiPenStyle.Dot:
                        pp.service.pageStream.writeLine1('[{0} {1}] 0 d', pp.service.convertToString(step), pp.service.convertToString(step * 55));
                        break;
                    case StiPenStyle.Dash:
                        pp.service.pageStream.writeLine1('[{0} {1}] 0 d', pp.service.convertToString(step * 50), pp.service.convertToString(step * 55));
                        break;
                    case StiPenStyle.DashDot:
                        pp.service.pageStream.writeLine1('[{0} {1} {2} {1}] 0 d', pp.service.convertToString(step * 50), pp.service.convertToString(step * 55), pp.service.convertToString(step));
                        break;
                    case StiPenStyle.DashDotDot:
                        pp.service.pageStream.writeLine1('[{0} {1} {2} {1} {2} {1}] 0 d', pp.service.convertToString(step * 50), pp.service.convertToString(step * 55), pp.service.convertToString(step));
                        break;
                    }
                    if (shape.shapeType.is(StiVerticalLineShapeType)) {
                        if (needFill) {
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} re f', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.Width), pp.service.convertToString(pp.Height));
                        }
                        if (needStroke) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + pp.Height));
                        }
                    }
                    if (shape.shapeType.is(StiHorizontalLineShapeType)) {
                        if (needFill) {
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} re f', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.Width), pp.service.convertToString(pp.Height));
                        }
                        if (needStroke) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height / 2));
                        }
                    }
                    if (shape.shapeType.is(StiTopAndBottomLineShapeType)) {
                        if (needFill) {
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} re f', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.Width), pp.service.convertToString(pp.Height));
                        }
                        if (needStroke) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y));
                        }
                    }
                    if (shape.shapeType.is(StiLeftAndRightLineShapeType)) {
                        if (needFill) {
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} re f', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.Width), pp.service.convertToString(pp.Height));
                        }
                        if (needStroke) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height));
                        }
                    }
                    if (shape.shapeType.is(StiRectangleShapeType)) {
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y));
                        pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                    }
                    if (shape.shapeType.is(StiDiagonalDownLineShapeType)) {
                        if (needFill) {
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} re f', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.Width), pp.service.convertToString(pp.Height));
                        }
                        if (needStroke) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y));
                        }
                    }
                    if (shape.shapeType.is(StiDiagonalUpLineShapeType)) {
                        if (needFill) {
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} re f', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.Width), pp.service.convertToString(pp.Height));
                        }
                        if (needStroke) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height));
                        }
                    }
                    if (shape.shapeType.is(StiTriangleShapeType)) {
                        let ssd = shape.shapeType.direction;
                        if (ssd == StiShapeDirection.Up) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                        }
                        if (ssd == StiShapeDirection.Down) {
                            if (needFill)
                                st = needStroke ? 'B*' : 'f*';
                            else
                                st = needStroke ? 'S' : 'n';
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height));
                        }
                        if (ssd == StiShapeDirection.Left) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y));
                        }
                        if (ssd == StiShapeDirection.Right) {
                            if (needFill)
                                st = needStroke ? 'B*' : 'f*';
                            else
                                st = needStroke ? 'S' : 'n';
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                        }
                    }
                    if (shape.shapeType.is(StiOvalShapeType)) {
                        pp.service.pageStream.writeLine1(geomWriter.getEllipseString(new Rectangle(pp.X, pp.Y, pp.Width, pp.Height)) + st);
                    }
                    if (shape.shapeType.is(StiRoundedRectangleShapeType)) {
                        let rnd = shape.shapeType.round;
                        let side = pp.Width;
                        if (side > pp.Height)
                            side = pp.Height;
                        let offs = Math.min(side, 70) * rnd;
                        let tmp = offs * (1 - pp.service.pdfCKT);
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + offs));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height - offs));
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height - tmp), pp.service.convertToString(pp.X + tmp), pp.service.convertToString(pp.Y + pp.Height), pp.service.convertToString(pp.X + offs), pp.service.convertToString(pp.Y + pp.Height));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - offs), pp.service.convertToString(pp.Y + pp.Height));
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(pp.X + pp.Width - tmp), pp.service.convertToString(pp.Y + pp.Height), pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height - tmp), pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height - offs));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + offs));
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + tmp), pp.service.convertToString(pp.X + pp.Width - tmp), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + pp.Width - offs), pp.service.convertToString(pp.Y));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + offs), pp.service.convertToString(pp.Y));
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c ' + st, pp.service.convertToString(pp.X + tmp), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + tmp), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + offs));
                    }
                    if (shape.shapeType.is(StiArrowShapeType)) {
                        let ssd = shape.shapeType.direction;
                        let arrowW = shape.shapeType.arrowWidth;
                        let arrowH = shape.shapeType.arrowHeight;
                        let arw = pp.Width * arrowW;
                        let arh = pp.Height * arrowH;
                        if (ssd == StiShapeDirection.Left || ssd == StiShapeDirection.Right) {
                            arw = pp.Height * arrowW;
                            arh = pp.Width * arrowH;
                        }
                        if (arrowH == 0)
                            arh = Math.min(pp.Width / 2, pp.Height / 2);
                        if (ssd == StiShapeDirection.Up) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + arw), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arw), pp.service.convertToString(pp.Y + pp.Height - arh));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height - arh));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height - arh));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - arw), pp.service.convertToString(pp.Y + pp.Height - arh));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - arw), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X + arw), pp.service.convertToString(pp.Y));
                        }
                        if (ssd == StiShapeDirection.Down) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + pp.Width - arw), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - arw), pp.service.convertToString(pp.Y + arh));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + arh));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + arh));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arw), pp.service.convertToString(pp.Y + arh));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arw), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X + pp.Width - arw), pp.service.convertToString(pp.Y + pp.Height));
                        }
                        if (ssd == StiShapeDirection.Left) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + arw));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arh), pp.service.convertToString(pp.Y + arw));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arh), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arh), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arh), pp.service.convertToString(pp.Y + pp.Height - arw));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height - arw));
                            pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + arw));
                        }
                        if (ssd == StiShapeDirection.Right) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height - arw));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - arh), pp.service.convertToString(pp.Y + pp.Height - arw));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - arh), pp.service.convertToString(pp.Y + pp.Height));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - arh), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - arh), pp.service.convertToString(pp.Y + arw));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + arw));
                            pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height - arw));
                        }
                    }
                    if (shape.shapeType.is(StiOctagonShapeType)) {
                        let octagonShape = shape.shapeType;
                        let bevelx = (shape.report != null ? shape.report.unit.convertToHInches(octagonShape.bevel) : octagonShape.bevel) * pp.service.hiToTwips;
                        let bevely = bevelx;
                        if (octagonShape.autoSize) {
                            bevelx = pp.Width / (2.414 * 1.414);
                            bevely = pp.Height / (2.414 * 1.414);
                        }
                        if (bevelx > pp.Width / 2)
                            bevelx = pp.Width / 2;
                        if (bevely > pp.Height / 2)
                            bevely = pp.Height / 2;
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + bevelx), pp.service.convertToString(pp.Y));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - bevelx), pp.service.convertToString(pp.Y));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + bevely));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width), pp.service.convertToString(pp.Y + pp.Height - bevely));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width - bevelx), pp.service.convertToString(pp.Y + pp.Height));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + bevelx), pp.service.convertToString(pp.Y + pp.Height));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height - bevely));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + bevely));
                        pp.service.pageStream.writeLine1('{0} {1} l ' + st, pp.service.convertToString(pp.X + bevelx), pp.service.convertToString(pp.Y));
                    }
                    if (shape.shapeType.is(StiComplexArrowShapeType)) {
                        let restHeight = pp.Width < pp.Height ? pp.Width / 2 : pp.Height / 2;
                        let topBottomSpace = pp.Height / 3.8;
                        let leftRightSpace = pp.Width / 3.8;
                        let restWidth = pp.Height < pp.Width ? pp.Height / 2 : pp.Width / 2;
                        switch (shape.shapeType.direction) {
                        case StiShapeDirection.Left:
                        case StiShapeDirection.Right:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + restHeight), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + restHeight), pp.service.convertToString(pp.Y + topBottomSpace));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - restHeight), pp.service.convertToString(pp.Y + topBottomSpace));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - restHeight), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y + pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - restHeight), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - restHeight), pp.service.convertToString(pp.Top - topBottomSpace));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + restHeight), pp.service.convertToString(pp.Top - topBottomSpace));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + restHeight), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + pp.Height / 2));
                            break;
                        case StiShapeDirection.Down:
                        case StiShapeDirection.Up:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + restWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y + restWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - leftRightSpace), pp.service.convertToString(pp.Y + restWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - leftRightSpace), pp.service.convertToString(pp.Top - restWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - restWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - restWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + leftRightSpace), pp.service.convertToString(pp.Top - restWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + leftRightSpace), pp.service.convertToString(pp.Y + restWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + restWidth));
                            break;
                        }
                    }
                    if (shape.shapeType.is(StiBentArrowShapeType)) {
                        let lineHeight = 0;
                        let arrowWidth = 0;
                        let space = 0;
                        if (pp.Height > pp.Width) {
                            arrowWidth = pp.Width / 4;
                            lineHeight = arrowWidth;
                            space = arrowWidth / 2;
                        } else {
                            lineHeight = Math.floor(pp.Height / 4);
                            arrowWidth = lineHeight;
                            space = arrowWidth / 2;
                        }
                        switch (shape.shapeType.direction) {
                        case StiShapeDirection.Up:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + lineHeight));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - (space + lineHeight)), pp.service.convertToString(pp.Y + lineHeight));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - (space + lineHeight)), pp.service.convertToString(pp.Top - arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - arrowWidth * 2), pp.service.convertToString(pp.Top - arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - arrowWidth), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - space), pp.service.convertToString(pp.Top - arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - space), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            break;
                        case StiShapeDirection.Left:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - space));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arrowWidth), pp.service.convertToString(pp.Top - space));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arrowWidth), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arrowWidth), pp.service.convertToString(pp.Top - arrowWidth * 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arrowWidth), pp.service.convertToString(pp.Top - arrowWidth - space));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - lineHeight), pp.service.convertToString(pp.Top - arrowWidth - space));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - lineHeight), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y));
                            break;
                        case StiShapeDirection.Down:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + space), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + space), pp.service.convertToString(pp.Y + arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arrowWidth), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arrowWidth * 2), pp.service.convertToString(pp.Y + arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arrowWidth + space), pp.service.convertToString(pp.Y + arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + arrowWidth + space), pp.service.convertToString(pp.Top - lineHeight));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - lineHeight));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top));
                            break;
                        case StiShapeDirection.Right:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + space));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - arrowWidth), pp.service.convertToString(pp.Y + space));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - arrowWidth), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y + arrowWidth));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - arrowWidth), pp.service.convertToString(pp.Y + arrowWidth * 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - arrowWidth), pp.service.convertToString(pp.Y + arrowWidth + space));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + lineHeight), pp.service.convertToString(pp.Y + arrowWidth + space));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + lineHeight), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top));
                            break;
                        }
                    }
                    if (shape.shapeType.is(StiChevronShapeType)) {
                        let rest = pp.Width > pp.Height ? pp.Height / 2 : pp.Width / 2;
                        switch (shape.shapeType.direction) {
                        case StiShapeDirection.Right:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + rest), pp.service.convertToString(pp.Top - pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - rest), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - rest), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top));
                            break;
                        case StiShapeDirection.Left:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + rest), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + rest), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right - rest), pp.service.convertToString(pp.Top - pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top));
                            break;
                        case StiShapeDirection.Up:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - rest));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - rest));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + rest));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - rest));
                            break;
                        case StiShapeDirection.Down:
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Top - rest));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y + rest));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + rest));
                            pp.service.pageStream.writeLine1('{0} {1} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top));
                            break;
                        }
                    }
                    if (shape.shapeType.is(StiDivisionShapeType)) {
                        let restHeight = pp.Height / 3;
                        let offset = 4 * pp.service.hiToTwips;
                        pp.service.pageStream.writeLine1(geomWriter.getRectString4(pp.X, pp.Y + restHeight + offset, pp.Width, restHeight - offset * 2) + st);
                        pp.service.pageStream.writeLine1(geomWriter.getEllipseString4(pp.X + pp.Width / 2 - restHeight / 2, pp.Top - pp.service.hiToTwips - restHeight, restHeight, restHeight) + st);
                        pp.service.pageStream.writeLine1(geomWriter.getEllipseString4(pp.X + pp.Width / 2 - restHeight / 2, pp.Y + 2 * pp.service.hiToTwips, restHeight, restHeight) + st);
                    }
                    if (shape.shapeType.is(StiEqualShapeType)) {
                        let height = (pp.Height - pp.Height / 6) / 2;
                        pp.service.pageStream.writeLine1(geomWriter.getRectString4(pp.X, pp.Top - height, pp.Width, height) + st);
                        pp.service.pageStream.writeLine1(geomWriter.getRectString4(pp.X, pp.Y, pp.Width, height) + st);
                    }
                    if (shape.shapeType.is(StiFlowchartCardShapeType)) {
                        pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l', pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - pp.Height / 5), pp.service.convertToString(pp.X + pp.Width / 5), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top));
                    }
                    if (shape.shapeType.is(StiFlowchartCollateShapeType)) {
                        switch (shape.shapeType.direction) {
                        case StiShapeDirection.Down:
                        case StiShapeDirection.Up:
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + pp.Height / 2), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y));
                            break;
                        case StiShapeDirection.Left:
                        case StiShapeDirection.Right:
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + pp.Height / 2));
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + pp.Height / 2), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top));
                            break;
                        }
                    }
                    if (shape.shapeType.is(StiFlowchartDecisionShapeType)) {
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - pp.Height / 2));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - pp.Height / 2), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - pp.Height / 2));
                    }
                    if (shape.shapeType.is(StiFlowchartManualInputShapeType)) {
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - pp.Height / 5));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - pp.Height / 5));
                    }
                    if (shape.shapeType.is(StiFlowchartOffPageConnectorShapeType)) {
                        let restHeight = pp.Height / 5;
                        let restWidth = pp.Width / 5;
                        switch (shape.shapeType.direction) {
                        case StiShapeDirection.Down:
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y + restHeight), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + restHeight), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top));
                            break;
                        case StiShapeDirection.Up:
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - restHeight));
                            pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                            break;
                        case StiShapeDirection.Left:
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l', pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - pp.Height / 2), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top));
                            break;
                        case StiShapeDirection.Right:
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - pp.Height / 2), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top));
                            break;
                        }
                    }
                    if (shape.shapeType.is(StiFlowchartPreparationShapeType)) {
                        let restWidth = pp.Width / 5;
                        let restHeight = pp.Height / 5;
                        let xCenter = pp.Width / 2;
                        let yCenter = pp.Height / 2;
                        switch (shape.shapeType.direction) {
                        case StiShapeDirection.Left:
                        case StiShapeDirection.Right:
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - yCenter), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Top));
                            pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - yCenter), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - yCenter));
                            break;
                        case StiShapeDirection.Down:
                        case StiShapeDirection.Up:
                            pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l', pp.service.convertToString(pp.X + xCenter), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y + restHeight));
                            pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.X + xCenter), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + restHeight), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.X + xCenter), pp.service.convertToString(pp.Top));
                            break;
                        }
                    }
                    if (shape.shapeType.is(StiFlowchartSortShapeType)) {
                        pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - pp.Height / 2), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Top));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - pp.Height / 2), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - pp.Height / 2), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - pp.Height / 2));
                    }
                    if (shape.shapeType.is(StiFrameShapeType)) {
                        let restWidth = pp.Width / 7;
                        let restHeight = pp.Height / 7;
                        pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l {6} {7} l h', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                        pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Y + restHeight), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Y + restHeight), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Top - restHeight));
                    }
                    if (shape.shapeType.is(StiMinusShapeType)) {
                        let restHeight = pp.Height / 3;
                        pp.service.pageStream.writeLine1(geomWriter.getRectString4(pp.X, pp.Y + restHeight, pp.Width, restHeight) + st);
                    }
                    if (shape.shapeType.is(StiMultiplyShapeType)) {
                        let restWidth = pp.Width / 4;
                        let restHeight = pp.Height / 4;
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - restHeight));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l', pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - restHeight));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l', pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Top - pp.Height / 2), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y + restHeight), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + restHeight));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l h ' + st, pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + restHeight), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top - pp.Height / 2));
                    }
                    if (shape.shapeType.is(StiParallelogramShapeType)) {
                        pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + pp.Width / 5), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right - pp.Width / 5), pp.service.convertToString(pp.Y));
                    }
                    if (shape.shapeType.is(StiPlusShapeType)) {
                        let restWidth = pp.Width / 3;
                        let restHeight = pp.Height / 3;
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l', pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y + restHeight));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l', pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Y + restHeight), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Y + restHeight));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + restHeight), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top));
                    }
                    if (shape.shapeType.is(StiRegularPentagonShapeType)) {
                        let restTop = pp.Height / 2.6;
                        let restLeft = pp.Width / 5.5;
                        pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - restTop), pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Top));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - restTop), pp.service.convertToString(pp.Right - restLeft), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + restLeft), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - restTop));
                    }
                    if (shape.shapeType.is(StiTrapezoidShapeType)) {
                        let rest = pp.Width / 4.75;
                        pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l {6} {7} l h ' + st, pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + rest), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right - rest), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y));
                    }
                    if (shape.shapeType.is(StiSnipSameSideCornerRectangleShapeType)) {
                        let restWidth = pp.Width / 7.2;
                        let restHeight = pp.Height / 4.6;
                        pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Top));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - restHeight), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y));
                    }
                    if (shape.shapeType.is(StiSnipDiagonalSideCornerRectangleShapeType)) {
                        let restWidth = pp.Width / 7.2;
                        let restHeight = pp.Height / 4.6;
                        pp.service.pageStream.writeLine1('{0} {1} m {2} {3} l {4} {5} l', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right - restWidth), pp.service.convertToString(pp.Top), pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Top - restHeight));
                        pp.service.pageStream.writeLine1('{0} {1} l {2} {3} l {4} {5} l h ' + st, pp.service.convertToString(pp.Right), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X + restWidth), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y + restHeight));
                    }
                    pp.service.pageStream.writeLine('Q');
                } else {
                }
            }
        }
        static renderRoundedRectanglePrimitive(pp) {
            let mBorder = pp.Component.as(IStiBorder);
            if (mBorder != null) {
                let border = new StiBorderSide(mBorder.border.color, mBorder.border.size, mBorder.border.style);
                let primitive = pp.Component.as(StiRoundedRectanglePrimitive);
                if (primitive.style == StiPenStyle.None)
                    return;
                let needPush = mBorder.border.style != StiPenStyle.None && mBorder.border.style != StiPenStyle.Solid;
                if (needPush) {
                    pp.service.pageStream.writeLine('q');
                    pp.service.pushColorToStack();
                }
                let offset = this.storeBorderSideData(border, pp);
                let roundOffset = Math.min(pp.Width < pp.Height ? pp.Width : pp.Height, 100 * pp.Component.page.zoom) * primitive.round;
                let roundOffset2 = roundOffset * (1 - pp.service.pdfCKT);
                let x1 = pp.X - offset;
                let x2 = pp.X + pp.Width + offset;
                let xc = pp.X + pp.Width / 2;
                let y1 = pp.Y - offset;
                let y2 = pp.Y + pp.Height + offset;
                if (primitive.leftSide) {
                    if (primitive.bottomSide) {
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(primitive.rightSide ? xc : x2), pp.service.convertToString(y1));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(x1 + roundOffset), pp.service.convertToString(y1));
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(x1 + roundOffset2), pp.service.convertToString(y1), pp.service.convertToString(x1), pp.service.convertToString(y1 + roundOffset2), pp.service.convertToString(x1), pp.service.convertToString(y1 + roundOffset));
                    } else {
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(x1), pp.service.convertToString(y1));
                    }
                    if (primitive.topSide) {
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(x1), pp.service.convertToString(y2 - roundOffset));
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(x1), pp.service.convertToString(y2 - roundOffset2), pp.service.convertToString(x1 + roundOffset2), pp.service.convertToString(y2), pp.service.convertToString(x1 + roundOffset), pp.service.convertToString(y2));
                        pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(primitive.rightSide ? xc : x2), pp.service.convertToString(y2));
                    } else {
                        pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(x1), pp.service.convertToString(y2));
                    }
                }
                if (primitive.rightSide) {
                    if (primitive.bottomSide) {
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(primitive.leftSide ? xc : x1), pp.service.convertToString(y1));
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(x2 - roundOffset), pp.service.convertToString(y1));
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(x2 - roundOffset2), pp.service.convertToString(y1), pp.service.convertToString(x2), pp.service.convertToString(y1 + roundOffset2), pp.service.convertToString(x2), pp.service.convertToString(y1 + roundOffset));
                    } else {
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(x2), pp.service.convertToString(y1));
                    }
                    if (primitive.topSide) {
                        pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(x2), pp.service.convertToString(y2 - roundOffset));
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(x2), pp.service.convertToString(y2 - roundOffset2), pp.service.convertToString(x2 - roundOffset2), pp.service.convertToString(y2), pp.service.convertToString(x2 - roundOffset), pp.service.convertToString(y2));
                        pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(primitive.leftSide ? xc : x1), pp.service.convertToString(y2));
                    } else {
                        pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(x2), pp.service.convertToString(y2));
                    }
                }
                if (primitive.topSide && !primitive.leftSide && !primitive.rightSide) {
                    pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(x1), pp.service.convertToString(y2));
                    pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(x2), pp.service.convertToString(y2));
                }
                if (primitive.bottomSide && !primitive.leftSide && !primitive.rightSide) {
                    pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(x1), pp.service.convertToString(y1));
                    pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(x2), pp.service.convertToString(y1));
                }
                if (border.style == StiPenStyle.Double) {
                    roundOffset -= offset * 2;
                    roundOffset2 = roundOffset * (1 - pp.service.pdfCKT);
                    let x3 = pp.X + offset;
                    let x4 = pp.X + pp.Width - offset;
                    let y3 = pp.Y + offset;
                    let y4 = pp.Y + pp.Height - offset;
                    if (primitive.leftSide) {
                        if (primitive.bottomSide) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(primitive.rightSide ? xc : x2), pp.service.convertToString(y3));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(x3 + roundOffset), pp.service.convertToString(y3));
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(x3 + roundOffset2), pp.service.convertToString(y3), pp.service.convertToString(x3), pp.service.convertToString(y3 + roundOffset2), pp.service.convertToString(x3), pp.service.convertToString(y3 + roundOffset));
                        } else {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(x3), pp.service.convertToString(y1));
                        }
                        if (primitive.topSide) {
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(x3), pp.service.convertToString(y4 - roundOffset));
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(x3), pp.service.convertToString(y4 - roundOffset2), pp.service.convertToString(x3 + roundOffset2), pp.service.convertToString(y4), pp.service.convertToString(x3 + roundOffset), pp.service.convertToString(y4));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(primitive.rightSide ? xc : x2), pp.service.convertToString(y4));
                        } else {
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(x3), pp.service.convertToString(y2));
                        }
                    }
                    if (primitive.rightSide) {
                        if (primitive.bottomSide) {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(primitive.leftSide ? xc : x1), pp.service.convertToString(y3));
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(x4 - roundOffset), pp.service.convertToString(y3));
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(x4 - roundOffset2), pp.service.convertToString(y3), pp.service.convertToString(x4), pp.service.convertToString(y3 + roundOffset2), pp.service.convertToString(x4), pp.service.convertToString(y3 + roundOffset));
                        } else {
                            pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(x4), pp.service.convertToString(y1));
                        }
                        if (primitive.topSide) {
                            pp.service.pageStream.writeLine1('{0} {1} l', pp.service.convertToString(x4), pp.service.convertToString(y4 - roundOffset));
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} c', pp.service.convertToString(x4), pp.service.convertToString(y4 - roundOffset2), pp.service.convertToString(x4 - roundOffset2), pp.service.convertToString(y4), pp.service.convertToString(x4 - roundOffset), pp.service.convertToString(y4));
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(primitive.leftSide ? xc : x1), pp.service.convertToString(y4));
                        } else {
                            pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(x4), pp.service.convertToString(y2));
                        }
                    }
                    if (primitive.topSide && !primitive.leftSide && !primitive.rightSide) {
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(x1), pp.service.convertToString(y4));
                        pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(x2), pp.service.convertToString(y4));
                    }
                    if (primitive.bottomSide && !primitive.leftSide && !primitive.rightSide) {
                        pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(x1), pp.service.convertToString(y3));
                        pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(x2), pp.service.convertToString(y3));
                    }
                }
                if (needPush) {
                    pp.service.pageStream.writeLine('Q');
                    pp.service.popColorFromStack();
                }
            }
        }
        static renderCheckbox(pp, checkBoxValue, storeShading = true) {
            let checkbox = pp.Component.as(StiCheckBox);
            if (checkbox != null) {
                let shape = null;
                switch (checkBoxValue ? checkbox.checkStyleForTrue : checkbox.checkStyleForFalse) {
                case StiCheckStyle.Cross:
                    shape = '62.568 52.024 m 62.018 52.166 60.405 52.537 58.984 52.848 c 55.336 53.645 49.313 58.685 44.741 64.767 c 40.839 69.958 l 45.919 71.092 l \r\n' + '53.272 72.735 59.559 76.81 67.746 85.239 c 74.954 92.661 l 68.543 100.174 l 56.77 113.972 54.196 123.193 59.915 131.088 c 62.809 135.083 71.734 143.458 73.097 143.458 c \r\n' + '73.509 143.458 74.16 141.77 74.546 139.708 c 75.526 134.457 81.002 122.942 85.482 116.708 c 87.557 113.82 89.473 111.458 89.74 111.458 c \r\n' + '90.006 111.458 93.515 114.945 97.537 119.208 c 113.934 136.584 127.211 138.972 135.818 126.095 c 139.973 119.877 140.004 118.024 135.958 117.739 c \r\n' + '130.11 117.329 118.795 109.205 110.443 99.42 c 105.812 93.994 l 110.69 89.679 l 117.241 83.884 129.589 77.786 136.531 76.919 c \r\n' + '139.576 76.539 142.068 75.813 142.068 75.307 c 142.068 72.526 132.802 60.889 129.038 58.942 c 121.077 54.825 112.668 58.23 96.273 72.209 c \r\n' + '91.287 76.46 l 84.2 67.488 l 80.303 62.554 75.379 57.368 73.259 55.965 c 69.353 53.38 64.393 51.552 62.568 52.024 c h';
                    break;
                case StiCheckStyle.Check:
                    shape = '60.972 37.503 m 51.173 63.277 43.562 76.623 35.37 82.397 c 30.912 85.54 l 33.664 88.435 l 37.539 92.513 43.698 95.935 48.566 96.713 c \r\n' + '52.426 97.33 53.024 97.093 57.102 93.334 c 59.763 90.882 63.368 85.726 66.269 80.223 c 68.899 75.234 71.18 71.153 71.337 71.153 c \r\n' + '71.493 71.153 73.65 74.19 76.13 77.903 c 96.259 108.044 129.683 141.214 157.565 158.718 c 166.414 164.274 l 168.677 161.643 l \r\n' + '170.941 159.012 l 163.178 152.717 l 139.859 133.81 108.017 94.486 89.043 61.164 c 82.362 49.432 81.87 48.851 73.952 43.345 c \r\n' + '69.45 40.214 64.908 37.04 63.858 36.292 c 62.149 35.074 61.848 35.2 60.972 37.503 c h';
                    break;
                case StiCheckStyle.CrossRectangle:
                    shape = '24.153 97.958 m 24.153 170.458 l 98.653 170.458 l 173.153 170.458 l 173.153 97.958 l 173.153 25.458 l 98.653 25.458 l 24.153 25.458 l 24.153 97.958 l h \r\n' + '157.911 97.708 m 157.653 154.958 l 98.653 154.958 l 39.653 154.958 l 39.393 98.958 l 39.25 68.158 39.348 42.395 39.611 41.708 c \r\n' + '39.987 40.727 52.819 40.458 99.129 40.458 c 158.169 40.458 l 157.911 97.708 l h \r\n' + '67.337 54.521 m 65.513 54.912 62.41 56.378 60.442 57.778 c 57.123 60.14 48.153 70.186 48.153 71.541 c 48.153 71.87 50.57 72.68 53.525 73.342 c \r\n' + '60.71 74.95 67.272 79.277 75.328 87.718 c 82.003 94.713 l 75.624 102.027 l 64.931 114.288 61.644 123.705 65.472 131.108 c \r\n' + '67.054 134.168 78.562 145.458 80.098 145.458 c 80.556 145.458 81.245 143.77 81.63 141.708 c 82.611 136.457 88.086 124.942 92.567 118.708 c \r\n' + '94.642 115.82 96.558 113.458 96.824 113.458 c 97.091 113.458 100.6 116.945 104.622 121.208 c 121.019 138.584 134.296 140.972 142.903 128.095 c \r\n' + '147.058 121.877 147.089 120.024 143.043 119.739 c 137.213 119.33 124.806 110.39 117.127 101.066 c 113.226 96.33 113.155 96.112 114.876 94.198 c \r\n' + '118.066 90.648 128.579 83.654 133.847 81.578 c 136.682 80.461 141.285 79.244 144.077 78.873 c 146.868 78.503 149.153 77.878 149.153 77.484 c \r\n' + '149.153 75.37 140.777 64.275 137.501 62.048 c 129.107 56.344 120.869 59.278 103.358 74.209 c 98.372 78.46 l 91.285 69.488 l \r\n' + '81.563 57.18 74.76 52.928 67.337 54.521 c h';
                    break;
                case StiCheckStyle.CheckRectangle:
                    shape = '19.915 96.5 m 19.915 169 l 91.857 169 l 163.8 169 l 170.357 173.111 l 176.914 177.223 l 178.882 174.861 l 179.963 173.563 180.864 172.217 180.882 171.872 c \r\n' + '180.9 171.526 178.44 169.334 175.415 167 c 169.915 162.757 l 169.915 93.378 l 169.915 24 l 94.915 24 l 19.915 24 l 19.915 96.5 l h \r\n' + '153.915 92.622 m 153.915 141.962 153.786 146.137 152.294 144.899 c 149.513 142.592 136.609 126.998 127.965 115.5 c 117.473 101.544 104.486 81.963 98.451 71 c \r\n' + '93.993 62.903 93.316 62.192 84.16 56 c 78.873 52.425 74.256 49.375 73.9 49.223 c 73.544 49.07 71.988 52.22 70.441 56.223 c \r\n' + '68.895 60.225 65.183 68.635 62.192 74.911 c 57.906 83.903 55.515 87.56 50.914 92.161 c 47.703 95.372 44.364 98 43.495 98 c \r\n' + '40.697 98 41.79 99.66 47.479 104.049 c 53.073 108.365 60.662 111.14 64.28 110.194 c 67.84 109.263 73.689 102.039 78.2 93.002 c \r\n' + '82.663 84.062 l 87.207 90.895 l 95.518 103.394 108.214 118.311 125.807 136.25 c 143.215 154 l 89.565 154 l 35.915 154 l 35.915 96.5 l \r\n' + '35.915 39 l 94.915 39 l 153.915 39 l 153.915 92.622 l h';
                    break;
                case StiCheckStyle.CrossCircle:
                    shape = '83.347 26.864 m 61.07 31.95 42.193 47.128 32.202 67.986 c 23.401 86.36 23.68 110.034 32.919 128.958 c 41.882 147.315 60.868 162.86 80.847 168.201 c \r\n' + '91.083 170.936 112.112 170.628 121.812 167.6 c 147.999 159.425 167.881 138.673 173.432 113.721 c 175.869 102.768 175 85.662 171.452 74.743 c \r\n' + '164.795 54.256 145.804 35.792 124.126 28.729 c 117.735 26.647 113.94 26.133 102.847 25.845 c 93.814 25.61 87.363 25.947 83.347 26.864 c h \r\n' + '112.414 41.542 m 129.545 44.672 146.131 57.503 153.827 73.579 c 168.725 104.698 152.719 141.239 119.425 152.119 c 112.712 154.313 109.49 154.763 100.347 154.781 c \r\n' + '90.993 154.8 88.185 154.404 81.579 152.131 c 64.423 146.231 51.91 134.6 45.14 118.265 c 42.988 113.072 42.446 109.911 42.069 100.368 c \r\n' + '41.551 87.229 42.811 81.166 48.181 70.958 c 52.288 63.15 63.613 51.864 71.549 47.67 c 83.611 41.295 98.688 39.034 112.414 41.542 c h \r\n' + '69.097 66.583 m 66.21 69.342 63.847 71.942 63.847 72.361 c 63.847 72.78 69.506 78.671 76.422 85.451 c 88.996 97.78 l 76.198 110.607 l 63.4 123.434 l \r\n' + '68.336 128.446 l 71.051 131.202 73.641 133.458 74.091 133.458 c 74.542 133.458 80.666 127.846 87.7 120.988 c 100.49 108.517 l 104.919 113.071 l \r\n' + '107.354 115.575 113.31 121.259 118.154 125.701 c 126.961 133.777 l 132.308 128.496 l 137.656 123.215 l 124.694 110.658 l 111.733 98.1 l 124.866 84.939 l \r\n' + '137.999 71.779 l 132.815 67.118 l 129.964 64.555 127.11 62.458 126.474 62.458 c 125.837 62.458 119.93 67.858 113.347 74.458 c \r\n' + '106.765 81.058 100.96 86.458 100.449 86.458 c 99.938 86.458 93.856 80.857 86.933 74.013 c 74.347 61.567 l 69.097 66.583 l h';
                    break;
                case StiCheckStyle.DotCircle:
                    shape = '81.653 29.406 m 59.375 34.493 40.499 49.67 30.507 70.529 c 21.706 88.903 21.985 112.576 31.224 131.5 c 40.187 149.857 59.173 165.402 79.153 170.743 c \r\n' + '89.388 173.479 110.417 173.17 120.117 170.142 c 146.304 161.968 166.186 141.215 171.737 116.263 c 174.174 105.311 173.305 88.205 169.757 77.285 c \r\n' + '163.1 56.798 144.109 38.334 122.431 31.271 c 116.04 29.189 112.245 28.675 101.153 28.387 c 92.119 28.152 85.668 28.49 81.653 29.406 c h \r\n' + '111.653 44.504 m 132.341 48.848 149.671 64.959 155.751 85.5 c 158.113 93.481 158.113 107.519 155.751 115.5 c 150.089 134.629 134.635 149.703 114.653 155.588 c \r\n' + '106.553 157.973 90.741 157.974 82.695 155.589 c 62.46 149.592 46.687 133.961 41.605 114.869 c 39.656 107.547 39.74 91.753 41.764 84.932 c \r\n' + '50.494 55.507 80.736 38.013 111.653 44.504 c h \r\n' + '90.005 77.33 m 76.55 82.362 69.825 98.176 75.898 110.5 c 78.035 114.836 83.045 119.856 87.653 122.277 c 93.231 125.208 104.066 125.204 109.705 122.27 c \r\n' + '127.735 112.887 128.781 89.485 111.62 79.428 c 106.047 76.162 95.789 75.166 90.005 77.33 c h';
                    break;
                case StiCheckStyle.DotRectangle:
                    shape = '23.847 98.805 m 23.847 171.305 l 98.347 171.305 l 172.847 171.305 l 172.847 98.805 l 172.847 26.305 l 98.347 26.305 l 23.847 26.305 l 23.847 98.805 l h \r\n' + '157.847 98.813 m 157.847 156.321 l 98.597 156.063 l 39.347 155.805 l 39.089 98.555 l 38.831 41.305 l 98.339 41.305 l 157.847 41.305 l 157.847 98.813 l h \r\n' + '63.527 64.959 m 63.153 65.333 62.847 80.638 62.847 98.972 c 62.847 132.305 l 98.361 132.305 l 133.874 132.305 l 133.611 98.555 l 133.347 64.805 l \r\n' + '98.777 64.542 l 79.763 64.398 63.901 64.585 63.527 64.959 c h';
                    break;
                case StiCheckStyle.NoneCircle:
                    shape = '83.5 29.406 m 61.222 34.493 42.346 49.67 32.355 70.529 c 23.554 88.903 23.832 112.576 33.071 131.5 c 42.034 149.857 61.02 165.402 81 170.743 c \r\n' + '91.235 173.479 112.265 173.17 121.965 170.142 c 148.151 161.968 168.034 141.215 173.585 116.263 c 176.022 105.311 175.152 88.205 171.605 77.285 c \r\n' + '164.948 56.798 145.957 38.334 124.278 31.271 c 117.887 29.189 114.092 28.675 103 28.387 c 93.966 28.152 87.515 28.49 83.5 29.406 c h \r\n' + '113.5 44.504 m 134.189 48.848 151.519 64.959 157.598 85.5 c 159.961 93.481 159.961 107.519 157.598 115.5 c 151.937 134.629 136.483 149.703 116.5 155.588 c \r\n' + '108.401 157.973 92.589 157.974 84.543 155.589 c 64.308 149.592 48.534 133.961 43.453 114.869 c 41.504 107.547 41.588 91.753 43.612 84.932 c \r\n' + '52.342 55.507 82.583 38.013 113.5 44.504 c h';
                    break;
                case StiCheckStyle.NoneRectangle:
                    shape = '24.153 97.958 m 24.153 170.458 l 98.653 170.458 l 173.153 170.458 l 173.153 97.958 l 173.153 25.458 l 98.653 25.458 l 24.153 25.458 l 24.153 97.958 l h \r\n' + '157.911 97.708 m 157.653 154.958 l 98.653 154.958 l 39.653 154.958 l 39.393 98.958 l 39.25 68.158 39.348 42.395 39.611 41.708 c \r\n' + '39.987 40.727 52.819 40.458 99.129 40.458 c 158.169 40.458 l 157.911 97.708 l h';
                    break;
                }
                pp.service.pageStream.writeLine('q');
                pp.service.pushColorToStack();
                let tempColor = StiBrush.toColor(checkbox.textBrush);
                if (tempColor.a != 0) {
                    pp.service.setNonStrokeColor(tempColor);
                }
                if (checkbox.textBrush.is(StiGradientBrush) || checkbox.textBrush.is(StiGlareBrush)) {
                    if (storeShading) {
                        pp.service.storeShadingData2(pp.X, pp.Y, pp.Width, pp.Height, checkbox.textBrush);
                    }
                    pp.service.pageStream.writeLine1('/Pattern cs /P{0} scn', 1 + pp.service.shadingCurrent);
                }
                if (checkbox.textBrush.is(StiHatchBrush)) {
                    let hBrush = checkbox.textBrush;
                    pp.service.pageStream.writeLine1('/Cs1 cs /PH{0} scn', pp.service.getHatchNumber(hBrush) + 1);
                }
                pp.service.setStrokeColor(checkbox.contourColor);
                pp.service.pageStream.writeLine1('{0} w', pp.service.convertToString(checkbox.size));
                pp.service.pageStream.writeLine1('1 0 0 1 {0} {1} cm', pp.service.convertToString(pp.X + pp.Width / 2), pp.service.convertToString(pp.Y + pp.Height / 2));
                let size = Math.min(pp.Width, pp.Height);
                let scale = size / 200;
                pp.service.pageStream.writeLine1('{0} 0 0 {0} 0 0 cm', pp.service.convertToString(scale));
                pp.service.pageStream.writeLine('1 0 0 1 -98 -98 cm');
                pp.service.pageStream.writeLine(shape);
                pp.service.pageStream.writeLine('B');
                pp.service.pageStream.writeLine('Q');
                pp.service.popColorFromStack();
            }
        }
        static getCheckBoxValue(checkbox) {
            let checkBoxValue = null;
            if (checkbox != null && checkbox.checkedValue != null) {
                checkBoxValue = false;
                let checkedValueStr = checkbox.checkedValue.toString().trim().toLowerCase();
                let strs = checkbox.values.split('/');
                if (strs.length == 1)
                    strs = checkbox.values.split(';');
                if (strs.length == 1)
                    strs = checkbox.values.split(',');
                if (strs != null && strs.length > 0) {
                    let firstValue = strs[0].trim().toLowerCase();
                    checkBoxValue = checkedValueStr == firstValue;
                }
            }
            return checkBoxValue;
        }
    };
}
let IStiText = __.a.Components.IStiText;
{
    let StiPdfRenderText = class {
        static renderText(pp) {
            let mTextBrush = pp.Component.as(IStiTextBrush);
            let text = pp.Component.as(IStiText);
            let textOpt = pp.Component.as(IStiTextOptions);
            let mTextHorAlign = pp.Component.as(IStiTextHorAlignment);
            let mVertAlign = pp.Component.as(IStiVertAlignment);
            let textComp = pp.Component.as(StiText);
            let wordWrap = textOpt != null && textOpt.textOptions.wordWrap;
            let needWidthAlign = mTextHorAlign != null && mTextHorAlign.horAlignment == StiTextHorAlignment.Width;
            let needAnnots = pp.service.haveAnnots && textComp.editable;
            let useRightToLeft = textOpt != null && textOpt.textOptions != null && textOpt.textOptions.rightToLeft;
            let annotText = null;
            let linesCount = 0;
            let textAngle = 0;
            let useWysiwyg = textComp.textQuality == __.a.Components.StiTextQuality.Wysiwyg;
            if (needWidthAlign)
                wordWrap = true;
            let useUnicode = pp.service.pdfFont.UseUnicode;
            if (text != null) {
                let margins = textComp.margins;
                let marginL = this.hiToTwips * margins.left;
                let marginR = this.hiToTwips * margins.right;
                let marginT = this.hiToTwips * margins.top;
                let marginB = this.hiToTwips * margins.bottom;
                let textX = pp.X + marginL;
                let textY = pp.Y + marginB;
                let textW = pp.Width - marginL - marginR;
                let textH = pp.Height - marginT - marginB;
                let borderSizeLeft = 0;
                let borderSizeRight = 0;
                let borderSizeTop = 0;
                let borderSizeBottom = 0;
                if (textComp.border.style != StiPenStyle.None) {
                    let tempSizeOffset = textComp.border.getSizeOffset();
                    if (textComp.border.isLeftBorderSidePresent)
                        borderSizeLeft = tempSizeOffset;
                    if (textComp.border.isRightBorderSidePresent)
                        borderSizeRight = tempSizeOffset;
                    if (textComp.border.isTopBorderSidePresent)
                        borderSizeTop = tempSizeOffset;
                    if (textComp.border.isBottomBorderSidePresent)
                        borderSizeBottom = tempSizeOffset;
                }
                let advBorder = textComp.border.stimulsoft().as(StiAdvancedBorder);
                if (advBorder != null) {
                    borderSizeLeft = advBorder.leftSide.getSizeOffset();
                    borderSizeRight = advBorder.rightSide.getSizeOffset();
                    borderSizeTop = advBorder.topSide.getSizeOffset();
                    borderSizeBottom = advBorder.bottomSide.getSizeOffset();
                }
                let borderScale = 0.94;
                textX += this.hiToTwips * borderScale * borderSizeLeft;
                textY += this.hiToTwips * borderScale * borderSizeBottom;
                textW -= this.hiToTwips * borderScale * (borderSizeLeft + borderSizeRight);
                textH -= this.hiToTwips * borderScale * (borderSizeTop + borderSizeBottom);
                if (!needAnnots) {
                    pp.service.pageStream.writeLine('q');
                    pp.service.pushColorToStack();
                    pp.service.pageStream.writeLine1('{0} {1} {2} {3} re W n', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.Width), pp.service.convertToString(pp.Height));
                }
                let textColor = Color.transparent;
                if (mTextBrush != null) {
                    textColor = StiBrush.toColor(mTextBrush.textBrush);
                    pp.service.setNonStrokeColor(textColor);
                    pp.service.storeShadingData2(pp.X, pp.Y, pp.Width, pp.Height, mTextBrush.textBrush);
                    if (mTextBrush.textBrush.is(StiGradientBrush) || mTextBrush.textBrush.is(StiGlareBrush)) {
                        pp.service.pageStream.writeLine1('/Pattern cs /P{0} scn', 1 + pp.service.shadingCurrent);
                    }
                    if (mTextBrush.textBrush.is(StiHatchBrush)) {
                        let hBrush = mTextBrush.textBrush.as(StiHatchBrush);
                        pp.service.pageStream.writeLine1('/Cs1 cs /PH{0} scn', pp.service.getHatchNumber(hBrush) + 1);
                    }
                    if (needAnnots) {
                        let seo = pp.service.annotsArray[pp.service.annotsCurrent];
                        seo.FontColor = textColor;
                    }
                }
                let sizeInPt = 1;
                let mFont = pp.Component.as(IStiFont);
                if (mFont != null)
                    sizeInPt = mFont.font.sizeInPoints;
                let cf = 1;
                let fonttmASC = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.tmASC / 1000 * cf;
                let fonttmDESC = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.tmDESC / 1000 * -1 * cf;
                let fonttmExternal = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.tmExternal / 1000 * cf;
                let fontUnderscoreSize = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.UnderscoreSize / 1000 * cf;
                let fontUnderscorePosition = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.UnderscorePosition / 1000 * cf;
                let fontStrikeoutSize = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.StrikeoutSize / 1000 * cf;
                let fontStrikeoutPosition = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.StrikeoutPosition / 1000 * cf;
                let fontLineHeightWithoutLineSpacing = fonttmASC - fonttmDESC + fonttmExternal;
                let fontLineHeight = fontLineHeightWithoutLineSpacing * textComp.lineSpacing;
                let fontAscF = fonttmASC;
                let fontDescF = fonttmDESC;
                let isRotate90 = false;
                if (textOpt != null) {
                    textAngle = textOpt.textOptions.angle;
                    isRotate90 = textAngle > 45 && textAngle < 135 || textAngle > 225 && textAngle < 315;
                }
                if (needAnnots) {
                    textX -= pp.X;
                    textY -= pp.Y;
                }
                let textQualityOffset = 0;
                if (textComp.textQuality == __.a.Components.StiTextQuality.Standard) {
                    let correctX = 0.35 - (14 - sizeInPt) * 0.04;
                    textQualityOffset = 137.61;
                    let halfSpaceOffset = textQualityOffset * (sizeInPt * this.fontCorrectValue) / 1000;
                    if (isRotate90) {
                        textY += correctX + halfSpaceOffset;
                        textH -= (correctX + halfSpaceOffset) * 2;
                    } else {
                        textX += correctX + halfSpaceOffset;
                        textW -= (correctX + halfSpaceOffset) * 2;
                    }
                }
                if (textComp.textQuality == __.a.Components.StiTextQuality.Typographic) {
                    let correctX = 0.05 + (8 - sizeInPt) * 0.009;
                    if (isRotate90) {
                        textY += correctX;
                        textH -= correctX * 2;
                    } else {
                        textX += correctX;
                        textW -= correctX * 2;
                    }
                }
                let st = text.text;
                if (st == null)
                    st = '';
                st = pp.service.stringReplace(st, '\r', '');
                st = pp.service.stringReplace(st, '', '');
                if (needAnnots) {
                    annotText = pp.service.stringReplace(text.text, '\n', '');
                }
                if (textW > 0 && st.length > 0) {
                    let normTextX = textX;
                    let normTextY = textY;
                    let normTextW = textW;
                    let normTextH = textH;
                    if (textOpt != null) {
                        textAngle = textOpt.textOptions.angle;
                        if (textAngle != 0) {
                            if (isRotate90) {
                                let tempValue = textW;
                                textW = textH;
                                textH = tempValue;
                            }
                            textX = -textW / 2;
                            textY = -textH / 2;
                        }
                    }
                    let stringList = __.b.StiExportUtils.splitString(st, false);
                    if (wordWrap) {
                        for (let indexLine = 0; indexLine < stringList.length; indexLine++) {
                            let stt = stringList[indexLine];
                            if (stt.length < 2)
                                continue;
                            let sbt = new StringBuilder();
                            let indexChar = 0;
                            while (indexChar < stt.length) {
                                if (Char.isWhitespace(stt, indexChar)) {
                                    sbt.append(stt.charAt(indexChar));
                                    indexChar++;
                                } else {
                                    let sbtWord = new StringBuilder();
                                    while (indexChar < stt.length && !Char.isWhitespace(stt, indexChar)) {
                                        sbtWord.append(stt.charAt(indexChar));
                                        indexChar++;
                                    }
                                    let sbtWordBidi = pp.service.bidi.convert(sbtWord, false);
                                    sbt.append(sbtWordBidi);
                                    let lenWord = sbtWord.length - sbtWordBidi.length;
                                    if (lenWord > 0) {
                                        sbt.append(StiString.repeat(String.fromCharCode(0), lenWord));
                                    }
                                }
                            }
                            let charr = [];
                            let stsbt = sbt.toString();
                            for (let tempIndex = 0; tempIndex < stt.length; tempIndex++) {
                                charr[tempIndex] = pp.service.pdfFont.UnicodeMap[stsbt.charCodeAt(tempIndex)];
                            }
                            let summarr = StiArray.create(Number, stt.length);
                            let wordarr = StiArray.create(Number, stt.length);
                            let wordCounter = 0;
                            let summ = 0;
                            for (let index = 0; index < charr.length; index++) {
                                if (charr[index] >= 32)
                                    summ += pp.service.pdfFont.Widths[charr[index] - 32];
                                if (charr[index] == 9)
                                    summ += this.getTabsSize(textOpt, sizeInPt, summ + textQualityOffset) + textQualityOffset;
                                summarr[index] = StiMath.trunc(summ);
                                if (this.isWordWrapSymbol(stsbt, index) && index > 0) {
                                    wordCounter++;
                                }
                                wordarr[index] = wordCounter;
                            }
                            let summf = summ * (sizeInPt * this.fontCorrectValue) / 1000;
                            if (summf > textW) {
                                let index = stt.length - 1;
                                let textWint = StiMath.trunc(textW * 1000 / (sizeInPt * this.fontCorrectValue));
                                while (summarr[index] > textWint && index > 0)
                                    index--;
                                let index2 = index;
                                if (wordarr[index] > 0) {
                                    if (wordarr[index] != wordarr[index + 1]) {
                                        index2 = index++;
                                        while (Char.isWhitespace(stsbt, index) && stsbt.charAt(index) != '	')
                                            index++;
                                    } else {
                                        while (!this.isWordWrapSymbol(stsbt, index))
                                            index--;
                                        index2 = index - 1;
                                        while (Char.isWhitespace(stsbt, index2) && index2 > 0)
                                            index2--;
                                        while (Char.isWhitespace(stsbt, index) && stsbt.charAt(index) != '	')
                                            index++;
                                    }
                                } else {
                                    index++;
                                }
                                if (needWidthAlign) {
                                    stringList[indexLine] = stt.substr(0, index2 + 1) + this.charCode07;
                                } else {
                                    stringList[indexLine] = stt.substr(0, index2 + 1);
                                }
                                stringList.stimulsoft().insert(indexLine + 1, stt.substr(index, stt.length - index).stimulsoft().trimStart(' '));
                            }
                        }
                    }
                    linesCount = stringList.length;
                    let trimCountLines = -1;
                    for (let indexLine = 0; indexLine < stringList.length; indexLine++) {
                        let stt = stringList[indexLine];
                        if (pp.service.pdfFont.UnicodeMap[160] != 0 && pp.service.pdfFont.GlyphList[pp.service.pdfFont.UnicodeMap[160]] == 65535) {
                            stt = pp.service.stringReplace(stt, ' ', ' ');
                        }
                        let stTemp = pp.service.bidi.convert(new StringBuilder(stt), useRightToLeft).toString();
                        let sbTemp = '';
                        for (let index = 0; index < stTemp.length; index++) {
                            sbTemp += String.fromCharCode(pp.service.pdfFont.UnicodeMap[stTemp.charCodeAt(index)]);
                        }
                        stringList[indexLine] = sbTemp;
                    }
                    if (mVertAlign != null) {
                        let textHeight = (linesCount - 1) * fontLineHeight + fontLineHeightWithoutLineSpacing;
                        let vertAlignment = mVertAlign.vertAlignment;
                        if (textAngle != 0 && textAngle != 90 && textAngle != 180 && textAngle != 270) {
                            vertAlignment = StiVertAlignment.Center;
                        }
                        if (vertAlignment == StiVertAlignment.Top) {
                            textY += textH - textHeight + (fontLineHeightWithoutLineSpacing - fontAscF);
                        }
                        if (vertAlignment == StiVertAlignment.Center) {
                            if (textComp.textQuality == __.a.Components.StiTextQuality.Typographic) {
                                textY += (textH - textHeight) / 2 - fontDescF;
                            } else {
                                textY += (textH - textHeight) / 2 + (fontLineHeightWithoutLineSpacing - fontAscF) * 1.2;
                            }
                        }
                        if (vertAlignment == StiVertAlignment.Bottom) {
                            if (textComp.textQuality == __.a.Components.StiTextQuality.Typographic) {
                                textY += -fontDescF;
                            } else {
                                textY += (fontLineHeightWithoutLineSpacing - fontAscF) * 1.4;
                            }
                        }
                    }
                    pp.service.pageStream.writeLine('BT');
                    let lastTextLineX = 0;
                    let lastTextLineY = 0;
                    let underlineArray = StiArray.create2(Number, stringList.length, 3);
                    let matrix = null;
                    if (textAngle != 0) {
                        let AngleInRadians = textAngle * Math.PI / 180;
                        matrix = new Matrix(Math.cos(AngleInRadians), Math.sin(AngleInRadians), -Math.sin(AngleInRadians), Math.cos(AngleInRadians), normTextX + normTextW / 2, normTextY + normTextH / 2);
                        if (!(pp.service.pdfFont.NeedSyntItalic && mFont != null && mFont.font.italic)) {
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} Tm', pp.service.convertToString(matrix.elements[0]), pp.service.convertToString(matrix.elements[1]), pp.service.convertToString(matrix.elements[2]), pp.service.convertToString(matrix.elements[3]), pp.service.convertToString(matrix.elements[4]), pp.service.convertToString(matrix.elements[5]));
                        }
                    }
                    if (pp.service.pdfFont.NeedSyntBold && mFont != null && mFont.font.bold) {
                        pp.service.pageStream.writeLine1('{0} w 2 Tr', pp.service.convertToString(this.boldFontStrokeWidthValue * sizeInPt, 3));
                        pp.service.setStrokeColor(textColor);
                    }
                    for (let indexLine = 0; indexLine < linesCount; indexLine++) {
                        let stt = stringList[indexLine];
                        let tabsArr = StiArray.create(Number, stt.length);
                        let numTabs = 0;
                        let summ = 0;
                        let trimSumm = 0;
                        let trimWidth = textW * 1000 / (sizeInPt * this.fontCorrectValue);
                        let trimCharWidth = pp.service.pdfFont.Widths[pp.service.pdfFont.UnicodeMap['…'.charCodeAt(0)]];
                        let trimIndex = 0;
                        for (let index = 0; index < stt.length; index++) {
                            let charrSym = stt.charCodeAt(index);
                            if (charrSym >= 32) {
                                summ += pp.service.pdfFont.Widths[charrSym - 32];
                            }
                            if (charrSym == 9) {
                                let tabSize = this.getTabsSize(textOpt, sizeInPt, summ);
                                summ += tabSize;
                                tabsArr[numTabs++] = tabSize;
                            }
                            if (summ + trimCharWidth < trimWidth) {
                                trimSumm = summ;
                                trimIndex = index;
                            }
                        }
                        summ = summ * (sizeInPt * this.fontCorrectValue) / 1000;
                        if (trimCountLines != -1 && (indexLine == linesCount - 1 && trimCountLines < stringList.length || summ > textW)) {
                            stt = stt.substr(0, trimIndex) + String.fromCharCode(pp.service.pdfFont.UnicodeMap['…'.charCodeAt(0)]);
                            summ = (trimSumm + trimCharWidth) * (sizeInPt * this.fontCorrectValue) / 1000;
                        }
                        if (useUnicode) {
                            let sbt = new StringBuilder();
                            for (let index = 0; index < stt.length; index++) {
                                if (index % 121 == 120) {
                                    sbt.appendLine('\r');
                                }
                                let code = stt.charCodeAt(index);
                                if (code == 32 || code == 9 || code == 7) {
                                    sbt.append(stt.charAt(index));
                                } else {
                                    let glyph = pp.service.pdfFont.GlyphList[code];
                                    if (glyph == 65535)
                                        glyph = 0;
                                    sbt.appendFormat('{0:X4}', glyph);
                                }
                            }
                            stt = sbt.toString();
                        } else {
                            stt = __.b.StiPdfExportService.convertToEscapeSequence(stt);
                        }
                        let textLineX = textX;
                        let textLineY = textY + fontLineHeight * (linesCount - indexLine - 1);
                        let isTextHorAlignmentWidth = false;
                        let useSpaceWidth = false;
                        if (mTextHorAlign != null) {
                            let horAlign = mTextHorAlign.horAlignment;
                            if (needWidthAlign) {
                                if (stt.length > 0 && stt.charCodeAt(stt.length - 1) === 7) {
                                    stt = stt.substr(0, stt.length - 1);
                                } else {
                                    horAlign = StiTextHorAlignment.Left;
                                }
                            }
                            if (!(textAngle == 0 || textAngle == 90 || textAngle == 180 || textAngle == 270))
                                horAlign = StiTextHorAlignment.Center;
                            if (textOpt != null && textOpt.textOptions != null && textOpt.textOptions.rightToLeft) {
                                if (horAlign == StiTextHorAlignment.Left)
                                    horAlign = StiTextHorAlignment.Right;
                                else if (horAlign == StiTextHorAlignment.Right)
                                    horAlign = StiTextHorAlignment.Left;
                            }
                            if (horAlign == StiTextHorAlignment.Center) {
                                textLineX += (textW - summ) / 2;
                            }
                            if (horAlign == StiTextHorAlignment.Right) {
                                textLineX += textW - summ;
                            }
                            if (horAlign == StiTextHorAlignment.Width) {
                                let numSpaces = 0;
                                for (let spaceIndex = 0; spaceIndex < stt.length; spaceIndex++) {
                                    if (stt.charCodeAt(spaceIndex) === 32)
                                        numSpaces++;
                                }
                                if (numSpaces > 0 && (indexLine != stringList.length - 1 || useWysiwyg && summ > textW)) {
                                    useSpaceWidth = true;
                                    let spaceOffset = (textW - summ) / numSpaces * 1000 / (sizeInPt * this.fontCorrectValue);
                                    if (spaceOffset > 0 || useWysiwyg) {
                                        isTextHorAlignmentWidth = true;
                                        spaceOffset += pp.service.pdfFont.Widths[0];
                                        if (spaceOffset < pp.service.pdfFont.Widths[0] * 0.5)
                                            spaceOffset = pp.service.pdfFont.Widths[0] * 0.5;
                                        let sbSpace = useUnicode ? '<' : '(';
                                        for (let charIndex = 0; charIndex < stt.length; charIndex++) {
                                            if (stt.charCodeAt(charIndex) === 32) {
                                                if (useUnicode) {
                                                    sbSpace += '>-' + pp.service.convertToString(spaceOffset) + '<';
                                                } else {
                                                    sbSpace += ')-' + pp.service.convertToString(spaceOffset) + '(';
                                                }
                                            } else {
                                                sbSpace += stt[charIndex];
                                            }
                                        }
                                        sbSpace += useUnicode ? '>' : ')';
                                        stt = sbSpace;
                                    }
                                }
                            }
                        }
                        if (numTabs > 0) {
                            let currentTab = 0;
                            let sbTabs = '';
                            if (useSpaceWidth == false) {
                                sbTabs += useUnicode ? '<' : '(';
                            }
                            for (let charIndex = 0; charIndex < stt.length; charIndex++) {
                                if (stt[charIndex] == '	') {
                                    let tabOffset = tabsArr[currentTab++];
                                    if (useUnicode) {
                                        sbTabs += '>-' + pp.service.convertToString(tabOffset) + '<';
                                    } else {
                                        sbTabs += ')-' + pp.service.convertToString(tabOffset) + '(';
                                    }
                                } else {
                                    sbTabs += stt[charIndex];
                                }
                            }
                            if (useSpaceWidth == false) {
                                sbTabs += useUnicode ? '>' : ')';
                            }
                            stt = sbTabs;
                        }
                        if (useUnicode) {
                            stt = pp.service.stringReplace(stt, ' ', pp.service.pdfFont.GlyphList[32].toString(16).toUpperCase().stimulsoft().padLeft(4, '0')).stimulsoft().replaceAll(this.charCode07, '0000');
                        }
                        let needChildFonts = pp.service.pdfFont.ChildFontsMap != null;
                        let currentChildFont = 0;
                        let charr = StiArray.create(Number, stt.length);
                        let warpPoints = new Array();
                        for (let tempIndex = 0; tempIndex < stt.length; tempIndex++) {
                            let ch = stt.charCodeAt(tempIndex);
                            charr[tempIndex] = ch;
                            let isWarp = false;
                            if (ch == 13) {
                                warpPoints.push(tempIndex);
                                isWarp = true;
                            }
                            if (needChildFonts) {
                                let symb = pp.service.pdfFont.UnicodeMapBack[ch];
                                if (ch == 92) {
                                    symb = pp.service.pdfFont.UnicodeMapBack[stt.charCodeAt(tempIndex + 1)];
                                }
                                let tempChildFont = pp.service.pdfFont.ChildFontsMap[symb];
                                if (symb < 64) {
                                    if (tempIndex > 0) {
                                        tempChildFont = currentChildFont;
                                    } else {
                                        if (stt.length > 1)
                                            tempChildFont = pp.service.pdfFont.ChildFontsMap[pp.service.pdfFont.UnicodeMapBack[stt.charCodeAt(1)]];
                                    }
                                }
                                if (ch != 92) {
                                    charr[tempIndex] = pp.service.pdfFont.fonts[tempChildFont].UnicodeMap[symb];
                                }
                                if (tempChildFont != currentChildFont && !isWarp && tempIndex != 0) {
                                    warpPoints.push(tempIndex);
                                }
                                currentChildFont = tempChildFont;
                            }
                        }
                        warpPoints.push(stt.length);
                        underlineArray[indexLine][0] = textLineX;
                        underlineArray[indexLine][1] = textLineY;
                        underlineArray[indexLine][2] = summ;
                        if (pp.service.pdfFont.NeedSyntItalic && mFont != null && mFont.font.italic) {
                            let matrix2 = new Matrix(1, 0, this.italicAngleTanValue, 1, textLineX, textLineY);
                            if (matrix != null) {
                                matrix2.multiplyAppend(matrix2);
                            }
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} Tm', pp.service.convertToString(matrix2.elements[0]), pp.service.convertToString(matrix2.elements[1]), pp.service.convertToString(matrix2.elements[2]), pp.service.convertToString(matrix2.elements[3]), pp.service.convertToString(matrix2.elements[4]), pp.service.convertToString(matrix2.elements[5]));
                        } else {
                            pp.service.pageStream.writeLine1('{0} {1} Td', pp.service.convertToString(textLineX - lastTextLineX), pp.service.convertToString(textLineY - lastTextLineY));
                            lastTextLineX = textLineX;
                            lastTextLineY = textLineY;
                        }
                        let startPoint = 0;
                        for (let indexWarpPoint = 0; indexWarpPoint < warpPoints.length; indexWarpPoint++) {
                            if (needChildFonts && stt.length > 0) {
                                let posCharToGetFont = stt.charCodeAt(startPoint) < 64 && stt.length > startPoint + 1 ? startPoint + 1 : startPoint;
                                let tempChildFont = pp.service.pdfFont.ChildFontsMap[pp.service.pdfFont.UnicodeMapBack[stt.charCodeAt(posCharToGetFont)]];
                                pp.service.pageStream.writeLine1('/F{0} {1} Tf', tempChildFont, pp.service.convertToString(sizeInPt * this.fontCorrectValue, this.precision_digits_font));
                            }
                            let warpPoint = warpPoints[indexWarpPoint];
                            let warpLength = warpPoint - startPoint;
                            if (warpLength > 0) {
                                if (isTextHorAlignmentWidth || numTabs > 0) {
                                    pp.service.pageStream.writeString('[');
                                    if (indexWarpPoint > 0)
                                        pp.service.pageStream.writeString(useUnicode ? '<' : '(');
                                    pp.service.pageStream.write(charr, startPoint, warpLength);
                                    if (indexWarpPoint < warpPoints.length - 1)
                                        pp.service.pageStream.writeString(useUnicode ? '>' : ')');
                                    pp.service.pageStream.writeLine('] TJ');
                                } else {
                                    pp.service.pageStream.writeString(useUnicode ? '<' : '(');
                                    pp.service.pageStream.write(charr, startPoint, warpLength);
                                    pp.service.pageStream.writeLine1('{0} Tj', useUnicode ? '>' : ')');
                                }
                            }
                            startPoint = warpPoint;
                            if (warpPoint < charr.length - 1 && charr[warpPoint] == 13)
                                startPoint++;
                        }
                    }
                    if (pp.service.pdfFont.NeedSyntBold && mFont != null && mFont.font.bold) {
                        pp.service.pageStream.writeLine('0 Tr');
                    }
                    pp.service.pageStream.writeLine('ET');
                    if (mFont != null && mFont.font.underline) {
                        pp.service.pageStream.writeLine('q');
                        pp.service.pushColorToStack();
                        let underscoreSize = sizeInPt * 0.07;
                        let underscorePosition = -sizeInPt * 0.1;
                        if (pp.service.pdfFont.UnderscoreSize != 0) {
                            underscoreSize = fontUnderscoreSize;
                            underscorePosition = fontUnderscorePosition;
                        }
                        if (underscoreSize < 0.1)
                            underscoreSize = 0.1;
                        pp.service.pageStream.writeLine1('{0} w', pp.service.convertToString(underscoreSize));
                        if (textAngle != 0) {
                            let AngleInRadians = textAngle * Math.PI / 180;
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} cm', pp.service.convertToString(Math.cos(AngleInRadians)), pp.service.convertToString(Math.sin(AngleInRadians)), pp.service.convertToString(-Math.sin(AngleInRadians)), pp.service.convertToString(Math.cos(AngleInRadians)), pp.service.convertToString(normTextX + normTextW / 2), pp.service.convertToString(normTextY + normTextH / 2));
                        }
                        if (mTextBrush != null) {
                            pp.service.setStrokeColor(textColor);
                        }
                        for (let tempIndex = 0; tempIndex < stringList.length; tempIndex++) {
                            if (underlineArray[tempIndex][2] != 0) {
                                pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(underlineArray[tempIndex][0]), pp.service.convertToString(underlineArray[tempIndex][1] + underscorePosition));
                                pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(underlineArray[tempIndex][0] + underlineArray[tempIndex][2]), pp.service.convertToString(underlineArray[tempIndex][1] + underscorePosition));
                            }
                        }
                        pp.service.pageStream.writeLine('Q');
                        pp.service.popColorFromStack();
                    }
                    if (mFont != null && mFont.font.strikeout) {
                        pp.service.pageStream.writeLine('q');
                        pp.service.pushColorToStack();
                        let strikeoutSize = sizeInPt * 0.045;
                        let strikeoutPosition = sizeInPt * 0.25;
                        if (pp.service.pdfFont.StrikeoutSize != 0) {
                            strikeoutSize = fontStrikeoutSize;
                            strikeoutPosition = fontStrikeoutPosition;
                        }
                        if (strikeoutSize < 0.1)
                            strikeoutSize = 0.1;
                        pp.service.pageStream.writeLine1('{0} w', pp.service.convertToString(strikeoutSize));
                        if (textAngle != 0) {
                            let AngleInRadians = textAngle * Math.PI / 180;
                            pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} cm', pp.service.convertToString(Math.cos(AngleInRadians)), pp.service.convertToString(Math.sin(AngleInRadians)), pp.service.convertToString(-Math.sin(AngleInRadians)), pp.service.convertToString(Math.cos(AngleInRadians)), pp.service.convertToString(normTextX + normTextW / 2), pp.service.convertToString(normTextY + normTextH / 2));
                        }
                        if (mTextBrush != null) {
                            pp.service.setStrokeColor(textColor);
                        }
                        for (let tempIndex = 0; tempIndex < stringList.length; tempIndex++) {
                            if (underlineArray[tempIndex][2] != 0) {
                                pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(underlineArray[tempIndex][0]), pp.service.convertToString(underlineArray[tempIndex][1] + strikeoutPosition));
                                pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(underlineArray[tempIndex][0] + underlineArray[tempIndex][2]), pp.service.convertToString(underlineArray[tempIndex][1] + strikeoutPosition));
                            }
                        }
                        pp.service.pageStream.writeLine('Q');
                        pp.service.popColorFromStack();
                    }
                }
                if (needAnnots) {
                    let seo = pp.service.annotsArray[pp.service.annotsCurrent];
                    seo.Multiline = wordWrap;
                    seo.X = pp.X;
                    seo.Y = pp.Y;
                    seo.Width = pp.Width;
                    seo.Height = pp.Height;
                    seo.Text = annotText;
                    seo.Component = pp.Component;
                    seo.Alignment = StiTextHorAlignment.Left;
                    if (mTextHorAlign != null) {
                        let horAlign = mTextHorAlign.horAlignment;
                        if (textOpt != null && textOpt.textOptions != null && textOpt.textOptions.rightToLeft) {
                            if (horAlign == StiTextHorAlignment.Left)
                                horAlign = StiTextHorAlignment.Right;
                            else if (horAlign == StiTextHorAlignment.Right)
                                horAlign = StiTextHorAlignment.Left;
                        }
                        seo.Alignment = horAlign;
                    }
                }
                if (!needAnnots) {
                    pp.service.pageStream.writeLine('Q');
                    pp.service.popColorFromStack();
                }
            }
        }
        static isWordWrapSymbol(sb, index) {
            let sym1 = sb.charCodeAt(index);
            let st1 = sb.charAt(index);
            if (sym1 >= 12288 && sym1 <= 55215 || Char.isWhitespace(sb, index) && sym1 != 160 || st1 == '(' || st1 == '{')
                return true;
            if (index > 0) {
                let sym2 = sb.charAt(index - 1);
                if (sym2 == '!' || sym2 == '%' || sym2 == ')' || sym2 == '}' || sym2 == '-' || sym2 == '?')
                    return true;
            }
            return false;
        }
        static getTabsSize(textOp, sizeInPt, currentPosition) {
            if (textOp != null && textOp.textOptions != null) {
                let position = currentPosition;
                let spaceWidth = 750 / sizeInPt;
                let otherTab = spaceWidth * textOp.textOptions.distanceBetweenTabs;
                let firstTab = spaceWidth * textOp.textOptions.firstTabOffset + otherTab;
                if (currentPosition < firstTab) {
                    position = firstTab;
                } else {
                    if (textOp.textOptions.distanceBetweenTabs > 0) {
                        let kolTabs = StiMath.trunc((currentPosition - firstTab) / otherTab);
                        kolTabs++;
                        position = firstTab + kolTabs * otherTab;
                    }
                }
                return position - currentPosition;
            } else {
                return 0;
            }
        }
        static renderTextFont(pp) {
            let mFont = pp.Component.as(IStiFont);
            if (mFont != null) {
                let fnt = pp.service.pdfFont.getFontNumber(mFont.font);
                let fntSize = mFont.font.sizeInPoints * this.fontCorrectValue;
                pp.service.pageStream.writeLine1('/F{0} {1} Tf', fnt, pp.service.convertToString(fntSize, this.precision_digits_font));
                pp.service.pdfFont.currentFont = fnt;
                if (pp.service.haveAnnots && pp.Component.as(StiText).editable) {
                    let seo = pp.service.annotsArray[pp.service.annotsCurrent];
                    seo.FontNumber = fnt;
                    seo.FontSize = fntSize;
                }
            }
        }
        static renderText2(pp, pageNumber = -1) {
            let text = pp.Component.as(IStiText);
            let textOpt = pp.Component.as(IStiTextOptions);
            let textComp = pp.Component.as(StiText);
            if (text == null || pp.Width <= 0)
                return;
            if (StiString.isNullOrWhiteSpace(text.text))
                return;
            let needAnnots = pp.service.haveAnnots && textComp.editable;
            let textAngle = 0;
            let margins = textComp.margins;
            let marginScale = 0;
            let marginL = marginScale * margins.left;
            let marginR = marginScale * margins.right;
            let marginT = marginScale * margins.top;
            let marginB = marginScale * margins.bottom;
            let textX = pp.X + marginL;
            let textY = pp.Y + marginB;
            let textW = pp.Width - marginL - marginR;
            let textH = pp.Height - marginT - marginB;
            if (textW <= 0)
                return;
            if (!needAnnots) {
                pp.service.pageStream.writeLine('q');
                pp.service.pushColorToStack();
                pp.service.pageStream.writeLine1('{0} {1} {2} {3} re W n', pp.service.convertToString(pp.X), pp.service.convertToString(pp.Y), pp.service.convertToString(pp.Width), pp.service.convertToString(pp.Height));
            }
            let isRotate90 = false;
            if (textOpt != null) {
                textAngle = textOpt.textOptions.angle;
                isRotate90 = textAngle > 45 && textAngle < 135 || textAngle > 225 && textAngle < 315;
            }
            if (needAnnots) {
                textX -= pp.X;
                textY -= pp.Y;
            }
            let normTextX = textX;
            let normTextY = textY;
            let normTextW = textW;
            let normTextH = textH;
            if (textOpt != null) {
                textAngle = textOpt.textOptions.angle;
                if (textAngle != 0) {
                    if (isRotate90) {
                        let tempValue = textW;
                        textW = textH;
                        textH = tempValue;
                    }
                    textX = -textW / 2;
                    textY = -textH / 2;
                }
            }
            let outRunsList = [];
            let outFontsList = [];
            StiHtmlTextRender.drawTextForOutput(textComp, outRunsList, outFontsList);
            if (Stimulsoft['StiOptions'].Export.Pdf.useProperCaseFontNamesFromHtml) {
                for (let fontState of outFontsList) {
                    let name = fontState.fontName;
                    let haveUpper = false;
                    for (let index = 0; index < name.length; index++) {
                        if (Char.isUpper(name, index)) {
                            haveUpper = true;
                            break;
                        }
                    }
                    if (!haveUpper) {
                        let fontName = Stimulsoft.System.Globalization.CultureInfo.InvariantCulture.textInfo.toTitleCase(name);
                        let stateFont = null;
                        if (fontName.indexOf(',') != -1) {
                            let fontNames = fontName.split(',');
                            for (let fontNamePart of fontNames) {
                                stateFont = new Font(fontNamePart, fontState.fontBase.size, fontState.fontBase.style);
                                if (stateFont.name.toLowerCase() == fontNamePart.toLowerCase())
                                    break;
                            }
                        } else {
                            stateFont = new Font(fontName, fontState.fontBase.size, fontState.fontBase.style);
                        }
                        fontState.fontBase = stateFont;
                        fontState.fontName = stateFont.name;
                    }
                }
            }
            let baseBackColor = StiBrush.toColor(textComp.brush);
            let isBackColorChanged = false;
            let rectComp = textComp.page.unit.convertRectangleToHInches(pp.Component.componentToPage(pp.Component.clientRectangle));
            let rectText = textComp.convertTextMargins(rectComp, false);
            rectText = textComp.convertTextBorders(rectText, false);
            for (let runInfo of outRunsList) {
                let posX = textX + this.hiToTwips * (rectText.left + runInfo.xPos - rectComp.left);
                let posY = textY + this.hiToTwips * (rectComp.bottom - (rectText.top + runInfo.yPos));
                if (isRotate90) {
                    posX = textX + this.hiToTwips * (rectComp.bottom - rectText.bottom + runInfo.xPos);
                    posY = textY + this.hiToTwips * (rectComp.right - (rectText.left + runInfo.yPos));
                }
                pp.service.pageStream.writeLine('q');
                pp.service.pushColorToStack();
                let tempFont = outFontsList[runInfo.fontIndex].fontBase;
                let fnt = pp.service.pdfFont.getFontNumber(tempFont);
                let fntSize = tempFont.sizeInPoints * this.fontCorrectValue;
                pp.service.pageStream.writeLine1('/F{0} {1} Tf', fnt, pp.service.convertToString(fntSize, this.precision_digits_font));
                pp.service.pdfFont.currentFont = fnt;
                let useUnicode = pp.service.pdfFont.UseUnicode;
                let sizeInPt = tempFont.sizeInPoints;
                let cf = 1;
                let fonttmASC = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.tmASC / 1000 * cf;
                let fonttmDESC = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.tmDESC / 1000 * -1 * cf;
                let fonttmExternal = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.tmExternal / 1000 * cf;
                let fontUnderscoreSize = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.UnderscoreSize / 1000 * cf;
                let fontUnderscorePosition = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.UnderscorePosition / 1000 * cf;
                let fontStrikeoutSize = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.StrikeoutSize / 1000 * cf;
                let fontStrikeoutPosition = sizeInPt * this.fontCorrectValue * pp.service.pdfFont.StrikeoutPosition / 1000 * cf;
                let fontLineHeight = (fonttmASC - fonttmDESC + fonttmExternal) * textComp.lineSpacing;
                let fontAscF = fonttmASC;
                let fontDescF = fonttmDESC;
                let hasGlyphs = true;
                if (useUnicode) {
                    if (runInfo.glyphIndexList[0] == -1) {
                        hasGlyphs = false;
                        for (let index = 0; index < runInfo.text.length; index++) {
                            runInfo.glyphIndexList[index] = pp.service.pdfFont.GlyphList[pp.service.pdfFont.UnicodeMap[runInfo.text.charCodeAt(index)]];
                        }
                    }
                }
                posY -= fontAscF;
                let summGdi = 0;
                let summPdf = 0;
                for (let indexGlyph = 0; indexGlyph < runInfo.glyphIndexList.length; indexGlyph++) {
                    let currentChar = runInfo.text.charCodeAt(indexGlyph);
                    if (useUnicode && hasGlyphs) {
                        currentChar = runInfo.glyphIndexList[indexGlyph];
                        currentChar = pp.service.pdfFont.GlyphBackList[currentChar];
                    }
                    let code = pp.service.pdfFont.UnicodeMap[currentChar];
                    let currentCharWidth = 1000;
                    if (code >= 32) {
                        currentCharWidth = pp.service.pdfFont.Widths[code - 32];
                    }
                    if (currentChar == 0 && pp.service.pdfFont.GlyphWidths != null) {
                        currentCharWidth = pp.service.pdfFont.GlyphWidths[runInfo.glyphIndexList[indexGlyph]];
                    }
                    currentCharWidth = currentCharWidth * runInfo.scaleList[indexGlyph];
                    if (useUnicode) {
                        if (runInfo.glyphWidths[indexGlyph] > 0) {
                            summGdi += runInfo.glyphWidths[indexGlyph];
                            summPdf += currentCharWidth;
                        }
                    } else {
                        summGdi += runInfo.widths[indexGlyph];
                        summPdf += currentCharWidth;
                    }
                }
                let lineWidth = summGdi * this.hiToTwips;
                let lineScale = lineWidth / (sizeInPt * this.fontCorrectValue / 1000) / summPdf;
                if (!isBackColorChanged) {
                    if (!runInfo.backColor.equals(baseBackColor))
                        isBackColorChanged = true;
                }
                if (isBackColorChanged && runInfo.backColor.a != 0) {
                    pp.service.setNonStrokeColor(runInfo.backColor);
                    pp.service.pageStream.writeLine1('{0} {1} {2} {3} re f', pp.service.convertToString(posX), pp.service.convertToString(posY - -fonttmDESC), pp.service.convertToString(lineWidth), pp.service.convertToString(fontLineHeight));
                }
                pp.service.setNonStrokeColor(runInfo.textColor);
                let stt = new StringBuilder();
                summGdi = 0;
                summPdf = 0;
                let summPdf2 = 0;
                stt.append(useUnicode ? '<' : '(');
                for (let index = 0; index < runInfo.glyphIndexList.length; index++) {
                    let currentChar = runInfo.text.charCodeAt(index);
                    if (useUnicode && hasGlyphs) {
                        currentChar = runInfo.glyphIndexList[index];
                        currentChar = pp.service.pdfFont.GlyphBackList[currentChar];
                    }
                    let code = pp.service.pdfFont.UnicodeMap[currentChar];
                    let currentCharWidth = 1000;
                    if (code >= 32) {
                        currentCharWidth = pp.service.pdfFont.Widths[code - 32];
                    }
                    let correctionValue = 0;
                    if ((useUnicode ? runInfo.glyphWidths[index] : runInfo.widths[index]) > 0) {
                        summPdf += currentCharWidth * runInfo.scaleList[index];
                        summPdf2 += currentCharWidth;
                        correctionValue = -(summPdf * lineScale - summPdf2);
                        summPdf2 += -correctionValue;
                    } else {
                        correctionValue = currentCharWidth;
                    }
                    if (useUnicode) {
                        let glyph = runInfo.glyphIndexList[index];
                        if (glyph == 65535)
                            glyph = 0;
                        stt.appendFormat('{0:X4}', glyph);
                        if (index < runInfo.glyphIndexList.length - 1) {
                            stt.append('>' + pp.service.convertToString(correctionValue) + '<');
                        }
                    } else {
                        stt.append(__.b.StiPdfExportService.convertToEscapeSequencePlusTabs(String.fromCharCode(code)));
                        if (index < runInfo.glyphIndexList.length - 1) {
                            stt.append(')' + pp.service.convertToString(correctionValue) + '(');
                        }
                    }
                }
                stt.append(useUnicode ? '>' : ')');
                let charr = StiArray.create(Number, stt.length);
                for (let tempIndex = 0; tempIndex < stt.length; tempIndex++) {
                    charr[tempIndex] = stt.charCodeAt(tempIndex);
                }
                pp.service.pageStream.writeLine('BT');
                let matrix = null;
                if (textAngle != 0) {
                    let AngleInRadians = textAngle * Math.PI / 180;
                    matrix = new Matrix(Math.cos(AngleInRadians), Math.sin(AngleInRadians), -Math.sin(AngleInRadians), Math.cos(AngleInRadians), normTextX + normTextW / 2, normTextY + normTextH / 2);
                    let matrix2 = new Matrix(1, 0, 0, 1, posX, posY);
                    matrix.multiplyPrepend(matrix2);
                }
                if (pp.service.pdfFont.NeedSyntItalic && tempFont.italic) {
                    if (matrix != null) {
                        let matrix2 = new Matrix(1, 0, this.italicAngleTanValue, 1, 0, 0);
                        matrix.multiplyPrepend(matrix2);
                    } else {
                        let matrix2 = new Matrix(1, 0, this.italicAngleTanValue, 1, posX, posY);
                        matrix = matrix2;
                    }
                }
                if (matrix != null) {
                    pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} Tm', pp.service.convertToString(matrix.elements[0], 7), pp.service.convertToString(matrix.elements[1], 7), pp.service.convertToString(matrix.elements[2], 7), pp.service.convertToString(matrix.elements[3], 7), pp.service.convertToString(matrix.elements[4], 6), pp.service.convertToString(matrix.elements[5], 6));
                } else {
                    pp.service.pageStream.writeLine1('{0} {1} Td', pp.service.convertToString(posX), pp.service.convertToString(posY));
                }
                if (pp.service.pdfFont.NeedSyntBold && tempFont.bold) {
                    pp.service.pageStream.writeLine1('{0} w 2 Tr', pp.service.convertToString(this.boldFontStrokeWidthValue * sizeInPt * this.fontCorrectValue, this.precision_digits_font));
                    pp.service.setStrokeColor(runInfo.textColor);
                }
                pp.service.pageStream.writeString('[');
                pp.service.pageStream.flush();
                pp.service.pageStream.write(charr, 0, charr.length);
                pp.service.pageStream.writeLine('] TJ');
                pp.service.pageStream.writeLine('ET');
                if (pp.service.pdfFont.NeedSyntBold && tempFont.bold) {
                    pp.service.pageStream.writeLine('0 Tr');
                }
                if (tempFont.underline) {
                    pp.service.pageStream.writeLine('q');
                    pp.service.pushColorToStack();
                    let underscoreSize = sizeInPt * 0.09;
                    let underscorePosition = -sizeInPt * 0.115;
                    if (pp.service.pdfFont.UnderscoreSize != 0) {
                        underscoreSize = fontUnderscoreSize;
                        underscorePosition = fontUnderscorePosition;
                    }
                    if (underscoreSize < 0.1)
                        underscoreSize = 0.1;
                    pp.service.pageStream.writeLine1('{0} w', pp.service.convertToString(underscoreSize));
                    if (textAngle != 0) {
                        let AngleInRadians = textAngle * Math.PI / 180;
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} cm', pp.service.convertToString(Math.cos(AngleInRadians), 7), pp.service.convertToString(Math.sin(AngleInRadians), 7), pp.service.convertToString(-Math.sin(AngleInRadians), 7), pp.service.convertToString(Math.cos(AngleInRadians), 7), pp.service.convertToString(normTextX + normTextW / 2, 6), pp.service.convertToString(normTextY + normTextH / 2, 6));
                    }
                    pp.service.setStrokeColor(runInfo.textColor);
                    pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(posX), pp.service.convertToString(posY + underscorePosition));
                    pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(posX + lineWidth), pp.service.convertToString(posY + underscorePosition));
                    pp.service.pageStream.writeLine('Q');
                    pp.service.popColorFromStack();
                }
                if (tempFont.strikeout) {
                    pp.service.pageStream.writeLine('q');
                    pp.service.pushColorToStack();
                    let strikeoutSize = sizeInPt * 0.09;
                    let strikeoutPosition = sizeInPt * 0.4;
                    if (pp.service.pdfFont.StrikeoutSize != 0) {
                        strikeoutSize = fontStrikeoutSize;
                        strikeoutPosition = fontStrikeoutPosition;
                    }
                    if (strikeoutSize < 0.1)
                        strikeoutSize = 0.1;
                    pp.service.pageStream.writeLine1('{0} w', pp.service.convertToString(strikeoutSize));
                    if (textAngle != 0) {
                        let AngleInRadians = textAngle * Math.PI / 180;
                        pp.service.pageStream.writeLine1('{0} {1} {2} {3} {4} {5} cm', pp.service.convertToString(Math.cos(AngleInRadians), 7), pp.service.convertToString(Math.sin(AngleInRadians), 7), pp.service.convertToString(-Math.sin(AngleInRadians), 7), pp.service.convertToString(Math.cos(AngleInRadians), 7), pp.service.convertToString(normTextX + normTextW / 2, 6), pp.service.convertToString(normTextY + normTextH / 2, 6));
                    }
                    pp.service.setStrokeColor(runInfo.textColor);
                    pp.service.pageStream.writeLine1('{0} {1} m', pp.service.convertToString(posX), pp.service.convertToString(posY + strikeoutPosition));
                    pp.service.pageStream.writeLine1('{0} {1} l S', pp.service.convertToString(posX + lineWidth), pp.service.convertToString(posY + strikeoutPosition));
                    pp.service.pageStream.writeLine('Q');
                    pp.service.popColorFromStack();
                }
                pp.service.pageStream.writeLine('Q');
                pp.service.popColorFromStack();
                if (pageNumber != -1 && !StiString.isNullOrWhiteSpace(runInfo.href) && !runInfo.href.trim().startsWith('javascript:') && !pp.service.usePdfA) {
                    let stl = new __.b.StiLinkObject();
                    stl.Link = runInfo.href;
                    stl.X = posX;
                    stl.Y = posY + fontDescF;
                    stl.Width = lineWidth;
                    stl.Height = fontLineHeight;
                    stl.Page = pageNumber;
                    stl.DestPage = -1;
                    stl.DestY = -1;
                    pp.service.linksArray.push(stl);
                }
            }
            if (text.linesOfUnderline != StiPenStyle.None) {
            }
            if (!needAnnots) {
                pp.service.pageStream.writeLine('Q');
                pp.service.popColorFromStack();
            }
        }
    };
    StiPdfRenderText.hiToTwips = 0.72;
    StiPdfRenderText.precision_digits_font = 3;
    StiPdfRenderText.fontCorrectValue = 0.955;
    StiPdfRenderText.boldFontStrokeWidthValue = 0.031;
    StiPdfRenderText.italicAngleTanValue = 0.325;
    StiPdfRenderText.charCode07 = String.fromCharCode(7);
    __.b.StiPdfRenderText = StiPdfRenderText;
}
{
    let StiPdfResources = class {
        static get standardFontCharsNames() {
            if (this._standardFontCharsNames == null) {
                let charsNames = [
                    '0020space',
                    '0021exclam',
                    '0022quotedbl',
                    '0023numbersign',
                    '0024dollar',
                    '0025percent',
                    '0026ampersand',
                    '0027quotesingle',
                    '0028parenleft',
                    '0029parenright',
                    '002Aasterisk',
                    '002Bplus',
                    '002Ccomma',
                    '002Dhyphen',
                    '002Eperiod',
                    '002Fslash',
                    '0030zero',
                    '0031one',
                    '0032two',
                    '0033three',
                    '0034four',
                    '0035five',
                    '0036six',
                    '0037seven',
                    '0038eight',
                    '0039nine',
                    '003Acolon',
                    '003Bsemicolon',
                    '003Cless',
                    '003Dequal',
                    '003Egreater',
                    '003Fquestion',
                    '0040at',
                    '0041A',
                    '0042B',
                    '0043C',
                    '0044D',
                    '0045E',
                    '0046F',
                    '0047G',
                    '0048H',
                    '0049I',
                    '004AJ',
                    '004BK',
                    '004CL',
                    '004DM',
                    '004EN',
                    '004FO',
                    '0050P',
                    '0051Q',
                    '0052R',
                    '0053S',
                    '0054T',
                    '0055U',
                    '0056V',
                    '0057W',
                    '0058X',
                    '0059Y',
                    '005AZ',
                    '005Bbracketleft',
                    '005Cbackslash',
                    '005Dbracketright',
                    '005Easciicircum',
                    '005Funderscore',
                    '0060grave',
                    '0061a',
                    '0062b',
                    '0063c',
                    '0064d',
                    '0065e',
                    '0066f',
                    '0067g',
                    '0068h',
                    '0069i',
                    '006Aj',
                    '006Bk',
                    '006Cl',
                    '006Dm',
                    '006En',
                    '006Fo',
                    '0070p',
                    '0071q',
                    '0072r',
                    '0073s',
                    '0074t',
                    '0075u',
                    '0076v',
                    '0077w',
                    '0078x',
                    '0079y',
                    '007Az',
                    '007Bbraceleft',
                    '007Cbar',
                    '007Dbraceright',
                    '007Easciitilde',
                    '007FcontrolDEL',
                    '00A0nbspace',
                    '00A1exclamdown',
                    '00A2cent',
                    '00A3sterling',
                    '00A4currency',
                    '00A5yen',
                    '00A6brokenbar',
                    '00A7section',
                    '00A8dieresis',
                    '00A9copyright',
                    '00AAordfeminine',
                    '00ABguillemotleft',
                    '00AClogicalnot',
                    '00ADsofthyphen',
                    '00AEregistered',
                    '00AFmacron',
                    '00B0degree',
                    '00B1plusminus',
                    '00B2twosuperior',
                    '00B3threesuperior',
                    '00B4acute',
                    '00B5mu',
                    '00B6paragraph',
                    '00B7periodcentered',
                    '00B8cedilla',
                    '00B9onesuperior',
                    '00BAordmasculine',
                    '00BBguillemotright',
                    '00BConequarter',
                    '00BDonehalf',
                    '00BEthreequarters',
                    '00BFquestiondown',
                    '00C0Agrave',
                    '00C1Aacute',
                    '00C2Acircumflex',
                    '00C3Atilde',
                    '00C4Adieresis',
                    '00C5Aring',
                    '00C6AE',
                    '00C7Ccedilla',
                    '00C8Egrave',
                    '00C9Eacute',
                    '00CAEcircumflex',
                    '00CBEdieresis',
                    '00CCIgrave',
                    '00CDIacute',
                    '00CEIcircumflex',
                    '00CFIdieresis',
                    '00D0Eth',
                    '00D1Ntilde',
                    '00D2Ograve',
                    '00D3Oacute',
                    '00D4Ocircumflex',
                    '00D5Otilde',
                    '00D6Odieresis',
                    '00D7multiply',
                    '00D8Oslash',
                    '00D9Ugrave',
                    '00DAUacute',
                    '00DBUcircumflex',
                    '00DCUdieresis',
                    '00DDYacute',
                    '00DEThorn',
                    '00DFgermandbls',
                    '00E0agrave',
                    '00E1aacute',
                    '00E2acircumflex',
                    '00E3atilde',
                    '00E4adieresis',
                    '00E5aring',
                    '00E6ae',
                    '00E7ccedilla',
                    '00E8egrave',
                    '00E9eacute',
                    '00EAecircumflex',
                    '00EBedieresis',
                    '00ECigrave',
                    '00EDiacute',
                    '00EEicircumflex',
                    '00EFidieresis',
                    '00F0eth',
                    '00F1ntilde',
                    '00F2ograve',
                    '00F3oacute',
                    '00F4ocircumflex',
                    '00F5otilde',
                    '00F6odieresis',
                    '00F7divide',
                    '00F8oslash',
                    '00F9ugrave',
                    '00FAuacute',
                    '00FBucircumflex',
                    '00FCudieresis',
                    '00FDyacute',
                    '00FEthorn',
                    '00FFydieresis',
                    '0100Amacron',
                    '0101amacron',
                    '0102Abreve',
                    '0103abreve',
                    '0104Aogonek',
                    '0105aogonek',
                    '0106Cacute',
                    '0107cacute',
                    '0108Ccircumflex',
                    '0109ccircumflex',
                    '010ACdotaccent',
                    '010Bcdotaccent',
                    '010CCcaron',
                    '010Dccaron',
                    '010EDcaron',
                    '010Fdcaron',
                    '0110Dcroat',
                    '0111dcroat',
                    '0112Emacron',
                    '0113emacron',
                    '0114Ebreve',
                    '0115ebreve',
                    '0116Edotaccent',
                    '0117edotaccent',
                    '0118Eogonek',
                    '0119eogonek',
                    '011AEcaron',
                    '011Becaron',
                    '011CGcircumflex',
                    '011Dgcircumflex',
                    '011EGbreve',
                    '011Fgbreve',
                    '0120Gdotaccent',
                    '0121gdotaccent',
                    '0122Gcommaaccent',
                    '0123gcommaaccent',
                    '0124Hcircumflex',
                    '0125hcircumflex',
                    '0126Hbar',
                    '0127hbar',
                    '0128Itilde',
                    '0129itilde',
                    '012AImacron',
                    '012Bimacron',
                    '012CIbreve',
                    '012Dibreve',
                    '012EIogonek',
                    '012Fiogonek',
                    '0130Idotaccent',
                    '0131dotlessi',
                    '0132IJ',
                    '0133ij',
                    '0134Jcircumflex',
                    '0135jcircumflex',
                    '0136Kcommaaccent',
                    '0137kcommaaccent',
                    '0138kgreenlandic',
                    '0139Lacute',
                    '013Alacute',
                    '013BLcommaaccent',
                    '013Clcommaaccent',
                    '013DLcaron',
                    '013Elcaron',
                    '013FLdot',
                    '0140ldot',
                    '0141Lslash',
                    '0142lslash',
                    '0143Nacute',
                    '0144nacute',
                    '0145Ncommaaccent',
                    '0146ncommaaccent',
                    '0147Ncaron',
                    '0148ncaron',
                    '0149napostrophe',
                    '014AEng',
                    '014Beng',
                    '014COmacron',
                    '014Domacron',
                    '014EObreve',
                    '014Fobreve',
                    '0150Ohungarumlaut',
                    '0151ohungarumlaut',
                    '0152OE',
                    '0153oe',
                    '0154Racute',
                    '0155racute',
                    '0156Rcommaaccent',
                    '0157rcommaaccent',
                    '0158Rcaron',
                    '0159rcaron',
                    '015ASacute',
                    '015Bsacute',
                    '015CScircumflex',
                    '015Dscircumflex',
                    '015EScedilla',
                    '015Fscedilla',
                    '0160Scaron',
                    '0161scaron',
                    '0162Tcommaaccent',
                    '0163tcommaaccent',
                    '0164Tcaron',
                    '0165tcaron',
                    '0166Tbar',
                    '0167tbar',
                    '0168Utilde',
                    '0169utilde',
                    '016AUmacron',
                    '016Bumacron',
                    '016CUbreve',
                    '016Dubreve',
                    '016EUring',
                    '016Furing',
                    '0170Uhungarumlaut',
                    '0171uhungarumlaut',
                    '0172Uogonek',
                    '0173uogonek',
                    '0174Wcircumflex',
                    '0175wcircumflex',
                    '0176Ycircumflex',
                    '0177ycircumflex',
                    '0178Ydieresis',
                    '0179Zacute',
                    '017Azacute',
                    '017BZdotaccent',
                    '017Czdotaccent',
                    '017DZcaron',
                    '017Ezcaron',
                    '017Flongs',
                    '0180bstroke',
                    '0181Bhook',
                    '0182Btopbar',
                    '0183btopbar',
                    '0184Tonesix',
                    '0185tonesix',
                    '0186Oopen',
                    '0187Chook',
                    '0188chook',
                    '0189Dafrican',
                    '018ADhook',
                    '018BDtopbar',
                    '018Cdtopbar',
                    '018Ddeltaturned',
                    '018EEreversed',
                    '018FSchwa',
                    '0190Eopen',
                    '0191Fhook',
                    '0192florin',
                    '0193Ghook',
                    '0194Gammaafrican',
                    '0195hv',
                    '0196Iotaafrican',
                    '0197Istroke',
                    '0198Khook',
                    '0199khook',
                    '019Albar',
                    '019Blambdastroke',
                    '019CMturned',
                    '019DNhookleft',
                    '019Enlegrightlong',
                    '019FOcenteredtilde',
                    '01A0Ohorn',
                    '01A1ohorn',
                    '01A2Oi',
                    '01A3oi',
                    '01A4Phook',
                    '01A5phook',
                    '01A6yr',
                    '01A7Tonetwo',
                    '01A8tonetwo',
                    '01A9Esh',
                    '01AAeshreversedloop',
                    '01ABtpalatalhook',
                    '01ACThook',
                    '01ADthook',
                    '01AETretroflexhook',
                    '01AFUhorn',
                    '01B0uhorn',
                    '01B1Upsilonafrican',
                    '01B2Vhook',
                    '01B3Yhook',
                    '01B4yhook',
                    '01B5Zstroke',
                    '01B6zstroke',
                    '01B7Ezh',
                    '01B8Ezhreversed',
                    '01B9ezhreversed',
                    '01BAezhtail',
                    '01BBtwostroke',
                    '01BCTonefive',
                    '01BDtonefive',
                    '01BEglottalinvertedstroke',
                    '01BFwynn',
                    '01C0clickdental',
                    '01C1clicklateral',
                    '01C2clickalveolar',
                    '01C3clickretroflex',
                    '01C4DZcaron',
                    '01C5Dzcaron',
                    '01C6dzcaron',
                    '01C7LJ',
                    '01C8Lj',
                    '01C9lj',
                    '01CANJ',
                    '01CBNj',
                    '01CCnj',
                    '01CDAcaron',
                    '01CEacaron',
                    '01CFIcaron',
                    '01D0icaron',
                    '01D1Ocaron',
                    '01D2ocaron',
                    '01D3Ucaron',
                    '01D4ucaron',
                    '01F0jcaron',
                    '01F1DZ',
                    '01F2Dz',
                    '01F3dz',
                    '01F4Gacute',
                    '01F5gacute',
                    '01FAAringacute',
                    '01FBaringacute',
                    '01FCAEacute',
                    '01FDaeacute',
                    '01FEOslashacute',
                    '01FFoslashacute',
                    '0254oopen',
                    '0255ccurl',
                    '0256dtail',
                    '0257dhook',
                    '0258ereversed',
                    '0259schwa',
                    '025Aschwahook',
                    '025Beopen',
                    '025Fjdotlessstroke',
                    '0260ghook',
                    '0261gscript',
                    '0264ramshorn',
                    '0265hturned',
                    '0266hhook',
                    '0267henghook',
                    '0268istroke',
                    '0269iotalatin',
                    '026Clbelt',
                    '026Elezh',
                    '026Fmturned',
                    '0271mhook',
                    '0272nhookleft',
                    '0275obarred',
                    '0278philatin',
                    '0279rturned',
                    '027Brhookturned',
                    '027Crlongleg',
                    '027Drhook',
                    '027Erfishhook',
                    '0282shook',
                    '0283esh',
                    '0286eshcurl',
                    '0287tturned',
                    '0289ubar',
                    '028Bvhook',
                    '028Cvturned',
                    '028Dwturned',
                    '028Eyturned',
                    '0290zretroflexhook',
                    '0291zcurl',
                    '0292ezh',
                    '0293ezhcurl',
                    '0294glottalstop',
                    '02A3dzaltone',
                    '02A4dezh',
                    '02A5dzcurl',
                    '02A6ts',
                    '02A7tesh',
                    '02A8tccurl',
                    '02D6plusmod',
                    '02D7minusmod',
                    '02D8breve',
                    '02D9dotaccent',
                    '02DAring',
                    '02DBogonek',
                    '02DCtilde',
                    '0391Alpha',
                    '0392Beta',
                    '0393Gamma',
                    '0394Deltagreek',
                    '0395Epsilon',
                    '0396Zeta',
                    '0397Eta',
                    '0398Theta',
                    '0399Iota',
                    '039AKappa',
                    '039BLambda',
                    '039CMu',
                    '039DNu',
                    '039EXi',
                    '039FOmicron',
                    '03A0Pi',
                    '03A1Rho',
                    '03A3Sigma',
                    '03A4Tau',
                    '03A5Upsilon',
                    '03A6Phi',
                    '03A7Chi',
                    '03A8Psi',
                    '03A9Omegagreek',
                    '03AAIotadieresis',
                    '03ABUpsilondieresis',
                    '03ACalphatonos',
                    '03ADepsilontonos',
                    '03AEetatonos',
                    '03AFiotatonos',
                    '03B0upsilondieresistonos',
                    '03B1alpha',
                    '03B2beta',
                    '03B3gamma',
                    '03B4delta',
                    '03B5epsilon',
                    '03B6zeta',
                    '03B7eta',
                    '03B8theta',
                    '03B9iota',
                    '03BAkappa',
                    '03BBlambda',
                    '03BCmu',
                    '03BDnu',
                    '03BExi',
                    '03BFomicron',
                    '03C0pi',
                    '03C1rho',
                    '03C2sigma1',
                    '03C3sigma',
                    '03C4tau',
                    '03C5upsilon',
                    '03C6phi',
                    '03C7chi',
                    '03C8psi',
                    '03C9omega',
                    '03CAiotadieresis',
                    '03CBupsilondieresis',
                    '03CComicrontonos',
                    '03CDupsilontonos',
                    '03CEomegatonos',
                    '03D0betasymbolgreek',
                    '03D1theta1',
                    '03D2Upsilon1',
                    '03D5phi1',
                    '03D6omega1',
                    '03DAStigmagreek',
                    '03DCDigammagreek',
                    '03DEKoppagreek',
                    '03E0Sampigreek',
                    '03E2Sheicoptic',
                    '03E3sheicoptic',
                    '03E4Feicoptic',
                    '03E5feicoptic',
                    '03E6Kheicoptic',
                    '03E7kheicoptic',
                    '03E8Horicoptic',
                    '03E9horicoptic',
                    '03EAGangiacoptic',
                    '03EBgangiacoptic',
                    '03ECShimacoptic',
                    '03EDshimacoptic',
                    '03EEDeicoptic',
                    '03EFdeicoptic',
                    '03F0kappasymbolgreek',
                    '03F1rhosymbolgreek',
                    '03F3yotgreek',
                    '0401afii10023',
                    '0402afii10051',
                    '0403afii10052',
                    '0404afii10053',
                    '0405afii10054',
                    '0406afii10055',
                    '0407afii10056',
                    '0408afii10057',
                    '0409afii10058',
                    '040Aafii10059',
                    '040Bafii10060',
                    '040Cafii10061',
                    '040Eafii10062',
                    '040Fafii10145',
                    '0410afii10017',
                    '0411afii10018',
                    '0412afii10019',
                    '0413afii10020',
                    '0414afii10021',
                    '0415afii10022',
                    '0416afii10024',
                    '0417afii10025',
                    '0418afii10026',
                    '0419afii10027',
                    '041Aafii10028',
                    '041Bafii10029',
                    '041Cafii10030',
                    '041Dafii10031',
                    '041Eafii10032',
                    '041Fafii10033',
                    '0420afii10034',
                    '0421afii10035',
                    '0422afii10036',
                    '0423afii10037',
                    '0424afii10038',
                    '0425afii10039',
                    '0426afii10040',
                    '0427afii10041',
                    '0428afii10042',
                    '0429afii10043',
                    '042Aafii10044',
                    '042Bafii10045',
                    '042Cafii10046',
                    '042Dafii10047',
                    '042Eafii10048',
                    '042Fafii10049',
                    '0430afii10065',
                    '0431afii10066',
                    '0432afii10067',
                    '0433afii10068',
                    '0434afii10069',
                    '0435afii10070',
                    '0436afii10072',
                    '0437afii10073',
                    '0438afii10074',
                    '0439afii10075',
                    '043Aafii10076',
                    '043Bafii10077',
                    '043Cafii10078',
                    '043Dafii10079',
                    '043Eafii10080',
                    '043Fafii10081',
                    '0440afii10082',
                    '0441afii10083',
                    '0442afii10084',
                    '0443afii10085',
                    '0444afii10086',
                    '0445afii10087',
                    '0446afii10088',
                    '0447afii10089',
                    '0448afii10090',
                    '0449afii10091',
                    '044Aafii10092',
                    '044Bafii10093',
                    '044Cafii10094',
                    '044Dafii10095',
                    '044Eafii10096',
                    '044Fafii10097',
                    '0451afii10071',
                    '0452afii10099',
                    '0453afii10100',
                    '0454afii10101',
                    '0455afii10102',
                    '0456afii10103',
                    '0457afii10104',
                    '0458afii10105',
                    '0459afii10106',
                    '045Aafii10107',
                    '045Bafii10108',
                    '045Cafii10109',
                    '045Eafii10110',
                    '045Fafii10193',
                    '0462afii10146',
                    '0463afii10194',
                    '0472afii10147',
                    '0473afii10195',
                    '0474afii10148',
                    '0475afii10196',
                    '0490afii10050',
                    '0491afii10098',
                    '04D9afii10846',
                    '060Cafii57388',
                    '061Bafii57403',
                    '061Fafii57407',
                    '0621afii57409',
                    '0622afii57410',
                    '0623afii57411',
                    '0624afii57412',
                    '0625afii57413',
                    '0626afii57414',
                    '0627afii57415',
                    '0628afii57416',
                    '0629afii57417',
                    '062Aafii57418',
                    '062Bafii57419',
                    '062Cafii57420',
                    '062Dafii57421',
                    '062Eafii57422',
                    '062Fafii57423',
                    '0630afii57424',
                    '0631afii57425',
                    '0632afii57426',
                    '0633afii57427',
                    '0634afii57428',
                    '0635afii57429',
                    '0636afii57430',
                    '0637afii57431',
                    '0638afii57432',
                    '0639afii57433',
                    '063Aafii57434',
                    '0640afii57440',
                    '0641afii57441',
                    '0642afii57442',
                    '0643afii57443',
                    '0644afii57444',
                    '0645afii57445',
                    '0646afii57446',
                    '0647afii57470',
                    '0648afii57448',
                    '0649afii57449',
                    '064Aafii57450',
                    '064Bafii57451',
                    '064Cafii57452',
                    '064Dafii57453',
                    '064Eafii57454',
                    '064Fafii57455',
                    '0650afii57456',
                    '0651afii57457',
                    '0652afii57458',
                    '0660afii57392',
                    '0661afii57393',
                    '0662afii57394',
                    '0663afii57395',
                    '0664afii57396',
                    '0665afii57397',
                    '0666afii57398',
                    '0667afii57399',
                    '0668afii57400',
                    '0669afii57401',
                    '066Aafii57381',
                    '066Bdecimalseparatorarabic',
                    '066Cthousandsseparatorarabic',
                    '066Dafii63167',
                    '0679afii57511',
                    '067Eafii57506',
                    '0686afii57507',
                    '0688afii57512',
                    '0691afii57513',
                    '0698afii57508',
                    '06A4afii57505',
                    '06AFafii57509',
                    '06BAafii57514',
                    '06C1hehaltonearabic',
                    '06D1yehthreedotsbelowarabic',
                    '06D2afii57519',
                    '06D5afii57534',
                    '06F0zeropersian',
                    '06F1onepersian',
                    '06F2twopersian',
                    '06F3threepersian',
                    '06F4fourpersian',
                    '06F5fivepersian',
                    '06F6sixpersian',
                    '06F7sevenpersian',
                    '06F8eightpersian',
                    '06F9ninepersian',
                    '1E00Aringbelow',
                    '1E01aringbelow',
                    '1E02Bdotaccent',
                    '1E03bdotaccent',
                    '1E04Bdotbelow',
                    '1E05bdotbelow',
                    '1E06Blinebelow',
                    '1E07blinebelow',
                    '1E08Ccedillaacute',
                    '1E09ccedillaacute',
                    '1E0ADdotaccent',
                    '1E0Bddotaccent',
                    '1E0CDdotbelow',
                    '1E0Dddotbelow',
                    '1E0EDlinebelow',
                    '1E0Fdlinebelow',
                    '1E10Dcedilla',
                    '1E11dcedilla',
                    '1E12Dcircumflexbelow',
                    '1E13dcircumflexbelow',
                    '1E14Emacrongrave',
                    '1E15emacrongrave',
                    '1E16Emacronacute',
                    '1E17emacronacute',
                    '1E18Ecircumflexbelow',
                    '1E19ecircumflexbelow',
                    '1E1AEtildebelow',
                    '1E1Betildebelow',
                    '1E1CEcedillabreve',
                    '1E1Decedillabreve',
                    '1E1EFdotaccent',
                    '1E1Ffdotaccent',
                    '1E20Gmacron',
                    '1E21gmacron',
                    '1E22Hdotaccent',
                    '1E23hdotaccent',
                    '1E24Hdotbelow',
                    '1E25hdotbelow',
                    '1E26Hdieresis',
                    '1E27hdieresis',
                    '1E28Hcedilla',
                    '1E29hcedilla',
                    '1E2AHbrevebelow',
                    '1E2Bhbrevebelow',
                    '1E2CItildebelow',
                    '1E2Ditildebelow',
                    '1E2EIdieresisacute',
                    '1E2Fidieresisacute',
                    '1E30Kacute',
                    '1E31kacute',
                    '1E32Kdotbelow',
                    '1E33kdotbelow',
                    '1E34Klinebelow',
                    '1E35klinebelow',
                    '1E36Ldotbelow',
                    '1E37ldotbelow',
                    '1E38Ldotbelowmacron',
                    '1E39ldotbelowmacron',
                    '1E3ALlinebelow',
                    '1E3Bllinebelow',
                    '1E3CLcircumflexbelow',
                    '1E3Dlcircumflexbelow',
                    '1E3EMacute',
                    '1E3Fmacute',
                    '1E40Mdotaccent',
                    '1E41mdotaccent',
                    '1E42Mdotbelow',
                    '1E43mdotbelow',
                    '1E44Ndotaccent',
                    '1E45ndotaccent',
                    '1E46Ndotbelow',
                    '1E47ndotbelow',
                    '1E48Nlinebelow',
                    '1E49nlinebelow',
                    '1E4ANcircumflexbelow',
                    '1E4Bncircumflexbelow',
                    '1E4COtildeacute',
                    '1E4Dotildeacute',
                    '1E4EOtildedieresis',
                    '1E4Fotildedieresis',
                    '1E50Omacrongrave',
                    '1E51omacrongrave',
                    '1E52Omacronacute',
                    '1E53omacronacute',
                    '1E54Pacute',
                    '1E55pacute',
                    '1E56Pdotaccent',
                    '1E57pdotaccent',
                    '1E58Rdotaccent',
                    '1E59rdotaccent',
                    '1E5ARdotbelow',
                    '1E5Brdotbelow',
                    '1E5CRdotbelowmacron',
                    '1E5Drdotbelowmacron',
                    '1E5ERlinebelow',
                    '1E5Frlinebelow',
                    '1E60Sdotaccent',
                    '1E61sdotaccent',
                    '1E62Sdotbelow',
                    '1E63sdotbelow',
                    '1E64Sacutedotaccent',
                    '1E65sacutedotaccent',
                    '1E66Scarondotaccent',
                    '1E67scarondotaccent',
                    '1E68Sdotbelowdotaccent',
                    '1E69sdotbelowdotaccent',
                    '1E6ATdotaccent',
                    '1E6Btdotaccent',
                    '1E6CTdotbelow',
                    '1E6Dtdotbelow',
                    '1E6ETlinebelow',
                    '1E6Ftlinebelow',
                    '1E70Tcircumflexbelow',
                    '1E71tcircumflexbelow',
                    '1E72Udieresisbelow',
                    '1E73udieresisbelow',
                    '1E74Utildebelow',
                    '1E75utildebelow',
                    '1E76Ucircumflexbelow',
                    '1E77ucircumflexbelow',
                    '1E78Utildeacute',
                    '1E79utildeacute',
                    '1E7AUmacrondieresis',
                    '1E7Bumacrondieresis',
                    '1E7CVtilde',
                    '1E7Dvtilde',
                    '1E7EVdotbelow',
                    '1E7Fvdotbelow',
                    '1E80Wgrave',
                    '1E81wgrave',
                    '1E82Wacute',
                    '1E83wacute',
                    '1E84Wdieresis',
                    '1E85wdieresis',
                    '1E86Wdotaccent',
                    '1E87wdotaccent',
                    '1E88Wdotbelow',
                    '1E89wdotbelow',
                    '1E8AXdotaccent',
                    '1E8Bxdotaccent',
                    '1E8CXdieresis',
                    '1E8Dxdieresis',
                    '1E8EYdotaccent',
                    '1E8Fydotaccent',
                    '1E90Zcircumflex',
                    '1E91zcircumflex',
                    '1E92Zdotbelow',
                    '1E93zdotbelow',
                    '1E94Zlinebelow',
                    '1E95zlinebelow',
                    '1E96hlinebelow',
                    '1E97tdieresis',
                    '1E98wring',
                    '1E99yring',
                    '1E9Aarighthalfring',
                    '1E9Bslongdotaccent',
                    '1EA0Adotbelow',
                    '1EA1adotbelow',
                    '1EA2Ahookabove',
                    '1EA3ahookabove',
                    '1EA4Acircumflexacute',
                    '1EA5acircumflexacute',
                    '1EA6Acircumflexgrave',
                    '1EA7acircumflexgrave',
                    '1EA8Acircumflexhookabove',
                    '1EA9acircumflexhookabove',
                    '1EAAAcircumflextilde',
                    '1EABacircumflextilde',
                    '1EACAcircumflexdotbelow',
                    '1EADacircumflexdotbelow',
                    '1EAEAbreveacute',
                    '1EAFabreveacute',
                    '1EB0Abrevegrave',
                    '1EB1abrevegrave',
                    '1EB2Abrevehookabove',
                    '1EB3abrevehookabove',
                    '1EB4Abrevetilde',
                    '1EB5abrevetilde',
                    '1EB6Abrevedotbelow',
                    '1EB7abrevedotbelow',
                    '1EB8Edotbelow',
                    '1EB9edotbelow',
                    '1EBAEhookabove',
                    '1EBBehookabove',
                    '1EBCEtilde',
                    '1EBDetilde',
                    '1EBEEcircumflexacute',
                    '1EBFecircumflexacute',
                    '1EC0Ecircumflexgrave',
                    '1EC1ecircumflexgrave',
                    '1EC2Ecircumflexhookabove',
                    '1EC3ecircumflexhookabove',
                    '1EC4Ecircumflextilde',
                    '1EC5ecircumflextilde',
                    '1EC6Ecircumflexdotbelow',
                    '1EC7ecircumflexdotbelow',
                    '1EC8Ihookabove',
                    '1EC9ihookabove',
                    '1ECAIdotbelow',
                    '1ECBidotbelow',
                    '1ECCOdotbelow',
                    '1ECDodotbelow',
                    '1ECEOhookabove',
                    '1ECFohookabove',
                    '1ED0Ocircumflexacute',
                    '1ED1ocircumflexacute',
                    '1ED2Ocircumflexgrave',
                    '1ED3ocircumflexgrave',
                    '1ED4Ocircumflexhookabove',
                    '1ED5ocircumflexhookabove',
                    '1ED6Ocircumflextilde',
                    '1ED7ocircumflextilde',
                    '1ED8Ocircumflexdotbelow',
                    '1ED9ocircumflexdotbelow',
                    '1EDAOhornacute',
                    '1EDBohornacute',
                    '1EDCOhorngrave',
                    '1EDDohorngrave',
                    '1EDEOhornhookabove',
                    '1EDFohornhookabove',
                    '1EE0Ohorntilde',
                    '1EE1ohorntilde',
                    '1EE2Ohorndotbelow',
                    '1EE3ohorndotbelow',
                    '1EE4Udotbelow',
                    '1EE5udotbelow',
                    '1EE6Uhookabove',
                    '1EE7uhookabove',
                    '1EE8Uhornacute',
                    '1EE9uhornacute',
                    '1EEAUhorngrave',
                    '1EEBuhorngrave',
                    '1EECUhornhookabove',
                    '1EEDuhornhookabove',
                    '1EEEUhorntilde',
                    '1EEFuhorntilde',
                    '1EF0Uhorndotbelow',
                    '1EF1uhorndotbelow',
                    '1EF2Ygrave',
                    '1EF3ygrave',
                    '1EF4Ydotbelow',
                    '1EF5ydotbelow',
                    '1EF6Yhookabove',
                    '1EF7yhookabove',
                    '1EF8Ytilde',
                    '1EF9ytilde',
                    '2002enspace',
                    '200Bzerowidthspace',
                    '200Cafii61664',
                    '200Dafii301',
                    '200Eafii299',
                    '200Fafii300',
                    '2010hyphentwo',
                    '2012figuredash',
                    '2013endash',
                    '2014emdash',
                    '2015afii00208',
                    '2016dblverticalbar',
                    '2017underscoredbl',
                    '2018quoteleft',
                    '2019quoteright',
                    '201Aquotesinglbase',
                    '201Bquotereversed',
                    '201Cquotedblleft',
                    '201Dquotedblright',
                    '201Equotedblbase',
                    '2020dagger',
                    '2021daggerdbl',
                    '2022bullet',
                    '2024onedotenleader',
                    '2025twodotenleader',
                    '2026ellipsis',
                    '202Cafii61573',
                    '202Dafii61574',
                    '202Eafii61575',
                    '2030perthousand',
                    '2032minute',
                    '2033second',
                    '2035primereversed',
                    '2039guilsinglleft',
                    '203Aguilsinglright',
                    '203Breferencemark',
                    '203Cexclamdbl',
                    '203Eoverline',
                    '2042asterism',
                    '2044fraction',
                    '2070zerosuperior',
                    '2074foursuperior',
                    '2075fivesuperior',
                    '2076sixsuperior',
                    '2077sevensuperior',
                    '2078eightsuperior',
                    '2079ninesuperior',
                    '207Aplussuperior',
                    '207Cequalsuperior',
                    '207Dparenleftsuperior',
                    '207Eparenrightsuperior',
                    '207Fnsuperior',
                    '2080zeroinferior',
                    '2081oneinferior',
                    '2082twoinferior',
                    '2083threeinferior',
                    '2084fourinferior',
                    '2085fiveinferior',
                    '2086sixinferior',
                    '2087seveninferior',
                    '2088eightinferior',
                    '2089nineinferior',
                    '208Dparenleftinferior',
                    '208Eparenrightinferior',
                    '20A1colonmonetary',
                    '20A2cruzeiro',
                    '20A3franc',
                    '20A4afii08941',
                    '20A7peseta',
                    '20A9won',
                    '20AAafii57636',
                    '20ABdong',
                    '20ACEuro',
                    '2103centigrade',
                    '2105afii61248',
                    '2109fahrenheit',
                    '2111Ifraktur',
                    '2113afii61289',
                    '2116afii61352',
                    '2118weierstrass',
                    '211CRfraktur',
                    '211Eprescription',
                    '2121telephone',
                    '2122trademark',
                    '2126Omega',
                    '212Bangstrom',
                    '212Eestimated',
                    '2135aleph',
                    '2153onethird',
                    '2154twothirds',
                    '215Boneeighth',
                    '215Cthreeeighths',
                    '215Dfiveeighths',
                    '215Eseveneighths',
                    '2160Oneroman',
                    '2161Tworoman',
                    '2162Threeroman',
                    '2163Fourroman',
                    '2164Fiveroman',
                    '2165Sixroman',
                    '2166Sevenroman',
                    '2167Eightroman',
                    '2168Nineroman',
                    '2169Tenroman',
                    '216AElevenroman',
                    '216BTwelveroman',
                    '2170oneroman',
                    '2171tworoman',
                    '2172threeroman',
                    '2173fourroman',
                    '2174fiveroman',
                    '2175sixroman',
                    '2176sevenroman',
                    '2177eightroman',
                    '2178nineroman',
                    '2179tenroman',
                    '217Aelevenroman',
                    '217Btwelveroman',
                    '2200universal',
                    '2202partialdiff',
                    '2203existential',
                    '2205emptyset',
                    '2206Delta',
                    '2207gradient',
                    '2208element',
                    '2209notelement',
                    '220Bsuchthat',
                    '220Cnotcontains',
                    '220Fproduct',
                    '2211summation',
                    '2212minus',
                    '2213minusplus',
                    '2215divisionslash',
                    '2217asteriskmath',
                    '2219bulletoperator',
                    '221Aradical',
                    '221Dproportional',
                    '221Einfinity',
                    '221Forthogonal',
                    '2220angle',
                    '2223divides',
                    '2225parallel',
                    '2226notparallel',
                    '2227logicaland',
                    '2228logicalor',
                    '2229intersection',
                    '222Aunion',
                    '222Bintegral',
                    '222Cdblintegral',
                    '222Econtourintegral',
                    '2234therefore',
                    '2235because',
                    '2236ratio',
                    '2237proportion',
                    '223Csimilar',
                    '223Dreversedtilde',
                    '2243asymptoticallyequal',
                    '2245congruent',
                    '2248approxequal',
                    '224Callequal',
                    '2250approaches',
                    '2251geometricallyequal',
                    '2252approxequalorimage',
                    '2253imageorapproximatelyequal',
                    '2260notequal',
                    '2261equivalence',
                    '2262notidentical',
                    '2264lessequal',
                    '2265greaterequal',
                    '2266lessoverequal',
                    '2267greateroverequal',
                    '226Amuchless',
                    '226Bmuchgreater',
                    '226Enotless',
                    '226Fnotgreater',
                    '2270notlessnorequal',
                    '2271notgreaternorequal',
                    '2272lessorequivalent',
                    '2273greaterorequivalent',
                    '2276lessorgreater',
                    '2277greaterorless',
                    '2279notgreaternorless',
                    '227Aprecedes',
                    '227Bsucceeds',
                    '2280notprecedes',
                    '2281notsucceeds',
                    '2282propersubset',
                    '2283propersuperset',
                    '2284notsubset',
                    '2285notsuperset',
                    '2286reflexsubset',
                    '2287reflexsuperset',
                    '228Asubsetnotequal',
                    '228Bsupersetnotequal',
                    '2295circleplus',
                    '2296minuscircle',
                    '2297circlemultiply',
                    '2299circleot',
                    '22A3tackleft',
                    '22A4tackdown',
                    '22A5perpendicular',
                    '22BFrighttriangle',
                    '22C5dotmath',
                    '22CEcurlyor',
                    '22CFcurlyand',
                    '22DAlessequalorgreater',
                    '22DBgreaterequalorless',
                    '22EEellipsisvertical',
                    'F6BEdotlessj',
                    'F6BFLL',
                    'F6C0ll',
                    'F6C3commaaccent',
                    'F6C4afii10063',
                    'F6C5afii10064',
                    'F6C6afii10192',
                    'F6C7afii10831',
                    'F6C8afii10832',
                    'F6C9Acute',
                    'F6CACaron',
                    'F6CBDieresis',
                    'F6CCDieresisAcute',
                    'F6CDDieresisGrave',
                    'F6CEGrave',
                    'F6CFHungarumlaut',
                    'F6D0Macron',
                    'F6D1cyrBreve',
                    'F6D2cyrFlex',
                    'F6D3dblGrave',
                    'F6D4cyrbreve',
                    'F6D5cyrflex',
                    'F6D6dblgrave',
                    'F6D7dieresisacute',
                    'F6D8dieresisgrave',
                    'F6D9copyrightserif',
                    'F6DAregisterserif',
                    'F6DBtrademarkserif',
                    'F6DConefitted',
                    'F6DDrupiah',
                    'F8FFapple',
                    'FB00ff',
                    'FB01fi',
                    'FB02fl',
                    'FB03ffi',
                    'FB04ffl',
                    'FE61asterisksmall',
                    'FE62plussmall',
                    'FE63hyphensmall',
                    'FE64lesssmall',
                    'FE65greatersmall',
                    'FE66equalsmall',
                    'FE69dollarsmall',
                    'FE6Apercentsmall',
                    'FE6Batsmall'
                ];
                this._standardFontCharsNames = [];
                for (let indexTemp = 0; indexTemp < charsNames.length; indexTemp++) {
                    let code = parseInt(charsNames[indexTemp].substr(0, 4), 16);
                    this._standardFontCharsNames[code] = charsNames[indexTemp].substr(4);
                }
            }
            return this._standardFontCharsNames;
        }
    };
    StiPdfResources.sRGBprofile = [
        0,
        0,
        12,
        72,
        76,
        105,
        110,
        111,
        2,
        16,
        0,
        0,
        109,
        110,
        116,
        114,
        82,
        71,
        66,
        32,
        88,
        89,
        90,
        32,
        7,
        206,
        0,
        2,
        0,
        9,
        0,
        6,
        0,
        49,
        0,
        0,
        97,
        99,
        115,
        112,
        77,
        83,
        70,
        84,
        0,
        0,
        0,
        0,
        73,
        69,
        67,
        32,
        115,
        82,
        71,
        66,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        246,
        214,
        0,
        1,
        0,
        0,
        0,
        0,
        211,
        45,
        72,
        80,
        32,
        32,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        17,
        99,
        112,
        114,
        116,
        0,
        0,
        1,
        80,
        0,
        0,
        0,
        51,
        100,
        101,
        115,
        99,
        0,
        0,
        1,
        132,
        0,
        0,
        0,
        108,
        119,
        116,
        112,
        116,
        0,
        0,
        1,
        240,
        0,
        0,
        0,
        20,
        98,
        107,
        112,
        116,
        0,
        0,
        2,
        4,
        0,
        0,
        0,
        20,
        114,
        88,
        89,
        90,
        0,
        0,
        2,
        24,
        0,
        0,
        0,
        20,
        103,
        88,
        89,
        90,
        0,
        0,
        2,
        44,
        0,
        0,
        0,
        20,
        98,
        88,
        89,
        90,
        0,
        0,
        2,
        64,
        0,
        0,
        0,
        20,
        100,
        109,
        110,
        100,
        0,
        0,
        2,
        84,
        0,
        0,
        0,
        112,
        100,
        109,
        100,
        100,
        0,
        0,
        2,
        196,
        0,
        0,
        0,
        136,
        118,
        117,
        101,
        100,
        0,
        0,
        3,
        76,
        0,
        0,
        0,
        134,
        118,
        105,
        101,
        119,
        0,
        0,
        3,
        212,
        0,
        0,
        0,
        36,
        108,
        117,
        109,
        105,
        0,
        0,
        3,
        248,
        0,
        0,
        0,
        20,
        109,
        101,
        97,
        115,
        0,
        0,
        4,
        12,
        0,
        0,
        0,
        36,
        116,
        101,
        99,
        104,
        0,
        0,
        4,
        48,
        0,
        0,
        0,
        12,
        114,
        84,
        82,
        67,
        0,
        0,
        4,
        60,
        0,
        0,
        8,
        12,
        103,
        84,
        82,
        67,
        0,
        0,
        4,
        60,
        0,
        0,
        8,
        12,
        98,
        84,
        82,
        67,
        0,
        0,
        4,
        60,
        0,
        0,
        8,
        12,
        116,
        101,
        120,
        116,
        0,
        0,
        0,
        0,
        67,
        111,
        112,
        121,
        114,
        105,
        103,
        104,
        116,
        32,
        40,
        99,
        41,
        32,
        49,
        57,
        57,
        56,
        32,
        72,
        101,
        119,
        108,
        101,
        116,
        116,
        45,
        80,
        97,
        99,
        107,
        97,
        114,
        100,
        32,
        67,
        111,
        109,
        112,
        97,
        110,
        121,
        0,
        0,
        100,
        101,
        115,
        99,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        18,
        115,
        82,
        71,
        66,
        32,
        73,
        69,
        67,
        54,
        49,
        57,
        54,
        54,
        45,
        50,
        46,
        49,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        18,
        115,
        82,
        71,
        66,
        32,
        73,
        69,
        67,
        54,
        49,
        57,
        54,
        54,
        45,
        50,
        46,
        49,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        88,
        89,
        90,
        32,
        0,
        0,
        0,
        0,
        0,
        0,
        243,
        81,
        0,
        1,
        0,
        0,
        0,
        1,
        22,
        204,
        88,
        89,
        90,
        32,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        88,
        89,
        90,
        32,
        0,
        0,
        0,
        0,
        0,
        0,
        111,
        162,
        0,
        0,
        56,
        245,
        0,
        0,
        3,
        144,
        88,
        89,
        90,
        32,
        0,
        0,
        0,
        0,
        0,
        0,
        98,
        153,
        0,
        0,
        183,
        133,
        0,
        0,
        24,
        218,
        88,
        89,
        90,
        32,
        0,
        0,
        0,
        0,
        0,
        0,
        36,
        160,
        0,
        0,
        15,
        132,
        0,
        0,
        182,
        207,
        100,
        101,
        115,
        99,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        22,
        73,
        69,
        67,
        32,
        104,
        116,
        116,
        112,
        58,
        47,
        47,
        119,
        119,
        119,
        46,
        105,
        101,
        99,
        46,
        99,
        104,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        22,
        73,
        69,
        67,
        32,
        104,
        116,
        116,
        112,
        58,
        47,
        47,
        119,
        119,
        119,
        46,
        105,
        101,
        99,
        46,
        99,
        104,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        100,
        101,
        115,
        99,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        46,
        73,
        69,
        67,
        32,
        54,
        49,
        57,
        54,
        54,
        45,
        50,
        46,
        49,
        32,
        68,
        101,
        102,
        97,
        117,
        108,
        116,
        32,
        82,
        71,
        66,
        32,
        99,
        111,
        108,
        111,
        117,
        114,
        32,
        115,
        112,
        97,
        99,
        101,
        32,
        45,
        32,
        115,
        82,
        71,
        66,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        46,
        73,
        69,
        67,
        32,
        54,
        49,
        57,
        54,
        54,
        45,
        50,
        46,
        49,
        32,
        68,
        101,
        102,
        97,
        117,
        108,
        116,
        32,
        82,
        71,
        66,
        32,
        99,
        111,
        108,
        111,
        117,
        114,
        32,
        115,
        112,
        97,
        99,
        101,
        32,
        45,
        32,
        115,
        82,
        71,
        66,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        100,
        101,
        115,
        99,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        44,
        82,
        101,
        102,
        101,
        114,
        101,
        110,
        99,
        101,
        32,
        86,
        105,
        101,
        119,
        105,
        110,
        103,
        32,
        67,
        111,
        110,
        100,
        105,
        116,
        105,
        111,
        110,
        32,
        105,
        110,
        32,
        73,
        69,
        67,
        54,
        49,
        57,
        54,
        54,
        45,
        50,
        46,
        49,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        44,
        82,
        101,
        102,
        101,
        114,
        101,
        110,
        99,
        101,
        32,
        86,
        105,
        101,
        119,
        105,
        110,
        103,
        32,
        67,
        111,
        110,
        100,
        105,
        116,
        105,
        111,
        110,
        32,
        105,
        110,
        32,
        73,
        69,
        67,
        54,
        49,
        57,
        54,
        54,
        45,
        50,
        46,
        49,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        118,
        105,
        101,
        119,
        0,
        0,
        0,
        0,
        0,
        19,
        164,
        254,
        0,
        20,
        95,
        46,
        0,
        16,
        207,
        20,
        0,
        3,
        237,
        204,
        0,
        4,
        19,
        11,
        0,
        3,
        92,
        158,
        0,
        0,
        0,
        1,
        88,
        89,
        90,
        32,
        0,
        0,
        0,
        0,
        0,
        76,
        9,
        86,
        0,
        80,
        0,
        0,
        0,
        87,
        31,
        231,
        109,
        101,
        97,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        143,
        0,
        0,
        0,
        2,
        115,
        105,
        103,
        32,
        0,
        0,
        0,
        0,
        67,
        82,
        84,
        32,
        99,
        117,
        114,
        118,
        0,
        0,
        0,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        0,
        5,
        0,
        10,
        0,
        15,
        0,
        20,
        0,
        25,
        0,
        30,
        0,
        35,
        0,
        40,
        0,
        45,
        0,
        50,
        0,
        55,
        0,
        59,
        0,
        64,
        0,
        69,
        0,
        74,
        0,
        79,
        0,
        84,
        0,
        89,
        0,
        94,
        0,
        99,
        0,
        104,
        0,
        109,
        0,
        114,
        0,
        119,
        0,
        124,
        0,
        129,
        0,
        134,
        0,
        139,
        0,
        144,
        0,
        149,
        0,
        154,
        0,
        159,
        0,
        164,
        0,
        169,
        0,
        174,
        0,
        178,
        0,
        183,
        0,
        188,
        0,
        193,
        0,
        198,
        0,
        203,
        0,
        208,
        0,
        213,
        0,
        219,
        0,
        224,
        0,
        229,
        0,
        235,
        0,
        240,
        0,
        246,
        0,
        251,
        1,
        1,
        1,
        7,
        1,
        13,
        1,
        19,
        1,
        25,
        1,
        31,
        1,
        37,
        1,
        43,
        1,
        50,
        1,
        56,
        1,
        62,
        1,
        69,
        1,
        76,
        1,
        82,
        1,
        89,
        1,
        96,
        1,
        103,
        1,
        110,
        1,
        117,
        1,
        124,
        1,
        131,
        1,
        139,
        1,
        146,
        1,
        154,
        1,
        161,
        1,
        169,
        1,
        177,
        1,
        185,
        1,
        193,
        1,
        201,
        1,
        209,
        1,
        217,
        1,
        225,
        1,
        233,
        1,
        242,
        1,
        250,
        2,
        3,
        2,
        12,
        2,
        20,
        2,
        29,
        2,
        38,
        2,
        47,
        2,
        56,
        2,
        65,
        2,
        75,
        2,
        84,
        2,
        93,
        2,
        103,
        2,
        113,
        2,
        122,
        2,
        132,
        2,
        142,
        2,
        152,
        2,
        162,
        2,
        172,
        2,
        182,
        2,
        193,
        2,
        203,
        2,
        213,
        2,
        224,
        2,
        235,
        2,
        245,
        3,
        0,
        3,
        11,
        3,
        22,
        3,
        33,
        3,
        45,
        3,
        56,
        3,
        67,
        3,
        79,
        3,
        90,
        3,
        102,
        3,
        114,
        3,
        126,
        3,
        138,
        3,
        150,
        3,
        162,
        3,
        174,
        3,
        186,
        3,
        199,
        3,
        211,
        3,
        224,
        3,
        236,
        3,
        249,
        4,
        6,
        4,
        19,
        4,
        32,
        4,
        45,
        4,
        59,
        4,
        72,
        4,
        85,
        4,
        99,
        4,
        113,
        4,
        126,
        4,
        140,
        4,
        154,
        4,
        168,
        4,
        182,
        4,
        196,
        4,
        211,
        4,
        225,
        4,
        240,
        4,
        254,
        5,
        13,
        5,
        28,
        5,
        43,
        5,
        58,
        5,
        73,
        5,
        88,
        5,
        103,
        5,
        119,
        5,
        134,
        5,
        150,
        5,
        166,
        5,
        181,
        5,
        197,
        5,
        213,
        5,
        229,
        5,
        246,
        6,
        6,
        6,
        22,
        6,
        39,
        6,
        55,
        6,
        72,
        6,
        89,
        6,
        106,
        6,
        123,
        6,
        140,
        6,
        157,
        6,
        175,
        6,
        192,
        6,
        209,
        6,
        227,
        6,
        245,
        7,
        7,
        7,
        25,
        7,
        43,
        7,
        61,
        7,
        79,
        7,
        97,
        7,
        116,
        7,
        134,
        7,
        153,
        7,
        172,
        7,
        191,
        7,
        210,
        7,
        229,
        7,
        248,
        8,
        11,
        8,
        31,
        8,
        50,
        8,
        70,
        8,
        90,
        8,
        110,
        8,
        130,
        8,
        150,
        8,
        170,
        8,
        190,
        8,
        210,
        8,
        231,
        8,
        251,
        9,
        16,
        9,
        37,
        9,
        58,
        9,
        79,
        9,
        100,
        9,
        121,
        9,
        143,
        9,
        164,
        9,
        186,
        9,
        207,
        9,
        229,
        9,
        251,
        10,
        17,
        10,
        39,
        10,
        61,
        10,
        84,
        10,
        106,
        10,
        129,
        10,
        152,
        10,
        174,
        10,
        197,
        10,
        220,
        10,
        243,
        11,
        11,
        11,
        34,
        11,
        57,
        11,
        81,
        11,
        105,
        11,
        128,
        11,
        152,
        11,
        176,
        11,
        200,
        11,
        225,
        11,
        249,
        12,
        18,
        12,
        42,
        12,
        67,
        12,
        92,
        12,
        117,
        12,
        142,
        12,
        167,
        12,
        192,
        12,
        217,
        12,
        243,
        13,
        13,
        13,
        38,
        13,
        64,
        13,
        90,
        13,
        116,
        13,
        142,
        13,
        169,
        13,
        195,
        13,
        222,
        13,
        248,
        14,
        19,
        14,
        46,
        14,
        73,
        14,
        100,
        14,
        127,
        14,
        155,
        14,
        182,
        14,
        210,
        14,
        238,
        15,
        9,
        15,
        37,
        15,
        65,
        15,
        94,
        15,
        122,
        15,
        150,
        15,
        179,
        15,
        207,
        15,
        236,
        16,
        9,
        16,
        38,
        16,
        67,
        16,
        97,
        16,
        126,
        16,
        155,
        16,
        185,
        16,
        215,
        16,
        245,
        17,
        19,
        17,
        49,
        17,
        79,
        17,
        109,
        17,
        140,
        17,
        170,
        17,
        201,
        17,
        232,
        18,
        7,
        18,
        38,
        18,
        69,
        18,
        100,
        18,
        132,
        18,
        163,
        18,
        195,
        18,
        227,
        19,
        3,
        19,
        35,
        19,
        67,
        19,
        99,
        19,
        131,
        19,
        164,
        19,
        197,
        19,
        229,
        20,
        6,
        20,
        39,
        20,
        73,
        20,
        106,
        20,
        139,
        20,
        173,
        20,
        206,
        20,
        240,
        21,
        18,
        21,
        52,
        21,
        86,
        21,
        120,
        21,
        155,
        21,
        189,
        21,
        224,
        22,
        3,
        22,
        38,
        22,
        73,
        22,
        108,
        22,
        143,
        22,
        178,
        22,
        214,
        22,
        250,
        23,
        29,
        23,
        65,
        23,
        101,
        23,
        137,
        23,
        174,
        23,
        210,
        23,
        247,
        24,
        27,
        24,
        64,
        24,
        101,
        24,
        138,
        24,
        175,
        24,
        213,
        24,
        250,
        25,
        32,
        25,
        69,
        25,
        107,
        25,
        145,
        25,
        183,
        25,
        221,
        26,
        4,
        26,
        42,
        26,
        81,
        26,
        119,
        26,
        158,
        26,
        197,
        26,
        236,
        27,
        20,
        27,
        59,
        27,
        99,
        27,
        138,
        27,
        178,
        27,
        218,
        28,
        2,
        28,
        42,
        28,
        82,
        28,
        123,
        28,
        163,
        28,
        204,
        28,
        245,
        29,
        30,
        29,
        71,
        29,
        112,
        29,
        153,
        29,
        195,
        29,
        236,
        30,
        22,
        30,
        64,
        30,
        106,
        30,
        148,
        30,
        190,
        30,
        233,
        31,
        19,
        31,
        62,
        31,
        105,
        31,
        148,
        31,
        191,
        31,
        234,
        32,
        21,
        32,
        65,
        32,
        108,
        32,
        152,
        32,
        196,
        32,
        240,
        33,
        28,
        33,
        72,
        33,
        117,
        33,
        161,
        33,
        206,
        33,
        251,
        34,
        39,
        34,
        85,
        34,
        130,
        34,
        175,
        34,
        221,
        35,
        10,
        35,
        56,
        35,
        102,
        35,
        148,
        35,
        194,
        35,
        240,
        36,
        31,
        36,
        77,
        36,
        124,
        36,
        171,
        36,
        218,
        37,
        9,
        37,
        56,
        37,
        104,
        37,
        151,
        37,
        199,
        37,
        247,
        38,
        39,
        38,
        87,
        38,
        135,
        38,
        183,
        38,
        232,
        39,
        24,
        39,
        73,
        39,
        122,
        39,
        171,
        39,
        220,
        40,
        13,
        40,
        63,
        40,
        113,
        40,
        162,
        40,
        212,
        41,
        6,
        41,
        56,
        41,
        107,
        41,
        157,
        41,
        208,
        42,
        2,
        42,
        53,
        42,
        104,
        42,
        155,
        42,
        207,
        43,
        2,
        43,
        54,
        43,
        105,
        43,
        157,
        43,
        209,
        44,
        5,
        44,
        57,
        44,
        110,
        44,
        162,
        44,
        215,
        45,
        12,
        45,
        65,
        45,
        118,
        45,
        171,
        45,
        225,
        46,
        22,
        46,
        76,
        46,
        130,
        46,
        183,
        46,
        238,
        47,
        36,
        47,
        90,
        47,
        145,
        47,
        199,
        47,
        254,
        48,
        53,
        48,
        108,
        48,
        164,
        48,
        219,
        49,
        18,
        49,
        74,
        49,
        130,
        49,
        186,
        49,
        242,
        50,
        42,
        50,
        99,
        50,
        155,
        50,
        212,
        51,
        13,
        51,
        70,
        51,
        127,
        51,
        184,
        51,
        241,
        52,
        43,
        52,
        101,
        52,
        158,
        52,
        216,
        53,
        19,
        53,
        77,
        53,
        135,
        53,
        194,
        53,
        253,
        54,
        55,
        54,
        114,
        54,
        174,
        54,
        233,
        55,
        36,
        55,
        96,
        55,
        156,
        55,
        215,
        56,
        20,
        56,
        80,
        56,
        140,
        56,
        200,
        57,
        5,
        57,
        66,
        57,
        127,
        57,
        188,
        57,
        249,
        58,
        54,
        58,
        116,
        58,
        178,
        58,
        239,
        59,
        45,
        59,
        107,
        59,
        170,
        59,
        232,
        60,
        39,
        60,
        101,
        60,
        164,
        60,
        227,
        61,
        34,
        61,
        97,
        61,
        161,
        61,
        224,
        62,
        32,
        62,
        96,
        62,
        160,
        62,
        224,
        63,
        33,
        63,
        97,
        63,
        162,
        63,
        226,
        64,
        35,
        64,
        100,
        64,
        166,
        64,
        231,
        65,
        41,
        65,
        106,
        65,
        172,
        65,
        238,
        66,
        48,
        66,
        114,
        66,
        181,
        66,
        247,
        67,
        58,
        67,
        125,
        67,
        192,
        68,
        3,
        68,
        71,
        68,
        138,
        68,
        206,
        69,
        18,
        69,
        85,
        69,
        154,
        69,
        222,
        70,
        34,
        70,
        103,
        70,
        171,
        70,
        240,
        71,
        53,
        71,
        123,
        71,
        192,
        72,
        5,
        72,
        75,
        72,
        145,
        72,
        215,
        73,
        29,
        73,
        99,
        73,
        169,
        73,
        240,
        74,
        55,
        74,
        125,
        74,
        196,
        75,
        12,
        75,
        83,
        75,
        154,
        75,
        226,
        76,
        42,
        76,
        114,
        76,
        186,
        77,
        2,
        77,
        74,
        77,
        147,
        77,
        220,
        78,
        37,
        78,
        110,
        78,
        183,
        79,
        0,
        79,
        73,
        79,
        147,
        79,
        221,
        80,
        39,
        80,
        113,
        80,
        187,
        81,
        6,
        81,
        80,
        81,
        155,
        81,
        230,
        82,
        49,
        82,
        124,
        82,
        199,
        83,
        19,
        83,
        95,
        83,
        170,
        83,
        246,
        84,
        66,
        84,
        143,
        84,
        219,
        85,
        40,
        85,
        117,
        85,
        194,
        86,
        15,
        86,
        92,
        86,
        169,
        86,
        247,
        87,
        68,
        87,
        146,
        87,
        224,
        88,
        47,
        88,
        125,
        88,
        203,
        89,
        26,
        89,
        105,
        89,
        184,
        90,
        7,
        90,
        86,
        90,
        166,
        90,
        245,
        91,
        69,
        91,
        149,
        91,
        229,
        92,
        53,
        92,
        134,
        92,
        214,
        93,
        39,
        93,
        120,
        93,
        201,
        94,
        26,
        94,
        108,
        94,
        189,
        95,
        15,
        95,
        97,
        95,
        179,
        96,
        5,
        96,
        87,
        96,
        170,
        96,
        252,
        97,
        79,
        97,
        162,
        97,
        245,
        98,
        73,
        98,
        156,
        98,
        240,
        99,
        67,
        99,
        151,
        99,
        235,
        100,
        64,
        100,
        148,
        100,
        233,
        101,
        61,
        101,
        146,
        101,
        231,
        102,
        61,
        102,
        146,
        102,
        232,
        103,
        61,
        103,
        147,
        103,
        233,
        104,
        63,
        104,
        150,
        104,
        236,
        105,
        67,
        105,
        154,
        105,
        241,
        106,
        72,
        106,
        159,
        106,
        247,
        107,
        79,
        107,
        167,
        107,
        255,
        108,
        87,
        108,
        175,
        109,
        8,
        109,
        96,
        109,
        185,
        110,
        18,
        110,
        107,
        110,
        196,
        111,
        30,
        111,
        120,
        111,
        209,
        112,
        43,
        112,
        134,
        112,
        224,
        113,
        58,
        113,
        149,
        113,
        240,
        114,
        75,
        114,
        166,
        115,
        1,
        115,
        93,
        115,
        184,
        116,
        20,
        116,
        112,
        116,
        204,
        117,
        40,
        117,
        133,
        117,
        225,
        118,
        62,
        118,
        155,
        118,
        248,
        119,
        86,
        119,
        179,
        120,
        17,
        120,
        110,
        120,
        204,
        121,
        42,
        121,
        137,
        121,
        231,
        122,
        70,
        122,
        165,
        123,
        4,
        123,
        99,
        123,
        194,
        124,
        33,
        124,
        129,
        124,
        225,
        125,
        65,
        125,
        161,
        126,
        1,
        126,
        98,
        126,
        194,
        127,
        35,
        127,
        132,
        127,
        229,
        128,
        71,
        128,
        168,
        129,
        10,
        129,
        107,
        129,
        205,
        130,
        48,
        130,
        146,
        130,
        244,
        131,
        87,
        131,
        186,
        132,
        29,
        132,
        128,
        132,
        227,
        133,
        71,
        133,
        171,
        134,
        14,
        134,
        114,
        134,
        215,
        135,
        59,
        135,
        159,
        136,
        4,
        136,
        105,
        136,
        206,
        137,
        51,
        137,
        153,
        137,
        254,
        138,
        100,
        138,
        202,
        139,
        48,
        139,
        150,
        139,
        252,
        140,
        99,
        140,
        202,
        141,
        49,
        141,
        152,
        141,
        255,
        142,
        102,
        142,
        206,
        143,
        54,
        143,
        158,
        144,
        6,
        144,
        110,
        144,
        214,
        145,
        63,
        145,
        168,
        146,
        17,
        146,
        122,
        146,
        227,
        147,
        77,
        147,
        182,
        148,
        32,
        148,
        138,
        148,
        244,
        149,
        95,
        149,
        201,
        150,
        52,
        150,
        159,
        151,
        10,
        151,
        117,
        151,
        224,
        152,
        76,
        152,
        184,
        153,
        36,
        153,
        144,
        153,
        252,
        154,
        104,
        154,
        213,
        155,
        66,
        155,
        175,
        156,
        28,
        156,
        137,
        156,
        247,
        157,
        100,
        157,
        210,
        158,
        64,
        158,
        174,
        159,
        29,
        159,
        139,
        159,
        250,
        160,
        105,
        160,
        216,
        161,
        71,
        161,
        182,
        162,
        38,
        162,
        150,
        163,
        6,
        163,
        118,
        163,
        230,
        164,
        86,
        164,
        199,
        165,
        56,
        165,
        169,
        166,
        26,
        166,
        139,
        166,
        253,
        167,
        110,
        167,
        224,
        168,
        82,
        168,
        196,
        169,
        55,
        169,
        169,
        170,
        28,
        170,
        143,
        171,
        2,
        171,
        117,
        171,
        233,
        172,
        92,
        172,
        208,
        173,
        68,
        173,
        184,
        174,
        45,
        174,
        161,
        175,
        22,
        175,
        139,
        176,
        0,
        176,
        117,
        176,
        234,
        177,
        96,
        177,
        214,
        178,
        75,
        178,
        194,
        179,
        56,
        179,
        174,
        180,
        37,
        180,
        156,
        181,
        19,
        181,
        138,
        182,
        1,
        182,
        121,
        182,
        240,
        183,
        104,
        183,
        224,
        184,
        89,
        184,
        209,
        185,
        74,
        185,
        194,
        186,
        59,
        186,
        181,
        187,
        46,
        187,
        167,
        188,
        33,
        188,
        155,
        189,
        21,
        189,
        143,
        190,
        10,
        190,
        132,
        190,
        255,
        191,
        122,
        191,
        245,
        192,
        112,
        192,
        236,
        193,
        103,
        193,
        227,
        194,
        95,
        194,
        219,
        195,
        88,
        195,
        212,
        196,
        81,
        196,
        206,
        197,
        75,
        197,
        200,
        198,
        70,
        198,
        195,
        199,
        65,
        199,
        191,
        200,
        61,
        200,
        188,
        201,
        58,
        201,
        185,
        202,
        56,
        202,
        183,
        203,
        54,
        203,
        182,
        204,
        53,
        204,
        181,
        205,
        53,
        205,
        181,
        206,
        54,
        206,
        182,
        207,
        55,
        207,
        184,
        208,
        57,
        208,
        186,
        209,
        60,
        209,
        190,
        210,
        63,
        210,
        193,
        211,
        68,
        211,
        198,
        212,
        73,
        212,
        203,
        213,
        78,
        213,
        209,
        214,
        85,
        214,
        216,
        215,
        92,
        215,
        224,
        216,
        100,
        216,
        232,
        217,
        108,
        217,
        241,
        218,
        118,
        218,
        251,
        219,
        128,
        220,
        5,
        220,
        138,
        221,
        16,
        221,
        150,
        222,
        28,
        222,
        162,
        223,
        41,
        223,
        175,
        224,
        54,
        224,
        189,
        225,
        68,
        225,
        204,
        226,
        83,
        226,
        219,
        227,
        99,
        227,
        235,
        228,
        115,
        228,
        252,
        229,
        132,
        230,
        13,
        230,
        150,
        231,
        31,
        231,
        169,
        232,
        50,
        232,
        188,
        233,
        70,
        233,
        208,
        234,
        91,
        234,
        229,
        235,
        112,
        235,
        251,
        236,
        134,
        237,
        17,
        237,
        156,
        238,
        40,
        238,
        180,
        239,
        64,
        239,
        204,
        240,
        88,
        240,
        229,
        241,
        114,
        241,
        255,
        242,
        140,
        243,
        25,
        243,
        167,
        244,
        52,
        244,
        194,
        245,
        80,
        245,
        222,
        246,
        109,
        246,
        251,
        247,
        138,
        248,
        25,
        248,
        168,
        249,
        56,
        249,
        199,
        250,
        87,
        250,
        231,
        251,
        119,
        252,
        7,
        252,
        152,
        253,
        41,
        253,
        186,
        254,
        75,
        254,
        220,
        255,
        109,
        255,
        255
    ];
    StiPdfResources.hatchData = [
        '000000FF00000000',
        '1010101010101010',
        '8040201008040201',
        '0102040810204080',
        '101010FF10101010',
        '8142241818244281',
        '8000000008000000',
        '0010000100100001',
        '2200880022008800',
        '2288228822882288',
        '2255885522558855',
        'AA558A55AA55A855',
        'AA55AA55AA55AA55',
        'BB55EE55BB55EE55',
        'DD77DD77DD77DD77',
        'FFDDFF77FFDDFF77',
        'FF7FFFF7FF7FFFF7',
        'FF7FFFFFFFF7FFFF',
        '8844221188442211',
        '1122448811224488',
        'CC663399CC663399',
        '993366CC993366CC',
        'E070381C0E0783C1',
        'C183070E1C3870E0',
        '4040404040404040',
        '00FF000000FF0000',
        'AAAAAAAAAAAAAAAA',
        'FF00FF00FF00FF00',
        'CCCCCCCCCCCCCCCC',
        'FFFF0000FFFF0000',
        '8844221100000000',
        '1122448800000000',
        'F00000000F000000',
        '8080808008080808',
        '0240088004200110',
        '0C8DB130031BD8C0',
        '8403304884033048',
        '00304A8100304A81',
        '0102040818244281',
        '202020FF020202FF',
        '1422518854224588',
        'F0F0F0F0AA55AA55',
        '0100201020000102',
        'AA00800080008000',
        '0020008800020088',
        '8448300C02010103',
        '33FFCCFF33FFCCFF',
        '98F8F877898F8F77',
        '111111FF111111FF',
        '3333CCCC3333CCCC',
        '0F0F0F0FF0F0F0F0',
        '0502058850205088',
        '10387CFE7C381000',
        '0000000000000000'
    ];
    StiPdfResources.standardFontWidths = null;
    StiPdfResources.standardFontInfo = null;
    StiPdfResources._standardFontCharsNames = null;
    __.b.StiPdfResources = StiPdfResources;
}
{
    let StiPdfSecurity = class {
        constructor(service) {
            this.ownerValue = [];
            this.userValue = [];
            this.ownerExtendedValue = [];
            this.userExtendedValue = [];
            this.permsValue = [];
            this.IDValue = null;
            this.encryptionKey = null;
            this.encryptionKeyLength = 0;
            this.passwordOwner = '';
            this.passwordUser = '';
            this.securityFlags = 0;
            this.keyLength = __.b.StiPdfEncryptionKeyLength.Bit40;
            this.pdfService = null;
            this.pdfService = service;
        }
        padPassword(inputPassword) {
            let password = [];
            let index = 0;
            for (; index < inputPassword.length; index++) {
                password[index] = inputPassword.charCodeAt(index);
            }
            for (let index2 = 0; index2 < StiPdfSecurity.paddingString.length; index2++) {
                password[index++] = StiPdfSecurity.paddingString[index2];
            }
            let result = [];
            for (index = 0; index < 32; index++) {
                result[index] = password[index];
            }
            return result;
        }
        computingCryptoValues(userAccessPrivileges, passwordInputOwner, passwordInputUser, keyLength, IDValue) {
            this.securityFlags = 4294967232;
            let tempFlags = 0;
            if ((userAccessPrivileges & __.b.StiUserAccessPrivileges.PrintDocument) != 0)
                tempFlags |= 1 << 2;
            if ((userAccessPrivileges & __.b.StiUserAccessPrivileges.ModifyContents) != 0)
                tempFlags |= 1 << 3;
            if ((userAccessPrivileges & __.b.StiUserAccessPrivileges.CopyTextAndGraphics) != 0)
                tempFlags |= 1 << 4;
            if ((userAccessPrivileges & __.b.StiUserAccessPrivileges.AddOrModifyTextAnnotations) != 0)
                tempFlags |= 1 << 5;
            this.securityFlags |= tempFlags;
            if (passwordInputOwner == null)
                passwordInputOwner = '';
            if (passwordInputUser == null)
                passwordInputUser = '';
            this.passwordOwner = passwordInputOwner;
            this.passwordUser = passwordInputUser;
            this.keyLength = keyLength;
            this.IDValue = IDValue;
            let encrypted = false;
            if (this.passwordOwner.length > 0 || this.passwordUser.length > 0 || userAccessPrivileges != __.b.StiUserAccessPrivileges.All) {
                encrypted = true;
                let error = this.computingCryptoValues2();
                if (!error) {
                    encrypted = false;
                    this.throwEncryptionError(0, 'Encryption not work!');
                }
            }
            return encrypted;
        }
        computingCryptoValues2() {
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128_r4)
                return this.computingCryptoValuesV4();
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r5 || this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r6)
                return this.computingCryptoValuesV5();
            let password = this.passwordOwner;
            if (StiString.isNullOrEmpty(this.passwordOwner))
                password = this.passwordUser;
            let pass1 = this.padPassword(password);
            let hash = this.computeHashMD5(pass1);
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128) {
                for (let index1 = 0; index1 < 50; index1++) {
                    hash = this.computeHashMD5(hash);
                }
            }
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit40) {
                let buf = [];
                buf[0] = hash[0];
                buf[1] = hash[1];
                buf[2] = hash[2];
                buf[3] = hash[3];
                buf[4] = hash[4];
                hash = buf;
            }
            let result1 = this.padPassword(this.passwordUser);
            result1 = this.rc4(result1, hash);
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128) {
                for (let index2 = 1; index2 <= 19; index2++) {
                    for (let tempIndex = 0; tempIndex < 16; tempIndex++) {
                        hash[tempIndex] ^= index2 - 1;
                        hash[tempIndex] ^= index2;
                    }
                    result1 = this.rc4(result1, hash);
                }
            }
            result1.stimulsoft().copyTo(this.ownerValue, 0);
            let password2 = this.passwordUser;
            let pass2 = this.padPassword(password2);
            let pp = this.getBytesUInt32(this.securityFlags);
            let ms = [];
            ms.stimulsoft().addRange(pass2);
            ms.stimulsoft().addRange(result1);
            ms.stimulsoft().addRange(pp);
            ms.stimulsoft().addRange(this.IDValue);
            hash = this.computeHashMD5(ms);
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128) {
                for (let index1 = 0; index1 < 50; index1++) {
                    hash = this.computeHashMD5(hash);
                }
            }
            this.encryptionKey = [];
            this.encryptionKeyLength = this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128 ? 16 : 5;
            for (let index = 0; index < this.encryptionKeyLength; index++) {
                this.encryptionKey[index] = hash[index];
            }
            let result2 = [];
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128) {
                ms = [];
                ms.stimulsoft().addRange(StiPdfSecurity.paddingString);
                ms.stimulsoft().addRange(this.IDValue);
                hash = this.computeHashMD5(ms);
                hash = this.rc4(hash, this.encryptionKey);
                let newKey = [];
                for (let index2 = 1; index2 <= 19; index2++) {
                    for (let tempIndex = 0; tempIndex < 16; tempIndex++) {
                        newKey[tempIndex] = this.encryptionKey[tempIndex] ^ index2;
                    }
                    hash = this.rc4(hash, newKey);
                }
                StiPdfSecurity.paddingString.stimulsoft().copyTo(result2, 0);
                hash.stimulsoft().copyTo(result2, 0);
            } else {
                StiPdfSecurity.paddingString.stimulsoft().copyTo(result2, 0);
                result2 = this.rc4(result2, this.encryptionKey);
            }
            result2.stimulsoft().copyTo(this.userValue, 0);
            return true;
        }
        computingCryptoValuesV4() {
            let password = this.passwordOwner;
            if (StiString.isNullOrEmpty(this.passwordOwner))
                password = this.passwordUser;
            let pass1 = this.padPassword(password);
            let hash = this.computeHashMD5(pass1);
            for (let index1 = 0; index1 < 50; index1++) {
                hash = this.computeHashMD5(hash);
            }
            let result1 = this.padPassword(this.passwordUser);
            result1 = this.rc4(result1, hash);
            for (let index2 = 1; index2 <= 19; index2++) {
                for (let tempIndex = 0; tempIndex < 16; tempIndex++) {
                    hash[tempIndex] ^= index2 - 1;
                    hash[tempIndex] ^= index2;
                }
                result1 = this.rc4(result1, hash);
            }
            result1.stimulsoft().copyTo(this.ownerValue, 0);
            let password2 = this.passwordUser;
            let pass2 = this.padPassword(password2);
            let pp = this.getBytesUInt32(this.securityFlags);
            let ms = [];
            ms.stimulsoft().addRange(pass2);
            ms.stimulsoft().addRange(result1);
            ms.stimulsoft().addRange(pp);
            ms.stimulsoft().addRange(this.IDValue);
            hash = this.computeHashMD5(ms);
            for (let index1 = 0; index1 < 50; index1++) {
                hash = this.computeHashMD5(hash);
            }
            this.encryptionKey = [];
            this.encryptionKeyLength = 16;
            for (let index = 0; index < this.encryptionKeyLength; index++) {
                this.encryptionKey[index] = hash[index];
            }
            let result2 = [];
            ms = [];
            ms.stimulsoft().addRange(StiPdfSecurity.paddingString);
            ms.stimulsoft().addRange(this.IDValue);
            hash = this.computeHashMD5(ms);
            hash = this.rc4(hash, this.encryptionKey);
            let newKey = [];
            for (let index2 = 1; index2 <= 19; index2++) {
                for (let tempIndex = 0; tempIndex < 16; tempIndex++) {
                    newKey[tempIndex] = this.encryptionKey[tempIndex] ^ index2;
                }
                hash = this.rc4(hash, newKey);
            }
            StiPdfSecurity.paddingString.stimulsoft().copyTo(result2, 0);
            hash.stimulsoft().copyTo(result2, 0);
            result2.stimulsoft().copyTo(this.userValue, 0);
            return true;
        }
        computingCryptoValuesV5() {
            let rnd = new Stimulsoft.System.Crypt.SecureRandom();
            let buf = null;
            let hash = null;
            let baseEncryptionKey = rnd.createNextBytes(32);
            let userValidationSalt = rnd.createNextBytes(8);
            let userKeySalt = rnd.createNextBytes(8);
            let ownerValidationSalt = rnd.createNextBytes(8);
            let ownerKeySalt = rnd.createNextBytes(8);
            let passUser = Stimulsoft.System.Text.Encoding.UTF8.getBytes(this.passwordUser);
            if (passUser.length > 127) {
                let tempBuf = [];
                StiArray.copy2(passUser, 0, tempBuf, 0, 127);
                passUser = tempBuf;
            }
            hash = this.getHashV5(passUser, userValidationSalt, null);
            hash.stimulsoft().copyTo(this.userValue, 0);
            userValidationSalt.stimulsoft().copyTo(this.userValue, 32);
            userKeySalt.stimulsoft().copyTo(this.userValue, 40);
            hash = this.getHashV5(passUser, userKeySalt, null);
            this.encodeKeyDataV5(hash, baseEncryptionKey, true).stimulsoft().copyTo(this.userExtendedValue, 0);
            let password = this.passwordOwner;
            if (StiString.isNullOrEmpty(this.passwordOwner))
                password = this.passwordUser;
            let passOwner = Stimulsoft.System.Text.Encoding.UTF8.getBytes(password);
            if (passOwner.length > 127) {
                let tempBuf = [];
                StiArray.copy2(passOwner, 0, tempBuf, 0, 127);
                passOwner = tempBuf;
            }
            hash = this.getHashV5(passOwner, ownerValidationSalt, this.userValue);
            hash.stimulsoft().copyTo(this.ownerValue, 0);
            ownerValidationSalt.stimulsoft().copyTo(this.ownerValue, 32);
            ownerKeySalt.stimulsoft().copyTo(this.ownerValue, 40);
            hash = this.getHashV5(passOwner, ownerKeySalt, this.userValue);
            this.encodeKeyDataV5(hash, baseEncryptionKey, true).stimulsoft().copyTo(this.ownerExtendedValue, 0);
            buf = rnd.createNextBytes(16);
            this.getBytesUInt32(this.securityFlags).stimulsoft().copyTo(buf, 0);
            buf[4] = 255;
            buf[5] = 255;
            buf[6] = 255;
            buf[7] = 255;
            buf[8] = 84;
            buf[9] = 97;
            buf[10] = 100;
            buf[11] = 98;
            this.permsValue = this.encodeKeyDataV5(baseEncryptionKey, buf, false);
            hash = this.getHashV5(passUser, userKeySalt, null);
            this.encryptionKey = this.decodeKeyDataV5(hash, this.userExtendedValue, true);
            buf = this.decodeKeyDataV5(this.encryptionKey, this.permsValue, false);
            if (buf[9] != 97 || buf[10] != 100 || buf[11] != 98) {
                this.throwEncryptionError(102, 'Verifying key calculation failed');
            }
            return true;
        }
        encodeKeyDataV5(key, data, cbc) {
            let result = null;
            if (cbc) {
                let iv = [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ];
                let aesCbc = new Stimulsoft.ExternalLibrary.aesjs.ModeOfOperation.cbc(key, iv);
                result = aesCbc.encrypt(data);
            } else {
                let aesCbc = new Stimulsoft.ExternalLibrary.aesjs.ModeOfOperation.ecb(key);
                result = aesCbc.encrypt(data);
            }
            let result2 = [];
            for (let index = 0; index < result.length; index++) {
                result2[index] = result[index];
            }
            return result2;
        }
        decodeKeyDataV5(key, data, cbc) {
            let result = null;
            if (cbc) {
                let iv = [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ];
                let aesCbc = new Stimulsoft.ExternalLibrary.aesjs.ModeOfOperation.cbc(key, iv);
                result = aesCbc.decrypt(data);
            } else {
                let aesCbc = new Stimulsoft.ExternalLibrary.aesjs.ModeOfOperation.ecb(key);
                result = aesCbc.decrypt(data);
            }
            let result2 = [];
            for (let index = 0; index < result.length; index++) {
                result2[index] = result[index];
            }
            return result2;
        }
        getHashV5(password, salt, ownerkey) {
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r5)
                return StiPdfSecurity.calculate_hash_r5(password, salt, ownerkey);
            else
                return StiPdfSecurity.calculate_hash_r6(password, salt, ownerkey);
        }
        static calculate_hash_r5(password, salt, ownerkey) {
            let buf = [];
            buf.stimulsoft().addRange(password);
            buf.stimulsoft().addRange(salt);
            if (ownerkey != null)
                buf.stimulsoft().addRange(ownerkey);
            return Stimulsoft.System.Crypt.SHA2.SHA256(buf);
        }
        static calculate_hash_r6(password, salt, ownerkey) {
            let data = [];
            let block = [];
            let block_size = 32;
            let data_len = 0;
            let buf = null;
            let key = [];
            let iv = [];
            let sha2 = new Stimulsoft.System.Crypt.SHA2();
            buf = [];
            buf.stimulsoft().addRange(password);
            buf.stimulsoft().addRange(salt);
            if (ownerkey != null)
                buf.stimulsoft().addRange(ownerkey);
            sha2.SHA2_256(buf).stimulsoft().copyTo(block, 0);
            for (let i = 0; i < 64 || i < data[data_len * 64 - 1] + 32; i++) {
                buf.stimulsoft().clear();
                buf.stimulsoft().addRange(password);
                for (let k = 0; k < block_size; k++) {
                    buf.push(block[k]);
                }
                data_len = password.length + block_size;
                if (ownerkey != null) {
                    buf.stimulsoft().addRange(ownerkey);
                    data_len += 48;
                }
                for (let j = 0; j < 64; j++) {
                    buf.stimulsoft().copyTo(data, j * data_len);
                }
                StiArray.copy2(block, 0, key, 0, 16);
                StiArray.copy2(block, 16, iv, 0, 16);
                let aes = new Stimulsoft.ExternalLibrary.aesjs.ModeOfOperation.cbc(key, iv);
                let result = aes.encrypt(data.slice(0, data_len * 64));
                for (let index = 0; index < result.length; index++) {
                    data[index] = result[index];
                }
                let sum = 0;
                for (let j = 0; j < 16; j++) {
                    sum += data[j];
                }
                block_size = 32 + sum % 3 * 16;
                switch (block_size) {
                case 32:
                    sha2.SHA2_256(data.slice(0, data_len * 64)).stimulsoft().copyTo(block, 0);
                    break;
                case 48:
                    sha2.SHA2_384(data.slice(0, data_len * 64)).stimulsoft().copyTo(block, 0);
                    break;
                case 64:
                    sha2.SHA2_512(data.slice(0, data_len * 64)).stimulsoft().copyTo(block, 0);
                    break;
                }
            }
            let hash = [];
            StiArray.copy2(block, 0, hash, 0, 32);
            return hash;
        }
        encryptData(data, currentObjectNumber, currentGenerationNumber) {
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit40 || this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128) {
                let objectNumber = currentObjectNumber;
                let generationNumber = currentGenerationNumber;
                let hashData = [];
                this.encryptionKey.stimulsoft().copyTo(hashData, 0);
                this.getBytesUInt32(objectNumber).stimulsoft().copyTo(hashData, this.encryptionKeyLength);
                this.getBytesUint16(generationNumber).stimulsoft().copyTo(hashData, this.encryptionKeyLength + 3);
                let hash = this.computeHashMD5(hashData);
                if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit40) {
                    hash = hash.slice(0, 10);
                }
                data = this.rc4(data, hash);
            } else if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128_r4) {
                let objectNumber = currentObjectNumber;
                let generationNumber = currentGenerationNumber;
                let hashData = [];
                this.encryptionKey.stimulsoft().copyTo(hashData, 0);
                this.getBytesUInt32(objectNumber).stimulsoft().copyTo(hashData, 16);
                this.getBytesUint16(generationNumber).stimulsoft().copyTo(hashData, 19);
                hashData[21] = 115;
                hashData[22] = 65;
                hashData[23] = 108;
                hashData[24] = 84;
                let hash = this.computeHashMD5(hashData);
                let iv = new Stimulsoft.System.Crypt.SecureRandom().createNextBytes(16);
                let forEncrypt = [];
                forEncrypt.stimulsoft().addRange(iv);
                forEncrypt.stimulsoft().addRange(data);
                forEncrypt = new Stimulsoft.ExternalLibrary.aesjs.padding.pkcs7.pad(forEncrypt);
                let aesCbc = new Stimulsoft.ExternalLibrary.aesjs.ModeOfOperation.cbc(hash, iv);
                data = aesCbc.encrypt(forEncrypt);
            } else {
                let iv = new Stimulsoft.System.Crypt.SecureRandom().createNextBytes(16);
                let forEncrypt = [];
                forEncrypt.stimulsoft().addRange(iv);
                forEncrypt.stimulsoft().addRange(data);
                forEncrypt = new Stimulsoft.ExternalLibrary.aesjs.padding.pkcs7.pad(forEncrypt);
                let aesCbc = new Stimulsoft.ExternalLibrary.aesjs.ModeOfOperation.cbc(this.encryptionKey, iv);
                data = aesCbc.encrypt(forEncrypt);
            }
            return data;
        }
        throwEncryptionError(step, st) {
            throw new Error(StiString.format('EncryptionError at step {0} : {1}', step, st));
        }
        renderEncodeRecord(sw) {
            let sbOwner = '';
            let sbUser = '';
            let sbLength = 32;
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r5 || this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r6)
                sbLength = 48;
            let index = 0;
            for (index = 0; index < sbLength; index++) {
                sbOwner += String.fromCharCode(this.ownerValue[index]);
                sbUser += String.fromCharCode(this.userValue[index]);
            }
            sw.writeLine('/Filter /Standard');
            if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128) {
                sw.writeLine('/CF<</StdCF<</AuthEvent/DocOpen/CFM/V2/Length 16>>>>');
                sw.writeLine('/StmF /StdCF');
                sw.writeLine('/StrF /StdCF');
                sw.writeLine('/R 3');
                sw.writeLine('/V 2');
                sw.writeLine('/Length 128');
            } else if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit128_r4) {
                sw.writeLine('/CF<</StdCF<</AuthEvent/DocOpen/CFM/AESV2/Length 16>>>>');
                sw.writeLine('/StmF /StdCF');
                sw.writeLine('/StrF /StdCF');
                sw.writeLine('/R 4');
                sw.writeLine('/V 4');
                sw.writeLine('/Length 128');
            } else if (this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r5 || this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r6) {
                sw.writeLine('/CF<</StdCF<</AuthEvent/DocOpen/CFM/AESV3/Length 32>>>>');
                sw.writeLine('/StmF /StdCF');
                sw.writeLine('/StrF /StdCF');
                sw.writeLine1('/R {0}', this.keyLength == __.b.StiPdfEncryptionKeyLength.Bit256_r5 ? 5 : 6);
                sw.writeLine('/V 5');
                sw.writeLine('/Length 256');
                let sbOwnerE = '';
                let sbUserE = '';
                for (index = 0; index < 32; index++) {
                    sbOwnerE += String.fromCharCode(this.ownerExtendedValue[index]);
                    sbUserE += String.fromCharCode(this.userExtendedValue[index]);
                }
                let sbPerms = '';
                for (index = 0; index < 16; index++) {
                    sbPerms += String.fromCharCode(this.permsValue[index]);
                }
                sw.writeString(StiString.format('/OE ({0})', __.b.StiPdfExportService.convertToEscapeSequencePlusTabs(sbOwnerE)), true);
                sw.writeString(StiString.format('/UE ({0})', __.b.StiPdfExportService.convertToEscapeSequencePlusTabs(sbUserE)), true);
                sw.writeString(StiString.format('/Perms ({0})', __.b.StiPdfExportService.convertToEscapeSequencePlusTabs(sbPerms)), true);
            } else {
                sw.writeLine('/R 2');
                sw.writeLine('/V 1');
                sw.writeLine('/Length 40');
            }
            sw.writeString(StiString.format('/O ({0})', __.b.StiPdfExportService.convertToEscapeSequencePlusTabs(sbOwner)), true);
            sw.writeString(StiString.format('/U ({0})', __.b.StiPdfExportService.convertToEscapeSequencePlusTabs(sbUser)), true);
            sw.writeLine1('/P {0}', this.securityFlags);
        }
        getBytesUInt32(uint) {
            let buf = [];
            buf.push(uint & 255);
            buf.push(uint >> 8 & 255);
            buf.push(uint >> 16 & 255);
            buf.push(uint >> 24 & 255);
            return buf;
        }
        getBytesUint16(uint) {
            let buf = [];
            buf.push(uint & 255);
            buf.push(uint >> 8 & 255);
            return buf;
        }
        rc4(data, key) {
            let s = [];
            let i = 0;
            let j = 0;
            let x;
            let res = [];
            let keyLength = key.length;
            let dataLength = data.length;
            for (i = 0; i < 256; i++) {
                s[i] = i;
            }
            for (i = 0; i < 256; i++) {
                j = (j + s[i] + key[i % keyLength]) % 256;
                x = s[i];
                s[i] = s[j];
                s[j] = x;
            }
            i = 0;
            j = 0;
            for (let y = 0; y < dataLength; y++) {
                i = (i + 1) % 256;
                j = (j + s[i]) % 256;
                x = s[i];
                s[i] = s[j];
                s[j] = x;
                res.push(data[y] ^ s[(s[i] + s[j]) % 256]);
            }
            return res;
        }
        computeHashMD5(data) {
            let st = '';
            for (let index = 0; index < data.length; index++) {
                st += String.fromCharCode(data[index]);
            }
            return Stimulsoft.Base.StiMD5Helper.MD5(st, false);
        }
    };
    StiPdfSecurity.paddingString = [
        40,
        191,
        78,
        94,
        78,
        117,
        138,
        65,
        100,
        0,
        78,
        86,
        255,
        250,
        1,
        8,
        46,
        46,
        0,
        182,
        208,
        104,
        62,
        128,
        47,
        12,
        169,
        254,
        100,
        83,
        105,
        122
    ];
    __.b.StiPdfSecurity = StiPdfSecurity;
}
{
    let StiPdfObjInfo = class {
        constructor() {
            this.ref = -1;
            this.info = null;
        }
        get isUsed() {
            return !(this.ref == -1);
        }
        addRef() {
            this.info.addRef(this);
        }
        toString() {
            if (this.ref == -1)
                return '-';
            return StiString.format('ref = {0}', this.ref);
        }
    };
    __.b.StiPdfObjInfo = StiPdfObjInfo;
    let StiPdfContentObjInfo = class extends StiPdfObjInfo {
    };
    __.b.StiPdfContentObjInfo = StiPdfContentObjInfo;
    let StiPdfXObjectObjInfo = class extends StiPdfObjInfo {
    };
    __.b.StiPdfXObjectObjInfo = StiPdfXObjectObjInfo;
    let StiPdfFontObjInfo = class extends StiPdfObjInfo {
    };
    __.b.StiPdfFontObjInfo = StiPdfFontObjInfo;
    let StiPdfOutlinesObjInfo = class extends StiPdfObjInfo {
    };
    __.b.StiPdfOutlinesObjInfo = StiPdfOutlinesObjInfo;
    let StiPdfPatternsObjInfo = class extends StiPdfObjInfo {
    };
    __.b.StiPdfPatternsObjInfo = StiPdfPatternsObjInfo;
    let StiPdfAnnotObjInfo = class extends StiPdfObjInfo {
    };
    __.b.StiPdfAnnotObjInfo = StiPdfAnnotObjInfo;
    let StiPdfCheckBoxObjInfo = class {
    };
    __.b.StiPdfCheckBoxObjInfo = StiPdfCheckBoxObjInfo;
    let StiPdfAcroFormObjInfo = class extends StiPdfObjInfo {
    };
    __.b.StiPdfAcroFormObjInfo = StiPdfAcroFormObjInfo;
    __.b.StiPdfStructure = class {
        constructor() {
            this.objectsCounter = 0;
            this.objects = null;
            this.objectsCounter = 0;
            this.objects = [];
            this.root = this.createObject(true);
            this.info = this.createObject(true);
            this.colorSpace = this.createObject(true);
            this.pages = this.createObject(true);
            this.structTreeRoot = this.createObject(true);
            this.optionalContentGroup = this.createObject(true);
            this.pageList = [];
            this.xObjectList = [];
            this.fontList = [];
            this.linkList = [];
            this.embeddedFilesList = [];
        }
        addRef(info) {
            this.objectsCounter++;
            info.ref = this.objectsCounter;
        }
        createObject(addRef = false) {
            let obj = new StiPdfObjInfo();
            obj.info = this;
            if (addRef)
                this.addRef(obj);
            return obj;
        }
        createContentObject(addRef = false) {
            let obj = new StiPdfContentObjInfo();
            obj.info = this;
            if (addRef)
                this.addRef(obj);
            obj.content = this.createObject(addRef);
            return obj;
        }
        createXObject(addRef = false, haveMask = false) {
            let obj = new StiPdfXObjectObjInfo();
            obj.info = this;
            if (addRef)
                this.addRef(obj);
            obj.mask = this.createObject(addRef && haveMask);
            return obj;
        }
        createFontObject(addRef = false, useUnicodeMode = true, standardPdfFonts = false, embeddedFonts = true, annotFont = false) {
            let obj = new StiPdfFontObjInfo();
            obj.info = this;
            if (addRef)
                this.addRef(obj);
            obj.descendantFont = this.createObject(addRef && useUnicodeMode);
            obj.toUnicode = this.createObject(addRef && useUnicodeMode);
            obj.cIDSet = this.createObject(addRef && useUnicodeMode);
            obj.encoding = this.createObject(addRef && !useUnicodeMode && !annotFont);
            obj.fontDescriptor = this.createObject(addRef && !standardPdfFonts);
            obj.fontFile2 = this.createObject(addRef && embeddedFonts);
            return obj;
        }
        createOutlinesObject(addRef = false) {
            let obj = new StiPdfOutlinesObjInfo();
            obj.info = this;
            if (addRef)
                this.addRef(obj);
            obj.items = [];
            return obj;
        }
        createPatternsObject(addRef = false) {
            let obj = new StiPdfPatternsObjInfo();
            obj.info = this;
            obj.resources = this.createObject(addRef);
            obj.first = this.createObject(addRef);
            obj.hatchItems = [];
            obj.shadingItems = [];
            obj.shadingFunctionItems = [];
            return obj;
        }
        createAcroFormObject(addRef = false) {
            let obj = new StiPdfAcroFormObjInfo();
            obj.info = this;
            if (addRef)
                this.addRef(obj);
            obj.annots = [];
            obj.checkBoxes = [];
            obj.unsignedSignatures = [];
            obj.signatures = [];
            obj.tooltips = [];
            obj.annotFontItems = [];
            return obj;
        }
        createAnnotObject(addRef = false, createAP = false, numberAA = 0) {
            let obj = new StiPdfAnnotObjInfo();
            obj.info = this;
            if (addRef)
                this.addRef(obj);
            obj.aP = this.createObject(addRef && createAP);
            obj.aA = [];
            for (let index = 0; index < numberAA; index++) {
                obj.aA.push(this.createObject(addRef));
            }
            return obj;
        }
    };
}
(function (Stimulsoft) {
    var Reflection;
    (function (Reflection) {
        class StiTypesHelper {
            static run(type, namespace) {
                if (type === undefined) {
                    StiTypesHelper.run(Stimulsoft, 'Stimulsoft');
                    return;
                }
                namespace = namespace.stimulsoft().replaceAll('Stimulsoft.System', 'System');
                for (let name in type) {
                    if (typeof type[name] == 'function') {
                        type[name].ssTypeName = name;
                        type[name].ssNamespace = namespace;
                    } else if (typeof type[name] == 'object') {
                        StiTypesHelper.run(type[name], namespace + '.' + name);
                    }
                }
            }
        }
        Reflection.StiTypesHelper = StiTypesHelper;
    }(Reflection = Stimulsoft.Reflection || (Stimulsoft.Reflection = {})));
}(Stimulsoft || (Stimulsoft = {})));
Stimulsoft.Reflection.StiTypesHelper.run();;;
return { Stimulsoft };
})